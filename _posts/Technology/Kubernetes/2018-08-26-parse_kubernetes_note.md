---

layout: post
title: 《深入剖析kubernetes》笔记
category: 技术
tags: Kubernetes
keywords: kubernetes 

---

## 简介(会不断增补)

本文来自对极客时间《深入剖析kubernetes》的学习，作者本身对k8s 有一定的基础，但认为同样一个事情 听听别人 如何理解、表述 是很有裨益的，尤其是作者 还是k8s 领域的大牛。

作者在开篇中提到的几个问题 ，也是笔者一直的疑惑

1. 容器技术纷繁复杂，“牵一发而动全身”的主线 在哪里
2. Linux 内核、分布式系统、网络、存储等方方面面的知识，并不会在docker 和 k8s 的文档中交代清楚。可偏偏就是它们，才是真正掌握容器技术体系的精髓所在，是我们需要悉心修炼的内功。

## 一个很长但精彩的故事

### 打包发布阶段

在docker 之前有一个 cloud foundry Paas项目，使用`cf push` 将用户的可执行文件和 启动脚本打进一个压缩包内，上传到cloud foundry 的存储中，然后cloud foundry 会通过调度器选择一个可以运行这个应用的虚拟机，然后通知这个机器上的agent 把应用压缩包下载下来启动。由于需要在一个虚拟机中 启动不同用户的应用，cloud foundry为客户的应用单独创建一个称作沙盒的隔离环境，然后在沙盒中启动这些应用进程。

PaaS 主要是提供了一种名叫“应用托管”的能力。虚拟机技术发展 ==> 客户不自己维护物理机、转而购买虚拟机服务，按需使用 ==> 应用需要部署到云端 ==> 部署时云端虚拟机和本地环境不一致。所以产生了两种思路

1. 将云端虚拟机 做的尽量与 本地环境一样
2. 无论本地还是云端，代码都跑在 约定的环境里 ==> docker 镜像的精髓

与《尽在双11》作者提到的 “docker 最重要的特质是docker 镜像” 一致，docker 镜像提供了一种非常便利的打包机制。

### 农村包围城市

为应对docker 一家在容器领域一家独大的情况，google 等制定了一套标准和规范OCI，意在将容器运行时和镜像的实现从Docker 项目中完全剥离出来。然并卵，Docker 是容器领域事实上的标准。为此，google 将战争引向容器之上的平台层（或者说PaaS层），发起了一个名为CNCF的基金会。所谓平台层，就是除容器化、容器编排之外，推动容器监控、存储层、日志手机、微服务（lstio）等项目百花争鸣，与kubernetes 融为一体。

此时，kubernetes 对docker 依赖的只是一个 OCI 接口，docker 仍然是容器化的基础组件，但其 重要性在 平台化的 角度下已经大大下降了。若是kubernetes 说不支持 docker？那么。。。

笔者负责将公司的测试环境docker化，一直为是否使用kubernetes 替换mesos 而纠结，从现在看：

1. 笔者要做的其实是一个PaaS的事情
1. 单从“测试环境docker化” 来看（将PaaS理解为 打包发布），mesos 也是够用的。
2. 打包发布不是全部，加上编排也不是。就好像一个公司的技术组织架构，靠业务组写业务代码赚钱，但光有业务组是不够的。我们在用docker，更是在搭建一套稳定的 运行平台。

这让笔者想到了孟子说的“民为重、社稷次之、君为轻”，docker 和 kubernetes 的博弈历程 充分的体现了：最重要的角色 如何 演变成 一件可以最重要 也可以 不太重要的角色。

java 是一个单机版的业务逻辑实现语言，但在微服务架构成为标配的今天，服务发现、日志监控报警、熔断等也成为必备组件（spring cloud 提供了完整的一套）。如果这些组件 都可以使用协议来定义，那么最后用不用java 来写业务逻辑就不是那么重要了。

借用同事的一句总结：之前在应用程序里做的或者利用第三方工具做的微服务治理的事情，被下放到paas平台来负责。类似很多jvm兼容的脚本语言，groovy，scala等是以jvm为中心。而微服务以paas为中心，不以类似dubbo之类的框架为中心。如果以框架为中心，那么PaaS 只做打包和发布就行了，若是以PaaS 为中心，服务发现、路由、监控这类事PaaS就要做起来。


## docker

[docker中涉及到的一些linux知识](http://qiankunli.github.io/2016/12/02/linux_docker.html)

有哪些容器与虚拟机表现不一致的问题? 本质上还是共享内核的问题

1. 很多资源无法隔离，也就是说隔离是不彻底的。比如宿主机的 时间，你设置为0时区，我设置为东八区，肯定乱套了
2. 很多linux 命令依赖 /proc，比如top，而 容器内/proc 反应的是 宿主机的信息

对于大多数开发者而言，他们对应用依赖的理解，一直局限在编程语言层面，比如golang的godeps.json。容器镜像 打包的不只是应用， 还有整个操作系统的文件和目录。这就意味着，应用以及它运行所需要的所有依赖，都被封装在了一起，进而成为“沙盒”的一部分。参见 [linux 文件系统](http://qiankunli.github.io/2018/05/19/linux_file_mount.html)


![](/public/upload/kubernetes/parse_k8s_ad.JPG)

笔者个人微信订阅号

![](/public/upload/qrcode_for_gh.jpg)
