---

layout: post
title: 《clean code》笔记
category: 技术
tags: Other
keywords: clean code

---

## 前言


## 具体细节

1. 函数只做该函数名下同一抽象层上的步骤，函数中的语句都要在同一抽象层级上。
2. 给变量、函数、类起一个有意义的名字。**这个知道的多，做到的少。**

	* 比如测试类的测试方法写一个test就完事

3. 最理想的参数数量是0，其次是一，再次是二，应尽量避免三。为何？参数与函数名通常处在不同的抽象层级，它要求你了解目前并不特别重要的细节。从测试角度看，参数更让人为难。
4. 输出参数更让人难以理解。

	* 在面向对象编程之前的岁月里，有时的确需要输出参数。然而，面向对象语言中对输出参数的大部分需求已经消失了，因为this也有输出函数的意味在内。
	* writeField(outputStream,name) 可以把writeField写成outputStream的成员之一；把outputStream 写成当前类的成员变量，从而无需传递它；还可以分离出FieldWriter类，在其构造方法中采用outputStream，并且包含一个write方法。
	
5. 函数要么做什么事，要么回答什么事儿，这二者不可兼得。**不可能兼得的原因不是写起来有问题，而是用起来经常会带来可读性损失。**
6. 重复可能是软件中一切邪恶的根源，面向对象的继承、aop、面向组件编程多少都是消除重复的策略
7. 写代码和写别的东西很像，在写论文或文章时，你先想写什么就写什么，然后再打磨它。初稿也许粗陋无序，你就斟酌推敲，直至达到你心目中的样子。**关键是，你别写完代码就写别的代码去了**
8. 如果你做好了上述细节，那么基本不需要注释，**注释是一种失败**，原因很简单：程序猿不能坚持维护注释。
9. 代码格式关乎沟通，而沟通是代码开发者的头等大事，而不是“让代码能工作”。
10. 如果一个函数很长，那么通常需要拆分。一个变量列表很长，通常也需要拆分。
11. 错误处理

	* 使用异常而非返回码
12. 测试代码和生产代码一样重要，它需要被思考、设计和照料，没有了测试，你就很难做改动。

	* 测试应该有布尔值输出，你不应查看日志文件来确认测试是否通过
	* 正常的业务代码中，或许应为方便测试留有一席之地。比如，一个对象虽然理论上只需提供get方法，但为了方便测试，可以提供set方法以直接注入demo数据。

这些具体细节与《重构——改善既有代码的设计》是相辅相成的

1. 前者突出编写代码（代码还未完成），后者突出重构。
2. 以方法为例，前者要求“方法参数越少越好，不要超过三个”（“坏味道”描述的比较明确），后者提出重构方法的各种技巧。
3. 知道重构的技巧并不是难点，这又回到了老问题：知易行难，还是知难行易。


看到本小节，就可以发现，整洁代码，关系到代码的方方面面。除了实现功能，若是将整洁代码也加入到写代码的过程中，将更容易发现代码应重构的地方。

## 对象和数据结构

对比以下两个定义：

	public class Point{
		public double x;
		public double y;
	}
	
	public class Point{
		private double x;
		private double y;
		public void setX(double x){
			this.x = x;
		}
		public double getX(){
			return x;
		}
		public void setY(double y){
			this.y = y;
		}
		public double getY(){
			return y;
		}
	}
	
	public interface Point{
		double getX();
		double getY();
		void setCartesian(double x,double y);
		double getR();
		double getTheta();
		void setPolar(double r,double theta);
	}

第一段和第二段代码本质是一样的，第三段代码漂亮之处在于：

1. 你不知道该实现会是在矩形坐标系中，还是在极坐标系中，可能两个都不是！然而，该接口还是明白无误的呈现了一种数据结构。
2. 固定了一套存取策略，你可以单独读取某个坐标，但必须通过一次原子操作设定所有坐标。

无论出于怎样的初衷，setter/getter都把私有变量公开化，诱导外部函数以过程式程序使用数据结构的方式使用这些变量。

隐藏实现并非只是在变量之间放上一个函数层那么简单，隐藏实现关乎抽象！第一/二段代码更像数据结构，暴露其数据，没有提供有意义的函数。第三段代码，对象，把数据隐藏于抽象之后，暴露操作数据的函数（暴露行为）。暴露什么，不暴露什么，直接暴露，还是间接操作，都关于抽象。

过程式代码（使用数据结构的代码）便于在不改动既有数据结构的前提下添加新函数，面向对象代码便于在不改动既有函数的前提下添加新类。**老练的程序猿知道，一切都是对象只是一个传说，合适的才是最好的**。比如dto，本身就是为了传输数据存在的，全是setter/getter 方法。

||行为|数据|
|---|---|---|
|对象|暴露|隐藏|
|数据结构|没有|暴露|

隐藏什么，就容易更改什么。暴露什么，就难以新增什么。

## controller ==> service ==》 dao 后遗症

1. 过程式代码，基本无需抽象也能完成工作
2. object bean 概念的引入，简化了j2ee开发，但也将“抽象” 阉割了。大量类创建和转换代码出现在service类的方法中。

	



