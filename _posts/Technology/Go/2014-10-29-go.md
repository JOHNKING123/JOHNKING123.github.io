---

layout: post
title: Go初学
category: 技术
tags: Go
keywords: Go

---

## 简介

* TOC
{:toc}

on the last 20 years, we have lived an incredible growth in computer science. Storage spaces have been increased dramatically,RAM has suffered a substantial growth, and cpu's aare well simply faster. CPU industry has reached a limit. The CPU manufacturers are now shipping more cores on each computers. This situation crashes against the background of many systems programming languages that weren't designed for multi-processor CPUs or large distributed systems that act as a unique machine.

our programers were bigger,more complex,more difficult to maintain and **with a lot of room for bad practices**. While our computers had more cores and were faster,we were not faster when developing our code neither our distributed applications. 代码规模规模越来越大，越来越容易出错。

## 为什么要学习新的语言 ##

我本来是Java方向的，为什么打算换“东家”呢？

1. 程序员要多会一点，有人提出一个观点：即使这个语言过时了，学习一下也是很有必要的，因为这让你从另一个角度来观察问题，看到新的方式去解决问题。扩展的了解“什么死的，什么是可以变通的”。
2. 多核化和集群化渐渐成为主流，而JAVA是上一个时代单机服务器时的产品，虽然它现在也在努力跟上潮流。
3. **JAVA语法还是不够简单**。熟悉java多线程的人都知道，wait方法的调用必须在synchronized块中。并且，实现线程要继承Thread或者实现Runnable。总之，在java中开发多线程程序细节很多，能力要求也很高，是面试题的重要来源地。在未来的编程事业中，人们越来越关注实现业务本身，而实现业务所需的技术细节将主要由编程语言来实现。比如在Go语言中，实现一个线程将由一个关键字表示，学习的复杂性大大下降。
4. 当然，决定语言发展趋势的因素有很多。若只考虑易用性，C语言早该回家抱孩子了。从长远讲，语言要么效率足够高，要么足够简单，处在中间状态的语言会很尴尬！

## go语言的一点特性

所有函数参数都是传值的，只是一些参数底层结构的差异，导致它们传值的影响并不完全相同。

    func re2(a *[2]int){
    	(*a)[1]= 3
    }
    func re3(a *[2]int){
    	a = nil
    }
    func Test2(){
    	a := &[2]int{1,2}
    	re2(a)
    	for _,v := range a {
    		fmt.Println(v)
    	}
    	re3(a)    
    	fmt.Println(a)
    }
    输出：
    1    
    3         // 改变a指向的结构的内容的值
    &[1 3]    // 改变a的值（失效）

### 类型转换和类型断言

类型断言貌似是，一个大类型，比如`interface{}`，我怀疑它可能是字符串，则可以`xxx.(string)`

类型转换的情况比较多：

1. 同一类型的转换，比如int64与int
2. 某类型与字符串的转换，这个有专门的包
3. 字符串与字符/short数组的转换，比如string与`[]uint8`等

### 《go desgin patterns》未完成

结构体：a struct is an object in Go. It has some similarities with classes in OOP as they have fields. Structs can implement interfaces and declare methods. But, for example, in Go, there's not inheritance. Lack of inheritance looks limiting but in fact , **composition over inheritance was a requirement of the language**. The Go language, by nature,encourages use of composition almost exclusively by its lack of inheritance.Composition pattern is a very idiomatic（地道的） Go feature. PS：最佳实践生生变成了 语法 

对C来说：

1. 通过指针实现”传引用“而不是传值，本质上节约了数据传输性能
2. 光支持指针不是C出彩的地方，要支持指针的运算（对指针加减，甚至取指针）才是c类语言强大的地方。只支持传引用的语言很多。

方法带不带指针：`(p *Person)` refers to a pointer to the created instance of the Person struct. it is like using the keyword `this` in Java or `self` in Python when referring to the pointing object.
`(p Person)` is a copy of the value of Person ia passed to the function. any change that you make in  p if you pass it by value won't be reflected in source `p`.


    func (p *Person)GetFullName() string{
        return fmt.Println("%s %s",p.Name,p.Surname)
    }
    func (p Person)GetFullName() string{
        return fmt.Println("%s %s",p.Name,p.Surname)
    }

接口：interfaces are enssential in object-oriented programming, in functional programming(traits) and, especially,in design patterns. they provide the abstracton needed to deliver uncoupled(非耦合的)code with the help of functions.

工厂模式：the objectives of the Factory method design pattern
1. delegating the creation of new instances of structures to a different part of the program. 隔离创建与使用部分. 
2. **working at the interface level instead of with concrete**
3. grouping families of objects to obtain a family object creator.

    
## go runtime

提到 runtime, 大家可能会想起 java, python 的 runtime. 不过 go 和这两者不太一样, java, python 的 runtime 是虚拟机, 而 go 的 runtime 和用户代码一起编译到一个可执行文件中.用户代码和 runtime 代码除了代码组织上有界限外, 运行的时候并没有明显的界限. 一些常用的关键字被编译成 runtime 包下的一些函数调用.


Golang runtime 是go语言运行所需要的基础设施
1. 协程调度、内存分配、GC
2. 操作系统及cpu 相关的操作的封装（信号处理、系统调用、寄存器操作、原子操作等）CGO。go 对系统调用进行了封装，可不依赖glibc
3. pprof,trace,race 检测的支持
4. map,channel,string 等内置类型及反射的实现

## Go Test

我们测试一个函数的功能，就必须要运行该函数，而这往往是由main函数开始触发的。在大型项目中，测试一个函数的功能，总是劳驾main函数很不方便，于是我们可以使用`go test`功能。

假设存在`a.go`文件（文件中包含Add方法），我们只要在相同目录下创建`a_test.go`文件，在该目录下运行`go test`即可。（这将运行该目录下所有"_test"后缀文件中的带有“Test_”前缀的方法）

    package main
    import (
    	"fmt"
    	"testing"
    )
    func Test_Add(t *testing.T) {
    	re := Add(3,4)
    	fmt.Println(re)
    	// 如果没有抛出error，则运行go test将显示“PASS”
    }



## 包管理

Golang使用包（package）这种语法元素来组织源码，所有**语法可见性均定义在package这个级别**，与Java 、python等语言相比，这算不上什么创新，但与C传统的include相比，则是显得“先进”了许多。参见[理解Golang包导入](http://tonybai.com/2015/03/09/understanding-import-packages/)


||编译|install|
|---|---|---|
|maven|mvn build|mvn install|
|go|go build|go install|

`go build`后面可以是文件，也可以是目录，但该目录必须包含带`func main()`的文件，**有且只有一个**。所以，如果只是简单测一个功能，一个目录下可以有多个带`func main()`的文件，直接`go build xx.go`，`go build 目录`则无法通过。


## 补充

erlang和go有很大的渊源，Joe Armstrong在他的论文中《面对软件错误构建可靠的分布式系统》是这样介绍erlang的。

- Erlang顺序化编程
- 并行编程
- 错误处理

    不要把处理“正常情况” 的代码和处理异常的代码搅和在一起。 (这一点，其实java做的不错)
    
- 分布式编程
- 动态代码替换

由此我们可以发现，上述特性慢慢在语言层面提供支持（java的并行编程只是对操作系统调用的封装），而我们过去在学习一种语言时，其实只是了解了"顺序化编程"的部分。

总之，就是“面向'进程'编程（进程是程序的基本模块）”，进程之间的通信采用消息队列。至于为什么，可以参见大牛的论文。






