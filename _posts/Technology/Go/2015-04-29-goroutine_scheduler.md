---

layout: post
title: Goroutine 调度模型
category: 技术
tags: Go
keywords: Go goroutine

---

## 前言

go语言的一个重大特色就是支持协程（coroutine），即用户级线程。由运行在用户态程序实现“执行体”的调度和切换（本文将一个可并发执行的逻辑单元称为“执行体”），整个过程运行在一个或多个线程上，执行体切换过程不用“陷入”内核态，因此较为轻量。

[万字长文深入浅出 Golang Runtime](https://zhuanlan.zhihu.com/p/95056679)调度在计算机中是分配工作所需资源的方法，linux的调度为CPU找到可运行的线程，而Go的调度是为M（线程）找到P（内存、执行票据）和可运行的G。

## goroutine调度模型的四个抽象

[万字长文深入浅出 Golang Runtime](https://zhuanlan.zhihu.com/p/95056679)对操作系统有过一些了解, 知道 linux 下的线程其实是 task_struct 结构, 线程其实并不是真正运行的实体, **线程只是代表一个执行流和其状态**.真正运行驱动流程往前的其实是 CPU. CPU 在时钟的驱动下, 根据 PC 寄存器从程序中取指令和操作数, 从 RAM 中取数据, 进行计算, 处理, 跳转, 驱动执行流往前. CPU 并不关注处理的是线程还是协程, 只需要设置 PC 寄存器, 设置栈指针等(这些称为上下文), 那么 CPU 就可以欢快的运行这个线程或者这个协程了.线程的运行, 其实是被运行.其阻塞, 其实是切换出调度队列, 不再去调度执行这个执行流. 其他执行流满足其条件, 便会把被移出调度队列的执行流重新放回调度队列.

goroutine调度模型4个重要结构，分别是M、G、P、Sched，前三个定义在runtime.h中，Sched定义在proc.c中。

- Sched结构就是调度器，它维护有存储M和G的队列（全局的）以及调度器的一些状态信息等。
- M代表内核级线程，一个M就是一个线程，goroutine就是跑在M之上 ；M是一个很大的结构，里面维护小对象内存cache（mcache）、当前执行的goroutine、随机数发生器等等非常多的信息。
- P全称是Processor，处理器，它的主要用途就是用来执行goroutine的，所以它也维护了一个goroutine队列，里面存储了所有需要它来执行的goroutine。
- G就是goroutine实现的核心结构了，G维护了goroutine需要的栈、程序计数器以及它所在的M等信息。一个协程代表了一个执行流，执行流有需要执行的函数(startpc)，有函数的入参，有当前执行流的状态和进度(对应 CPU 的 PC 寄存器和 SP 寄存器)，当然也需要有保存状态的地方，用于执行流恢复。

`$GOROOT/src/runtime/runtime2.go`

![](/public/upload/go/go_scheduler_object.png)

## 线程视角的由简到繁

### 单线程上的协程调度模型

假设只有一个线程，该线程运行一个调度程序，调度程序从其管理的执行体集合中取出一个执行体交给线程执行。该线程执行逻辑如下：

![Alt text](/public/upload/go/one_thread.png)

如果考虑执行体各种非正常退出的情况：

![Alt text](/public/upload/go/one_thread2.png)

由此我们可以确定，实现该线程逻辑需要两个抽象：执行体和调度程序。

- 执行体包含：执行体的上下文环境，执行逻辑等
- 调度程序：执行体集合（链表），执行体切换等

该模型有两个问题：

- 除非执行体执行完毕、主动放弃或调用系统调用，执行体将一直“占用”线程。调度器因为没有“占用”线程，也只能干看着。这种非抢占式方式是协程调度模型的通病。
- 执行体执行过程中可能向执行体集合添加新的执行体，导致该线程负担过大。


### 多个线程上协程调度模型

可以想见，如果只是运行在一个线程上，那么goroutine也太简单了，接下来谈谈运行在多个线程上的情况。

不管是运行在几个线程上，线程总得一个一个启动，下图是第一个线程的运行逻辑。当然，在第一个线程启动前，肯定要为整个调度模型做一些数据结构的初始化工作。

![Alt text](/public/upload/go/multi_thread.png)

多个线程上调度跟单个线程调度有一个很大的不同就是：一旦执行体链表包含的执行体过多，就需要开启新的线程，转移部分执行体。反之，如果某个线程执行体链表为空，则需要从全局链表或其它线程那里“挖”执行体。

执行体本身是有状态的。

- 主动放弃执行。将执行体设置为runnable状态，然后放入到全局执行体集合。（看来执行体主动放弃执行，不仅是放弃所在线程的执行机会，还不想在本线程继续呆了）
- channel操作和网络操作等。执行体被置为wating状态，从本线程执行体集合中剥离，直到其依赖的条件满足。
- 调用系统调用。

第一个线程开始执行后，go调度模型还会创建一个sysmon线程（负责监控，不运行执行体）还有一个问题，那就是**一旦执行体中调用系统调用，整个线程会被阻塞。为了不影响线程中其它执行体的执行，Go语言完全是自己封装的系统调用，所以在封装系统调用的时候，可以做不少手脚**，也就是进入系统调用的时候执行entersyscall，退出后又执行exitsyscall函数。entersyscall将执行体从当前执行体链表中剥离，并将改变P的状态为syscall。Sysmon监控线程会扫描所有的P，发现一个P处于了syscall的状态，就知道这个P遇到了执行体在做系统调用，于是系统监控线程就会创建一个新的线程去把这个处于syscall的P给抢过来，开始干活，这样这个小车中的其它执行体就可以绕过之前系统调用的等待了。被抢走P的线程等系统调用返回后，发现自己的P没了，不能继续干活了，于是只能把执行系统调用的执行体放回到全局链表中，自己睡觉去了。

## 队列视角的由简到繁

### GM模型

go1.1 之前都是该模型

![](/public/upload/go/go_scheduler_gm.jpg)

### GPM模型

几个问题

1. 为什么引入Processor 的概念
2. 为什么把全局队列打散. 对该队列的操作均需要竞争同一把锁, 导致伸缩性不好.
新生成的协程也会放入全局的队列, 大概率是被其他 m(可以理解为底层线程的一个表示)运行了, 内存亲和性不好. 
3. mcache 为什么跟随 P
4. 为什么 P 的个数默认是 CPU 核数: Go 尽量提升性能, 那么在一个 n 核机器上, 如何能够最大利用 CPU 性能呢? 当然是同时有 n 个线程在并行运行中, 把 CPU 喂饱, 即所有核上一直都有代码在运行.

![](/public/upload/go/go_scheduler_gpm.jpg)

![](/public/upload/go/go_scheduler_goroutine_status.jpg)

并没有一个一直在运行调度的调度器实体. 当一个协程切换出去或新生成的 m, go 的运行时从 stw 中恢复等情况时, 那么接下来就需要发生调度. go 的调度是通过线程(m)执行 runtime.schedule 函数来完成的. PS：就好像linux 进程会主动调用schedule() 触发调度，只是linux 多了时间片中断主动触发调度而已。

在 linux 内核中有一些执行定时任务的线程, 比如定时写回脏页的 pdflush, 定期回收内存的 kswapd0, 以及每个 cpu 上都有一个负责负载均衡的 migration 线程等.在 go 运行时中也有类似的协程, sysmon.功能比较多: 定时从 netpoll 中获取 ready 的协程, 进行抢占, 定时 GC,打印调度信息,归还内存等定时任务.

协作式抢占：基本流程是 sysmon 协程标记某个协程运行过久, 需要切换出去, 该协程在运行函数时会检查栈标记, 然后进行切换.

## 补充

笔者今日学习Joe Armstrong的博士论文《面对软件错误构建可靠的分布式系统》，文中提到“在构建可容错软件系统的过程中要解决的本质问题就是故障隔离。”操作系统进程本身就是一种天然的故障隔离机制，当然从另一个层面，进程间还是因为共享cpu和内存等原因相互影响。进程要想达到容错性，就不能与其他进程有共享状态；它与其他进程的唯一联系就是由内核消息系统传递的消息。 

## 参考文献


[goroutine与调度器](http://blog.csdn.net/chanshimudingxi/article/details/40855467)