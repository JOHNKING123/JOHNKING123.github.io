---

layout: post
title: 《Mysql实战45讲》笔记
category: 技术
tags: Storage
keywords: Redis

---

## 前言（持续更新）

* TOC
{:toc}

## 基本架构

![](/public/upload/storage/mysql_architecture.png)

查询缓存：key 是查询的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会被直接返回给客户端。**大多数情况下我会建议你不要使用查询缓存**，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。MySQL 8.0 版本直接将查询缓存的整块功能删掉了

crash-safe 能力：保证即使数据库发生异常重启，之前提交的记录都不会丢失。日志系统
1. Server层日志/binlog。最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。
1. 存储引擎层日志。当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面。redo log 是固定大小的，如果redo log 写满了（write ops-checkpoint），就不能再执行更新操作了，得停下来将内存数据写到磁盘（把checkpoint 推进一下）。

||redo log|binlog|
|---|---|---|
|层次|InnoDB 引擎特有的|Server 层实现|
|内容|物理日志<br>记录的是“在某个数据页上做了什么修改”|逻辑日志<br>记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1”|
|写的方式|循环写<br>空间固定会用完|追加写<br>写到一定大小后会切换到下一个，并不会覆盖以前的日志|


**事务支持是在引擎层实现的**。

**索引是在存储引擎层实现的**。在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。**根据叶子节点的内容**，索引类型分为主键索引和非主键索引。

假设你的表中确实有一个唯一字段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？
1. 自增主键的插入数据模式，每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。而身份证号做主键，则往往不容易保证有序插入，这样写数据成本相对较高。
2. 每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约 20 个字节，而如果用整型做主键，则只要 4 个字节。**主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小**。
3. 典型的 KV 场景适合用业务字段直接做主键：只有一个索引；该索引必须是唯一索引。