---

layout: post
title: 苹果APNs推送框架pushy
category: 技术
tags: Netty
keywords: JAVA APNs 苹果推送

---

## 前言

了解netty及其相关框架，最好事先了解下异步编程思想[异步编程](http://qiankunli.github.io/2017/05/16/async_servlet.html)

[relayrides/pushy](https://github.com/relayrides/pushy)是一个 Java library for sending APNs (iOS, OS X, and Safari) push notifications. 揉和了netty和http2协议。因此，除了它本身的功能外，从中也可以学到许多对netty框架以及http2协议的使用技巧。

其它基于http2的apns客户端[linkedkeeper/apns-http2](https://github.com/linkedkeeper/apns-http2)，文章[浅谈基于HTTP2推送消息到APNs](http://www.linkedkeeper.com/detail/blog.action?bid=167)

## 对外接口

    // 构建payload
    ApnsPayloadBuilder payloadBuilder = new ApnsPayloadBuilder();
    payloadBuilder.setAlertBody("Example!");
    String payload = payloadBuilder.buildWithDefaultMaximumLength();
    String token = TokenUtil.sanitizeTokenString("<efc7492 bdbd8209>");
    // 构建推送model
    SimpleApnsPushNotification  pushNotification = new SimpleApnsPushNotification(token, "com.example.myApp", payload);
    // 发送
	Future<PushNotificationResponse<SimpleApnsPushNotification>> sendNotificationFuture = apnsClient.sendNotification(pushNotification);

一般netty的启动逻辑

	EventLoopGroup group = new NioEventLoopGroup();
    try {
       	Bootstrap b = new Bootstrap();
       	b.group(group)
               .channel(NioSocketChannel.class)
               .handler(new ChannelInitializer<SocketChannel>() {
                   protected void initChannel(SocketChannel ch) throws Exception {
                       ch.pipeline().addLast(new DelimiterBasedFrameDecoder(1024, delimiter));
                       ch.pipeline().addLast(new StringDecoder());
                       ch.pipeline().addLast(new EchoClientHandler());
                   }
               });
       	ChannelFuture f = b.connect(host, port).sync();
       	f.channel().closeFuture().sync();
   	} finally {
        group.shutdownGracefully();
   	}

可以看到，两者差异还是蛮大的。

## 整体结构

![](/public/upload/netty/pushy_object.png)

send notification 流程

![](/public/upload/netty/pushy_send_notification.png)

## 从pushy中学到的

### ChannelGroup

A thread-safe  Set that contains open Channels and provides various bulk operations on them. 管理所有channel，提供批量操作，比如`ChannelGroupFuture write(Object message)` 的实现便是 遍历所有channel并执行`channel.write`

A closed Channel is automatically removed from the collection, so that you don't need to worry about the life cycle of the added Channel. 

    private final ChannelFutureListener remover = new ChannelFutureListener() {
        public void operationComplete(ChannelFuture future) throws Exception {
            remove(future.channel());
        }
    };

ChannelGroup 监听了所管理的每一个channel的close 事件

    public boolean add(Channel channel) {
        ConcurrentMap<ChannelId, Channel> map = xx;
        boolean added = map.putIfAbsent(channel.id(), channel) == null;
        if (added) {
            channel.closeFuture().addListener(remover);
        }
        ...
        return added;
    }

### ApnsChannelPool.acquire

![](/public/upload/netty/pushy_acquire_channel.png)

### 既写又读的handler

一般框架Client，通过一个id关联request和response(通过future来获取)，这个future要在多个类之间传递。

	class Client{
		Map<id,future> map;
		Future<Response> send(request){
			future = new xxx;
			map.put(id,future);
			channel.write(request).addListener(new xx{
				onComplete(){
					xxx
					future.set(xx)
				}
			});
			return future;
		}
	}
	class ReceiveHandler{
		Map<id,future> map;
		onDataReceive(response){
			future = map.get(response.getId());
			future.set(xx)
		}
	}
	
而pushy则是

	class ApnsClient{
		Future<Response> send(request){
			future = new xx();
			channel.write(new Composite(request,future));
			return future;
		}
	}
	
	ApnsClientHandler{
		Map<id,future> map;
		write(composite){
			request = composite.getRequest()
			future = composite.getFuture();
			map.put(id,future)
			write(request).addListener(){
				future.set(xx)
			}
		}
		onDataReceive(response){
			future = map.get(response.getId());
			future.set(xx);
		}
	}
	
从代码上讲，write和receive都写在一个类里（这里是），因为write和read要共享很多数据，这些数据作为ApnsClientHandler的成员，代码上就可以更紧凑。

### 操作接口的演进

netty对外提供的操作接口有以下几个问题，当然，这也不怨netty

1. 操作对象有多个，比如bootstrap、channel。并且，操作对象间存在依赖关系，channel不是直接初始化，而是通过bootstrap获得。
2. netty启动逻辑复杂，必须由用户显式编写代码。
3. 操作接口不简洁，对于io操作，简介的接口应该是

	1. 同步,`response send(request)`
	2. 异步,`Future<response> send(request)`

	而netty则无明确封装
	
通过pushy，我们可以学习到如何封装netty，同时学习如何以纯异步的方式新增自定义逻辑，比如线程池等。

## 最佳实践

2018.6.18 补充 [relayrides/pushy](https://github.com/relayrides/pushy/wiki/Best-practices)

1. Flow control。pushy 是纯异步接口，pushy 有个控制，实现原理估计是1500个future 未返回时，则将后续的请求 缓冲起来，等等这个1500个inflight 的reqeust。

	当数据量很大时，必然触发1500 的上线，进而大量请求 缓存在netty buffer 中，然后耗尽内存。此时，需要一个 flow control layer ，可以使用CountDown 或 Semaphore
	


## 其它

从pushy 中我们可以学习到，如何去写一个纯异步框架