---

layout: post
title: netty 内存管理
category: 技术
tags: Netty
keywords: JAVA netty ByteBuffer

---

## 前言

[深入浅出Netty内存管理：PoolChunk](http://blog.jobbole.com/106001/)开篇说的太好了：多年之前，从C内存的手动管理上升到java的自动GC，是历史的巨大进步。然而多年之后，netty的内存实现又曲线的回到了手动管理模式，正印证了马克思哲学观：社会总是在螺旋式前进的，没有永远的最好。的确，就内存管理而言，GC给程序员带来的价值是不言而喻的，不仅大大的降低了程序员的负担，而且也极大的减少了内存管理带来的Crash困扰，不过也有很多情况，可能手动的内存管理更为合适。

## 整体思路

[Netty Memory Management Overview](https://www.programmersought.com/article/9322400832/)At the operating system level, each software requests the operating system to quickly allocate computer memory resources at runtime and release and reclaim memory resources when appropriate. Some common algorithms include slab, buddy, and jemalloc. PS：Netty uses the idea of ​​jemalloc

From the Netty level, the essence is to allocate a large memory first, and then use some data structure to record the memory usage status during memory allocation and recycling. If there is a new allocation request, find the most suitable location based on the status information. Returns and updates the data structure; after the memory is released, the data structure is modified synchronously. netty 先申请大块内存，然后自己负责这块内存的申请与回收。PS: netty 这样做的前提是，bytebuf 大部分时候只出现在 协议编解码层，这一块由netty 封装，因此netty 可以把控bytebuf的 分配与回收。在业务层开发直接操作的是消息对象，比如`channel.write(Obj)`。

内存池大概思路：首先应该会向系统申请一大块内存，然后通过某种算法管理这块内存并提供接口让上层申请空闲内存，**申请到的内存地址应该透出到应用层**，但是对开发人员来说应该是透明的，所以要有一个对象包装这个地址，并且这个对象应该也是池化的，也就是说不仅要有内存池，还要有一个对象池。所以，自然可以带着以下问题去看源码：

1. 内存池管理算法是怎么做到申请效率，怎么减少内存碎片。主要在于数据结构的组织。Chunk、smallSubPage、tinySubPage、ChunkList按照使用率分配、Chunk的二叉树内存管理、subPage的位图内存管理。
2. 高负载下内存池不断扩展，如何做到内存回收
3. 对象池是如何实现的
4. 内存池跟对象池作为全局数据，在多线程环境下如何减少锁竞争
5. 池化后内存的申请跟释放必然是成对出现的，那么如何做内存泄漏检测，特别是跨线程之间的申请跟释放是如何处理的。

## nio byte buffer

对于java nio，ByteBuffer有两个子类HeapByteBuffer和DirectByteBuffer的不同。

|ByteBuffer子类|底层数据存储|分配释放|使用场景|优缺点|
|---|---|---|---|---|
|HeapByteBuffer|byte[]|由堆分配和释放|消息编解码||
|DirectByteBuffer|long base = sun.misc.Unsafe.allocateMemory(size)|java对象本身归gc管理，其对应的内存由单独的组件负责释放|io收发|io效率更高,分配和释放效率低|

## netty内存管理

### 内存规格

![](/public/upload/netty/netty_arena.png)

1. The minimum unit of memory allocation is 16B.
2. The request of less than 512B is Tiny, the request of less than 8KB (PageSize) is Small, the request of 16MB (Chunk Size) is Normal, and the request of more than 16MB (Chun kSize) is Huge.
3. Requests smaller than 512B are incremented by 16B each time starting from 16B; requests larger than or equal to 512B are doubled each time.

### PooledByteBufAllocator

```java
public class PooledByteBufAllocator extends AbstractByteBufAllocator implements ByteBufAllocatorMetricProvider {
    private final PoolArena<byte[]>[] heapArenas;
    private final PoolArena<ByteBuffer>[] directArenas;
    protected ByteBuf newHeapBuffer(int initialCapacity, int maxCapacity) {
        PoolThreadCache cache = threadCache.get();
        PoolArena<byte[]> heapArena = cache.heapArena;
        final ByteBuf buf;
        if (heapArena != null) {
            buf = heapArena.allocate(cache, initialCapacity, maxCapacity);
        } else {
            buf = PlatformDependent.hasUnsafe() ?
                    new UnpooledUnsafeHeapByteBuf(this, initialCapacity, maxCapacity) :
                    new UnpooledHeapByteBuf(this, initialCapacity, maxCapacity);
        }

        return toLeakAwareBuffer(buf);
    }
}
```

```java
abstract class PoolArena<T> implements PoolArenaMetric {
    PooledByteBuf<T> allocate(PoolThreadCache cache, int reqCapacity, int maxCapacity) {
        // 从对象池 中取出一个 buf 对象
        PooledByteBuf<T> buf = newByteBuf(maxCapacity);
        allocate(cache, buf, reqCapacity);
        return buf;
    }
    protected abstract PooledByteBuf<T> newByteBuf(int maxCapacity);
    // HeapArena 是 PoolArena 子类，也是内部类
    static final class HeapArena extends PoolArena<byte[]> {
        @Override
        protected PooledByteBuf<byte[]> newByteBuf(int maxCapacity) {
            return HAS_UNSAFE ? PooledUnsafeHeapByteBuf.newUnsafeInstance(maxCapacity)
                    : PooledHeapByteBuf.newInstance(maxCapacity);
        }
    }
    private void allocate(PoolThreadCache cache, PooledByteBuf<T> buf, final int reqCapacity) {
        final int normCapacity = normalizeCapacity(reqCapacity);
        if (isTinyOrSmall(normCapacity)) { // capacity < pageSize
             if (tiny) { // < 512
                cache.allocateTiny(this, buf, reqCapacity, normCapacity)
                ...
                return;
            } else {
                cache.allocateSmall(this, buf, reqCapacity, normCapacity);
                ...
                return;
            }
        }
        if (normCapacity <= chunkSize) {
            cache.allocateNormal(this, buf, reqCapacity, normCapacity)
            ...
            return;
        } else {
            // Huge allocations are never served via the cache so just call allocateHuge
            allocateHuge(buf, reqCapacity);
        }
    }
    private void allocateHuge(PooledByteBuf<T> buf, int reqCapacity) {
        PoolChunk<T> chunk = newUnpooledChunk(reqCapacity);
        activeBytesHuge.add(chunk.chunkSize());
        buf.initUnpooled(chunk, reqCapacity);
        allocationsHuge.increment();
    }
}
class PooledHeapByteBuf extends PooledByteBuf<byte[]> {
    // ByteBuf 工作的基础元素
    protected long handle;
    protected T memory;
    protected int offset;
    protected int length;
    int maxLength;
    // 持有ByteBuf 相关的一些引用
    protected PoolChunk<T> chunk;
    PoolThreadCache cache;
    private ByteBuffer tmpNioBuf;
    private ByteBufAllocator allocator;
    static PooledHeapByteBuf newInstance(int maxCapacity) {
        PooledHeapByteBuf buf = RECYCLER.get();
        buf.reuse(maxCapacity);
        return buf;
    }
    void initUnpooled(PoolChunk<T> chunk, int length) {
        init0(chunk, 0, chunk.offset, length, length, null);
    }
    private void init0(PoolChunk<T> chunk, long handle, int offset, int length, int maxLength, PoolThreadCache cache) {
        assert handle >= 0;
        assert chunk != null;
        this.chunk = chunk;
        memory = chunk.memory;  // 将chunk 的内存起始地址 赋给ByteBuf
        allocator = chunk.arena.parent;
        this.cache = cache;
        this.handle = handle;
        this.offset = offset;
        this.length = length;
        this.maxLength = maxLength;
        tmpNioBuf = null;
    }
}
```

Recycler负责对象的分配与回收（这块还没细看），PooledArena负责buffer对象引用内存的分配与回收。

![](/public/upload/netty/netty_byte_buf.png)

## 引用

[Netty学习之旅----源码分析内存分配与释放原理](http://46aae4d1e2371e4aa769798941cef698.devproxy.yunshipei.com/prestigeding/article/details/54692464)

[《Netty官方文档》引用计数对象](http://ifeve.com/reference-counted-objects/)

[Netty文档之引用计数对象](http://www.wolfbe.com/detail/201609/377.html#)

[netty的引用计数](http://www.cnblogs.com/gaoxing/p/4249119.html)