---

layout: post
title: redis
category: 技术
tags: Tool
keywords: redis

---

## 简介(未完成)

很多事情联系起来想很有意思，比如rpc(跨主机进程通信)，然后一些大牛搞出redis，可以理解为**跨主机访问内存**，360推出一个pika，可以理解为跨主机访问磁盘。

跨主机通信，当然免不了网络通信的一些约定，这不是本文的重点，所以不多谈。不管跨主机访问内存还是磁盘，都不是提供一个byte[]让客户端随便用，而是像rpc一样，传输一些约定好的数据结构。区别是，rpc传输的数据结构描述了调用信息，redis等传输的数据结构只是为了存储。

把一些数据结构存在本机和存在远程主机，有一些隐含的意味：

1. "本机的"数据结构包括：基本数据类型，复合类型（string，list，map等）。基本数据类型往往用不着跨主机存储，因为不值当。
2. 对于本地访问内存而言，访问一个数据结构要指明两个要素：地址和类型。地址说明去哪去数据，类型说明取多少数据，取出的数据如何处理。远端访问内存类似，只不过”地址“不再是一个内存地址，而是一个具备唯一性的key，由远端主机完成key到该主机的内存地址的映射。

上述逻辑或许能够解释，很多类似redis的工具为什么是key-value的，并且value可以是各种数据结构。

## redis概述

redis分为server端和client端，server端以字典（dict，参见redis对dict数据结构的实现）存储所有的key-value。为了客户端划分业务的需要，key-value被划分到不同的redisDb中。

redis的服务器进程就是一个事件循环(loop)，这个循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复，而时间事件则负责执行像serverCron函数这样需要定时运行的函数(来自《Reis设计与实现》)。**简直跟netty的Eventloop一个样**：

1. 文件事件负责socket操作，基于Reactor模式。
2. 时间事件负责socket之外的操作，主要是定时操作。
3. 文件事件和时间事件在一个线程中执行

        def main(){
			init_server();
            while (server_is_not_shutdown{
            	aeProcessEvents(){
                	获取离当前时间最近的时间事件，根据算法计算一个值timeVal
                    阻塞等待文件事件（timeout为timeVal）。即下一个时间事件快了就少等会儿，否则就多等会儿。
                    处理文件事件（如果有的话）
                    处理时间事件
                }
            }
            clean_server();

        }
