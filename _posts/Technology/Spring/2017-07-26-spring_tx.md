---

layout: post
title: spring事务小结
category: 技术
tags: Spring
keywords: JAVA spi xsd

---

## 前言

本文基本算[第19章 Spring事务王国的架构](http://book.51cto.com/art/200908/147376.htm)的重新整理。



## 先从编程式事务说起

	public void serviceMethod(){  
        TransactionDefinition definition = ...;  
        PlatformTransactionManager transactionManager = ...;
        TransactionStatus txStatus = transactionManager.getTransaction(definition);  
        try {  
            // dao1.doDataAccess();  
            // dao2.doDataAccess();  
            // ...  
        }catch(DataAccessException e){  
            transactionManager.rollback(txStatus);  
            throw e;  
        }catch(OtherNecessaryException e){  
            transactionManager.rollback(txStatus);  
            throw e;  
        }  
        transactionManager.commit(txStatus);  
    }  
    
TransactionDefinition、PlatformTransactionManager、TransactionStatus是spring tx提供的一系列抽象。

Spring的事务框架设计理念的基本原则是：让事务管理的关注点与数据访问关注点相分离。如上图，try代码块数据还按照原来的方式访问，不管是datasource、hibernate还是其他数据源，亦或是rpc服务，怎么变化，try代码块之外的事务代码可以岿然不动。

**PlatformTransactionManager是整个事务抽象策略的顶层接口，它就好像我们的战略蓝图，而战略的具体实施则将由相应的PlatformTransactionManager实现类来执行。**

## 实现一个简单的PlatformTransactionManager

以JDBC数据访问方式的局部事务管理为例，[统一中原的过程（1）](http://book.51cto.com/art/200908/147377.htm)，其基本原理是：保证两个dao的数据访问方法使用的是同一个java.sql.Connection，这样PlatformTransactionManager的commit和rollback就可以转化为conn的对应方法。

采用称为connection-passing的方式，PlatformTransactionManager在事务开始时，获取一个conneciton，将其挂到当前线程，随后dao层在获取connection时，先尝试从当前线程获取Connection，（无则新建），然后使用Connection进行数据操作。可以看出，Spring的事务管理与它的数据访问框架是紧密结合的。

学习的路径

从常规路线来说，一般从理解配置、配置解析开始，将配置存到一些数据类中。

	<!-- 声明事务管理器,并支持事务注解 -->
	<bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
		<property name="dataSource" ref="dataSource" />
	</bean>
	<tx:annotation-driven transaction-manager="txManager" />
	
spring aop 一般涉及到ProxyFactoryBean，使得 ioc 返回带@Transactional 方法的类的实例时，返回的是代理类实例。 TransactionProxyFactoryBean 抛开ProxyFactoryBean功能，其功能点转向了其成员TransactionInterceptor，TransactionInterceptor实现了MethodInterceptor。

	public interface MethodInterceptor extends Interceptor {
    	/**
     	* Implement this method to perform extra treatments before and
     	* after the invocation.
     	* /
    	Object invoke(MethodInvocation invocation) throws Throwable;
	}

## 事务中的一些概念

[TransactionDefinition（1）](http://book.51cto.com/art/200908/147383.htm)

1. 事务的隔离级别，并发事务的相互影响
2. 事务的传播行为，直接说，就是一个标记了@Transactional的方法，调用了另一个标记了@Transactional的方法。后一个方法的失败是否会影响前一个方法。
3. 事务的超时时间
4. 是否为只读事务






