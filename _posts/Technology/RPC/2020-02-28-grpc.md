---

layout: post
title: grpc学习
category: 架构
tags: RPC
keywords: network communication protocol

---

## 简介（持续更新）

* TOC
{:toc}

grc特点

1. 语言中立，支持多种语言；
2. 基于 IDL 文件定义服务，通过 proto3 工具生成指定语言的数据结构、服务端接口以及客户端 Stub；
3. 通信协议基于标准的 HTTP/2 设计，支持双向流、消息头压缩、单 TCP 的多路复用、服务端推送等特性，这些特性使得 gRPC 在移动端设备上更加省电和节省网络流量；4. 序列化支持 PB（Protocol Buffer）和 JSON，PB 是一种语言无关的高性能序列化框架，基于 HTTP/2 + PB, 保障了 RPC 调用的高性能。

||grpc|thrift|
|---|---|---|
|协议层||TbinaryProtocol<br>TCompactProtocol<br>TJSONProtocol<br>TDebugProtocol|
|传输层|HTTP/2|TSocket<br>TFramedTransport<br>TFileTransport<br>TMemoryTransport<br>TZlibTransport|
|服务端|HTTP/2|TSimpleServer<br>TThreadPoolServer<br>TNonblockingServer|
|权限认证|SSL/TLS<br>OAuth2.0<br> API|SSL|
|流式处理|支持|不支持|

## 序列化协议 protobuf

事实上的跨语言序列化方案只有三个： protobuf, thrift, json体积太大，protobuf 和 grpc 都是google 发明的。

官方示例

    syntax = "proto3";
    package helloworld;
    // The greeting service definition.
    service Greeter {
        // Sends a greeting
        rpc SayHello (HelloRequest) returns (HelloReply) {}
    }
    // The request message containing the user's name.
    message HelloRequest {
        string name = 1;
    }
    // The response message containing the greetings
    message HelloReply {
        string message = 1;
    }

java序列化和反序列化接口调用

```java
HelloRequest request
= HelloRequest.newBuilder().setName(name).build();
byte[] data = request.toByteArray();
// 反序列化
HelloRequest.parseFrom(data);
```

## 客户端和服务端

go语言下的示例

    helloworld
        helloworld.proto
        helloworld.pb.go    ## 基于protoc --go_out=plugins=grpc:. helloworld.proto 生成
        server.go
        client.go

server.go

```go
type GrpcServerDemo struct {
}
func (*GrpcServerDemo) SayHello(ctx context.Context, req *HelloRequest) (*HelloReply, error) {
	return &HelloReply{
		Message: fmt.Sprintf("Hello: %s", req.Name),
	}, nil
}
func Server() {
	lis, err := net.Listen("tcp", "127.0.0.1:8080")
	if err != nil {
		fmt.Printf("failed to listen: %v\n", err)
	}
	grpcServer := grpc.NewServer()
	RegisterGreeterServer(grpcServer, &GrpcServerDemo{})
	grpcServer.Serve(lis)
}
```

client.go 

```go
func Client() {
     // 创建connection
	conn, _ := grpc.Dial("127.0.0.1:8080", grpc.WithInsecure())
    defer conn.Close()
    // 创建client
    cli := NewGreeterClient(conn)
    // 调用RPC接口
	response, _ := cli.SayHello(context.Background(), &HelloRequest{Name: "zhangsan"})
	fmt.Println(response.Message)
}
```

![](/public/upload/rpc/grpc_client_server.png)

1. 针对helloworld.proto 中定义的 Greeter service， gprc 生成的go 文件 helloworld.pb.go 分别定义了GreeterClient 和 GreeterServer interface。这点与thrift client和server 共用一个interface 不同。
2. GreeterClient 实现类 greeterClient 聚合ClientConn ，greeterClient.SayHello ==> ClientConn.Invoke ==> ClientStream.SendMsg + ClientStream.RecvMsg。 这点与thrift client 类似，接口实现本质是 send+recv
3. 服务端则是 Server.Serve 启动服务端，GreeterServer 实现类 作为业务处理逻辑在 必要时候被调用。


### 客户端流程（待具体分析）

![](/public/upload/rpc/grpc_client.png)

### 服务端流程（待具体分析）

[gRPC-Go服务端源码分析](https://feilengcui008.github.io/post/grpc-go%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/)

## 与http2 的协作

[从实践到原理，带你参透 gRPC](https://mp.weixin.qq.com/s/qet7FX26HGnXgLIG-lOSyw)grpc 基于http2 通信，**便有一个grpc 数据、状态 等如何对应 到http2 上的问题** （待抓包及源码进一步深入了解）

![](/public/upload/rpc/grpc_http2.png)

HEADERS 帧的主要作用是存储和传播 HTTP 的标头信息。 HEADERS 里有一些眼熟的信息，分别如下：

    method：POST
    scheme：http
    path：/proto.SearchService/Search
    authority：:10001
    content-type：application/grpc
    user-agent：grpc-go/1.20.0-dev

gGRPC把元数据放到HTTP/2 Headers里，请求参数序列化之后放到 DATA frame里

### 为什么是http2

[Introducing gRPC, a new open source HTTP/2 RPC Framework](https://developers.googleblog.com/2015/02/introducing-grpc-new-open-source-http2.html)

gRPC is based on many years of experience in building distributed systems. With the new framework, we want to bring to the developer community a modern, bandwidth and CPU efficient, low latency way to create massively distributed systems that span data centers, as well as power mobile apps, real-time communications, IoT devices and APIs. 从设计的立意上，grpc 就没有仅局限于 data center 内部rpc 调用，也希望用到 mobile 和 iot 设备上，这便要求协议尽量通用。又想用到实时通讯上，那么 相对普通rpc 支持 双向 stream 也就是顺理成章了。

Building on HTTP/2 standards brings many capabilities such as bidirectional streaming, flow control, header compression, multiplexing requests over a single TCP connection and more. These features save battery life and data usage on mobile while speeding up services and web applications running in the cloud.

[思考gRPC ：为什么是HTTP/2](http://hengyunabc.github.io/thinking-about-grpc-http2/)

1. HTTP/2 是一个公开的、实践检验过的标准
2. HTTP/2 天然支持物联网、手机、浏览器，多语言客户端实现容易，在Gateway/Proxy很容易支持
3. HTTP/2支持Stream和流控
4. HTTP/2 安全性有保证，HTTP/2 鉴权成熟

http 和 tcp 是传输协议，rpc 相对于传输协议，更多的是封装了“服务发现”，"负载均衡"，“熔断降级”一类面向服务的高级特性。使用http 作为传输层协议 倒也不少见，比如 Spring Cloud REST 风格直接把 HTTP 作为应用协议。

以http1.1 为例，建连开销可以使用连接池复用解决，http 协议也可以传输二进制数据。**为什么很多rpc 框架喜欢 直接用tcp 作为传输协议？**通用定义的http1.1协议的tcp报文包含太多废信息，一个POST协议的格式大致如下


    HTTP/1.0 200 OK 
    Content-Type: text/plain
    Content-Length: 137582
    Expires: Thu, 05 Dec 1997 16:00:00 GMT
    Last-Modified: Wed, 5 August 1996 15:55:28 GMT
    Server: Apache 0.84

    <html>
    <body>Hello World</body>
    </html>

报文元数据也就是header头的键值对却用了文本编码，非常占字节数。假如我们使用自定义tcp协议的报文如下

|1->4 byte|5->8 byte|9->16 byte|17->length+16 byte|
|---|---|---|---|
|length(int)|type int|package_id(long)|package_data|

报头占用的字节数也就只有16个byte，极大地精简了传输内容。http2.0协议已经优化编码效率问题。

## Stream 方式（待补充）

grpc 调用方式分为四种：

1. Unary RPC  一元RPC
2. Server-side streaming RPC 服务端流式RPC
3. Client-side streaming RPC 客户端流式RPC
4. Bidirectional streaming RPC 双向流式RPC

