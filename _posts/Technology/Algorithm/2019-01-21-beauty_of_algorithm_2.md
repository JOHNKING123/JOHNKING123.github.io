---

layout: post
title: 《数据结构与算法之美》——算法新解
category: 技术
tags: Algorithm
keywords: 数据结构与算法之美

---

## 简介（持续更新）

* TOC
{:toc}

建议看下前文 [《数据结构与算法之美》——数据结构笔记](http://qiankunli.github.io/2018/09/19/beauty_of_algorithm_1.html)


## 字符串匹配

先将主串拆分为 n-m+1 个子串，然后模式串与子串一一匹配 

![](/public/upload/algorithm/string_match_bf.jpg)

模式串与字串的匹配方式

1. Brute Force 算法：暴力匹配
2. Rabin-Karp 算法，在匹配效率（快速判断两个字符串是否相等 ==> 哈希 ==> 如何快速求哈希）上做文章
3. Boyer-Moore 算法，常用于文本编辑器中的查找替换。当遇到不匹配的字符时，有什么固定的规律，跳过一些肯定不会匹配的情况，将模式串往后多滑动几位呢？BM 算法构建的规则有两类：坏字符规则和好后缀规则。好后缀规则可以独立于坏字符规则（耗内存、某些场景下失效）使用
4. Knuth Morris Pratt/KMP 算法，当遇到不匹配的字符时，将模式串往后多滑动几位呢？好前缀规则。 这里有两个事情：模式串（长度为n）有n-1个好前缀；每个前缀有它自己的后移位数

    ![](/public/upload/algorithm/string_match_kmp.jpg)

Rabin-Karp 算法

1. 先全部算一遍哈希值，哈希值匹配
2. 前一个字串与后一个字串的哈希值计算有关联关系， 省去部分计算

针对a~z组成的字符串 设计一个哈希算法，将其转换为一个数字
1. 字符串对应一个26进制数字，数字可能很大， 计算机表示不了
2. a~z 对应1~26，将所有字母对应的数字求和，容易冲突
3. a~z 对应素数（这就引出了素数的价值），这样求和时冲突的概率就很低了

### Trie树

字符串的匹配问题，笼统上讲，其实就是数据的查找问题。Trie 树的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起。

如何存储一个 Trie 树？假设我们的字符串中只有从 a 到 z 这 26 个小写字母

1. 散列表方式

    ![](/public/upload/algorithm/trie_hash_table.jpg)

        class TrieNode { 
            char data; 
            TrieNode children[26];
        }

2. **每个节点中的数组换成其他数据结构**，来存储一个节点的子节点指针。用哪种数据结构呢？我们的选择其实有很多，比如有序数组、跳表、散列表、红黑树等。假设我们用有序数组，数组中的指针按照所指向的子节点中的字符的大小顺序排列。查询的时候，我们可以通过二分查找的方法，快速查找到某个字符应该匹配的子节点的指针。但是，在往 Trie 树中插入一个字符串的时候，我们为了维护数组中数据的有序性，就会稍微慢了点。

Trie 树不适合精确匹配查找，这种问题更适合用散列表或者红黑树来解决。Trie 树比较适合的是查找前缀匹配的字符串

### 多模式匹配

多模式串匹配算法，就是在多个模式串和一个主串之间做匹配，也就是说，在一个主串中查找多个模式串。比如很多网站提供敏感词过滤功能，也就是通过维护一个敏感词的字典，当用户输入一段文字内容之后，通过字符串匹配算法，来查找用户输入的这段文字，是否包含敏感词。如果敏感词很多，比如几千个，单模式处理思路比较低效。多模式匹配算法 只需要扫描一遍主串，就能在主串中一次性查找多个模式串是否存在


1. 对敏感词字典进行预处理，构建成 Trie 树
2. 当用户输入一个文本内容后，我们把用户输入的内容作为主串，从第一个字符（假设是字符 C）开始，在 Trie 树中匹配。当匹配到 Trie 树的叶子节点，或者中途遇到不匹配字符的时候，我们将主串的开始匹配位置后移一位，也就是从字符 C 的下一个字符开始，重新在 Trie 树中匹配。这有点类似单模式串匹配的 BF 算法
3. 我们知道，单模式串匹配算法中，KMP 算法对 BF 算法进行改进，引入了 next 数组，让匹配失败时，尽可能将模式串往后多滑动几位。**借鉴单模式串的优化改进方法，有一个AC自动机算法**。


![](/public/upload/algorithm/ac_trie.jpg)

    public class AcNode {
        public char data; 
        public AcNode[] children = new AcNode[26]; // 字符集只包含 a~z 这 26 个字符
        public boolean isEndingChar = false; // 结尾字符为 true
        public int length = -1; // 当 isEndingChar=true 时，记录模式串长度
        public AcNode fail; // 失败指针,相当于 KMP 中的失效函数 next 数组
        public AcNode(char data) {
            this.data = data;
        }
    }


## 算法思想

![](/public/upload/algorithm/algorithm_thought.png)

从算法思想的角度来理解具体算法。

贪心算法最难的一块是如何将要解决的问题抽象成贪心算法模型，然后才可以定义什么叫“贪心”。贪心算法适用的场景比较有限（假设一个决策分3步，可能除了第一步是最优的其它都是最差的）。这种算法思想更多的是指导设计基础算法。

分治与递归的关系：分治算法是一种处理问题的思想，递归是一种编程技巧，分治算法一般都比较适合用递归来实现

分治算法能解决的问题，一般需要满足下面这几个条件：

1. 原问题与分解成的小问题具有相同的模式；
2. 原问题分解成的子问题可以独立求解，**子问题之间没有相关性**（划分算法的选择标准），这一点是分治算法跟动态规划的明显区别。
3. 具有分解终止条件，也就是说，当问题足够小时，可以直接求解；
4. **可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了**。PS：**所以分治算法为什么比常规最笨的算法高效？**分治算法的复杂性=PartA+PartB+union(A,B)，PartA和PartB的复杂性与笨方法并无区别，比笨方法优化就优化在对AB合并逻辑的处理上。

分治算法思想的应用是非常广泛的，并不仅限于指导编程和算法设计。利用这种分治的处理思路，不仅仅能克服内存的限制，还能利用多线程或者多机处理，加快处理的速度。

## 小结

一个很深的体会是：算法可以很多样，但算法是逐步优化出来的，并且优化思路是一脉相承的。


![](/public/upload/algorithm/beauty_of_algorithm_post.JPG)

个人微信订阅号

![](/public/upload/qrcode_for_gh.jpg)