---

layout: post
title: 《数据结构与算法之美》笔记
category: 技术
tags: Algorithm
keywords: 数据结构与算法之美

---

## 简介（持续更新中）

推荐在学习的过程中，放慢速度，比如一天只学一章，尽量将demo中的代码实现下。


在技术圈，我们经常喜欢谈论高大上的架构，比如高可用、微服务、服务治理等等。鲜有人关注代码层面的编程能力，愿意沉下心来花几个月时间啃一啃计算机基础知识，认认真真夯实基础。PS：笔者在学习区块链时，区块链的原理很快就搞懂了，但真要说操盘一个项目还是远远不敢想的，因为面对具体的业务场景，不知道如何将取舍映射到技术上，也就始终跟区块链隔着距离。

像《算法导论》这些经典书籍，虽然很全面，但是过于理论，缺乏真实的开发场景，学起来非常枯燥，过不了几天就忘了。PS：计算机专业都会教《数据库原理》，讲了数据库的历史、三大范式、组成、事务等等，但你最直观的工作感受是什么？数据库压力很大。所以，**描述一个知识有两种方式，一种是how、what、when、why等娓娓道来；一种是拿一个问题将所有的知识点串起来。**

人生路上，我们会遇到很多的坎儿。跨过去，你就可以成长，跨不过去就是困难和停滞。而在后面很长一段时间里， 你都需要为这个困难买单。


## 为什么要学习数据结构和算法

参见[为什么很多业务程序猿觉得数据结构和算法没用？](http://qiankunli.github.io/2018/10/03/why_study_algorithm.html)

算法一般作用于特定的数据结构之上，比如二分查找是基于数组的，在链表上就玩不转了。

学习的重点：

1. 复杂度分析，作者将这个事儿提到了一个极其重要的高度
2. 除了知识本身外，更重要的是它的来历、特点和应用场景


算法的复杂度，

1. 多项式量级，O(1),O(n),O(n^2),O(logn),O(nlogn)
2. 非多项式量级，只有两个：O(2^n)和O(n!)，这类问题称为NP问题。

考虑一下场景：

1. 向数组第k个位置插入一个元素。将第k个原有的元素挪到数组最后
2. 从数组中删除一个元素。将该位置标记为已删除，然后在一个时刻统一删除。想想jvm的标记清理算法
3. 基于数组实现一个队列

为什么很多人的第一个反应是移动元素？原因就是

1. 很多人没有将数组 作为存储结构，而是逻辑结构。作为逻辑结构的数组，它的定义是：用一组**连续的**内存空间，来存储一组具有相同类型的数据。作为存储结构，这就是一段儿空间，爱连续不连续。作为逻辑结构，就必须保持它的连续性。 
2. 我们在说问题的时候，没有说业务场景。如果我跟你说jvm垃圾清理，你肯定知道标记清除算法，无需在每一个时刻都保持数组数据的“纯洁性”。
3. X/Y 问题。将元素插入数组的第K个位置，并没有说要维持数组原来的数据顺序。


## 常用的数据结构


![](/public/upload/algorithm/data_structure_summary.png)

栈在函数调用中的应用，一次回收一个数据意思不大，但一次回收一个栈帧，即可实现返回值、参数、局部变量的自动分配与回收。cpu 栈寄存器 + 出入栈指令 这类硬件支持，加上栈操作形式的相对固定，使得编译器层面便可以屏蔽这些细节。甚至反过来说，是硬件特性 + 编译器 造就了“方法/函数”这一抽象，而不是方法利用了栈的特性。jvm 虽说堆内存垃圾回收很高端，但这类复杂的事儿就只能语言的虚拟机层 解决了。


## 常用算法

快排伪代码

	// 快速排序，A 是数组，n 表示数组的大小
	quick_sort(A, n) { 
		quick_sort_c(A, 0, n-1)
	}
	// 快速排序递归函数，p,r 为下标	
	quick_sort_c(A, p, r) { 
		if p >= rthen return 
		q = partition(A, p, r) // 获取分区点 
		quick_sort_ck_sort_c(A, p, q-1) 
		quick_sort_c(A, q+1, r)
	}

如果我们不考虑空间消耗的话，partition() 分区函数可以写得非常简单。我们申请两个临时数组 X 和 Y，遍历 A[p…r]，将小于 pivot 的元素都拷贝到临时数组 X，将大于 pivot 的元素都拷贝到临时数组 Y，最后再将数组X 和数组 Y 中数据顺序拷贝到 A[p…r]。PS：这种表述方式让笔者对快排更有感觉了。


随机选择一个元素做“轴元素”，将所有大于轴元素的移到左边，其余移到右边。关键就是：从这一刻开始，小于“轴元素”的那些数就再也没有机会与大于“轴元素”的数进行两两比较了。

[数学之美番外篇：快排为什么那样快](http://mindhacks.cn/2008/06/13/why-is-quicksort-so-quick/)

排序的本质可以这样来表述：一组未排序的N个数字，它们一共有N!种重排，其中只有一种排列是满足题意的。将排序问题看成和猜数字（给一定范围，猜测提问者写好的数字）一样，是通过**问问题**来缩小/排除（narrow down）结果的可能性区间，这样一来，就会发现，“最好的问题”就是那些能够均分所有可能性的问题，因为那样的话不管问题的答案如何，都能排除掉k-1/k（k为问题的答案有多少种输出——猜数字里面是2，称球里面是3）种可能性，而不均衡的问题总会有一个或一些答案分支排除掉的可能性要小于k-1/k。于是策略的下界就被拖累了。




## 小结

知识的学习是一个反复迭代、不断沉淀的过程


![](/public/upload/algorithm/beauty_of_algorithm_post.JPG)

个人微信订阅号

![](/public/upload/qrcode_for_gh.jpg)