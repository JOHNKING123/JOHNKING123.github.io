---

layout: post
title: ddd前传——CRUD的败笔
category: 架构
tags: DDD
keywords: ddd cqrs

---

## 简介

* TOC
{:toc}

[浅谈我对DDD领域驱动设计的理解](https://www.cnblogs.com/netfocus/p/5548025.html) 很多项目（尤其是互联网项目，为了赶工）都是一开始模型没想清楚，一上来就开始建表写代码，代码写的非常冗余，完全是过程式的思考方式，最后导致系统非常难以维护。我们今天吐槽一下controller-service-dao的“坑”，挖一挖它的墙角。如果你觉得controller-service-dao 很不错，那说明你应对的场景还不够复杂，暂时还不适合谈论ddd。

## CRUD/controller-service-dao的败笔

[Spring Web 应用的最大败笔](https://www.jdon.com/45857)

大部分Spring的Web应用程序，常见的错误的设计如下：

1. 领域模型对象用来存储应用的数据(当作DTO使用)，领域模型是贫血模型这样的反模式。
2. 服务层每个实体有一个服务。

该应用程序有一个整体的服务层，它有太多的责任。更具体地，服务层有两个主要问题：

1. 在服务层发现业务逻辑，**业务逻辑被分散在各个服务层**
2. 每个领域模型一个服务。**每一个类都应该有一个责任**，不应将原属于领域模型的行为方法等划放在服务中实现，对象不但有属性还有行为。

[领域驱动设计在互联网业务开发中的实践](https://tech.meituan.com/DDD_in_%20practice.html)**在我们习惯了J2EE的开发模式后，Action/Service/DAO这种分层模式，会很自然地写出过程式代码**，而学到的很多关于OO理论的也毫无用武之地。使用这种开发方式，对象只是数据的载体，没有行为。以数据为中心，**以数据库ER设计作驱动。** PS，对这句深有体会，此时一个系统最有含量的部分就是数据库设计，数据库表定了，剩下的就是腾挪数据了。

[阿里盒马领域驱动设计实践](http://www.infoq.com/cn/articles/alibaba-freshhema-ddd-practice) 形容这类代码“面条代码”，从（客户）端上一条线杀到数据库完成一个操作，仅有的一些设计集中在数据库上。

[领域驱动设计学习输出](https://zhuanlan.zhihu.com/p/69056667)「CRUD工程师」认为自己没有创造任何东西，他们只是数据库表的搬运工。而**如果不是「CRUD」，业务系统后端工程师的价值在哪里**？**理解并抽象出业务逻辑，建立满足需求的业务模型，以此设计实现出可靠的系统，并有效地控制复杂性**。这才是大部分业务系统后端工程师的工作重点，也是解决他们工作中遇到的问题和难点的关键。

![](/public/upload/ddd/crud_defect.png)


## 搞得好像一切为了持久化

笔者在一篇文章中看到一个问题：如果内存足够大，且永不宕机，你还会用数据库么？不会， 因为：

1. 数据库表不支持继承和多态，表达能力有限。假设用户的联系方式可以是邮箱、电话（包括国家码，后续可以考虑扩展支持运营商信息）、qq任意一种，则用对象表示

		class User{
			Contact contact;
			setter
			getter
		}
		class Contact{
			int contactType
		}
		class QQ extends Contact{
			String qq;
		}
		class Phone extends Contact{
			String country;
			String phone;
		}
	
	用数据库表示就很尴尬了，因为多态的感觉不太好弄，你只能：

	1. 建一个contact表，所有的字段都放在里面
	2. 建一个contact表，一种联系方式建一个表
	
2. 表达一对多关系要额外加字段，表达多对多关系要额外建一个表


我们回想一下controller-service-dao的实现过程

1. model + dao 借助自动化工具生成
2. 有一个添加地址的需求
3. 然后controller实现，进而在UserService 里加一个addAddress方法，进而自然地 逻辑就写在`UserService.addAddress` 里了，直到调用dao 为止。

搞得我们一切操作像是为了持久化，持久化是编程的目的么？有时候不是

还以上文的User为例，对每一个新来的用户，我们需要保存用户身份信息（身份证号、性别等）、收货地址信息、画像信息等。为了用户操作友好

1. 用户信息 按类别 在不同的页面上输入。比如填完身份信息，点击下一步，让用户填写收货地址信息。
2. 用户可以添加任意多个收货地址，可以让用户在地图上选择地址，考虑到页面空间有限，一个页面只添加一个收货地址。一个收货地址添加完毕后， 用户可以选择下一步（添加兴趣信息）或者 新增下一个收货地址。
3. 每一个操作 都可以上一步，以便用户修改

针对这个需求，有几个实现方式

1. 每一步操作都保存到数据库，回显时从数据库中读取数据。这涉及到 用户请求对象 和 数据库对象的 相互转换。
2. 内存中有一个User 充血对象，在最后一步保存到db之前，其它所有的步骤只操作User 即可，包括但不限于

	1. 添加/回显身份证信息
	2. 添加/回显收货地址
	3. 添加/回显联系方式

为简单起见，你甚至可以将每一个步骤中页面发你的请求 数据直接保存在user 中，回显时原封不动直接返回给页面（用户的修改类似）。只有在最后保存的时刻， `user.sync` 同步到数据库。

![](/public/upload/architecture/ddd_step_save.png)

持久化就是持久化，本身不是业务逻辑的一部分（用户才不关心，甚至上层逻辑也不关心你将数据保存在msyql还是文件里，也不关心你是否做了分库分表），因此

1. 尽量的集中，对于整个User数据（包括n个收货地址和某种类型的联系方式）

	* 执行的时间集中
	* 代码的位置集中
2. 不要干预业务逻辑的处理过程，比如回显的时候不用从数据库获取。

## 面向功能的组件化

[阿里玄难：面向不确定性的软件设计几点思考](http://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&mid=2247488951&idx=1&sn=55485804760e3aff54bfc977176bc4bb&chksm=e92928b8de5ea1ae00e19ebf4a78a3c352da663a23334c7ae81c3ca005fc404214ef740e703c&mpshare=1&scene=23&srcid=#rd) 是一篇读多少遍都不过分的文章，其中就提到“面向功能的组件化设计到面向业务的对象化设计”。controller-service-dao 中包含大量的service，也是面向功能的组件化设计，**“因此按抽象归纳，组件化设计的软件系统，随着业务发展，补丁越来越多，运行几年就会被推倒重来是它的宿命”**

大量的service 有几个问题

1. 多了之后，经常出现互相引用的情况。**因为按领域划分的话，一定是大概念调用（多个）小概念，从上到下发散式的调用**。而对于面向功能的组件化设计，以班级-学生为例，ClassService 可能要获取班级内所有学生姓名的接口， StudentService 有获取班级 班主任老师姓名的需求，必定会彼此相互依赖。
2. 以京东业务类，既有自营也有第三方店铺，既有京东配送也有第三方配送。假设有一个订单服务，按传统设计会有OrderService，其尴尬之处是 自营非自营的订单对其来说都是一个Order对象，当然会有一个类似type的字段来标记其是否自营订单。但因为自营非自营订单的处理逻辑不同， 这时if else就不可避免了。在这个例子中，**“面向功能的组件化” 对多态的表达能力不足**，对能力的复用是服务化 而不是 "继承"(面向对象理念在架构设计上的延伸)的方式。“面向业务的对象化设计” 则会有Order、自营Order、第三方Order 等对象。称呼、行为 与代码的实际表现是一致的，[阿里玄难：面向不确定性的软件设计几点思考](http://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&mid=2247488951&idx=1&sn=55485804760e3aff54bfc977176bc4bb&chksm=e92928b8de5ea1ae00e19ebf4a78a3c352da663a23334c7ae81c3ca005fc404214ef740e703c&mpshare=1&scene=23&srcid=#rd) 甚至提到 阿里以后真的会有一个类 叫天猫、淘宝等。

## 碎碎念

只有架构分层是不够的，还需要更详细的**逻辑分层**，DDD领域驱动设计正是一个详细帮助建立丰富的有行为的领域模型的方法学。

数据驱动SQL ---->服务驱动SOA ----->领域驱动

聚合 >松耦合>重用 ==> 事件驱动>依赖注入>继承

过去系统分析和系统设计都是分离的，这样割裂的结果导致，需求分析的结果无法直接进行设计编程，而能够进行编程运行的代码却扭曲需求，导致客户运行软件后才发现很多功能不是自己想要的，而且软件不能快速跟随需求变化。

DDD最大的好处是：接触到需求第一步就是考虑领域模型，而不是将其切割成数据和行为，然后数据用数据库实现，行为使用服务实现，最后造成需求的首肢分离。DDD让你首先考虑的是业务语言，而不是数据。重点不同导致编程世界观不同。











