---

layout: post
title: 《实现领域驱动设计》笔记
category: 架构
tags: DDD
keywords: ddd cqrs

---

## 简介（未完成）

* TOC
{:toc}

DDD绝非是什么标新立异之物，我更倾向于将其看成是软件发展的自然结果。就像20世纪六七十年代出现了软件危机之后，面向对象成为了人们的救赎；瀑布式开发过程遇到瓶颈时，敏捷被搬上了舞台；而DDD则是对传统的以数据为中心的建模方式的反思结果。

如果你的项目完全以数据为中心，所有的操作都通过对数据库的crud完成，那么你并不需要DDD。此时你的团队只需要一个漂亮的数据库表编辑器。如果你的系统只有25到30个业务操作， 这应该是相当简单的，你没有感受到由复杂性和业务变化所带来的痛苦。 当你的系统有三四十个use case的时候，软件的复杂性便暴露出来了，如果软件功能在未来几年不断变化，ddd将有助于你管理复杂性和应对变化。


守住三个基本原则

1. 必须通过领域建模来驱动设计
1. One principle behind DDD is to bridge the gap between domain experts and developers by using the same language to create the same understanding. 
2. Another principle is to reduce complexity by applying object oriented design and design patters to avoid reinventing the wheel.

书的基本思路：传统编码的问题 ==> DDD的基本概念 ==> DDD与架构的关系 DDD在某个架构下找到自己“位置” ==> 领域模型内，领域对象的组成与彼此之间的关系

### DDD入门

    public void saveConsumer(String id,name,age,address,...){
        Consumer consumer = new Consumer();
        if(id != null){
            ...
        }
        ...
        consumerDao.save(consumer);
    }

saveConsumer 至少存在三大问题

1. saveConsumer 的业务意图不明确，代码无法反应业务意图，使用同一个方法来处理多个用例流
2. 方法的实现本身增加了潜在的复杂性（比如复杂的参数校验）
3. Consumer 只是一个data holder

一种优化：每一个应用层方法对应一个单一的用例流

    interface Consumer{
        public change PersonalName(String firstName,String lastName);
        ...
    }

我们希望对对象行为的命名能够传达准确的业务含义，也即反映通用语言。要达到这样的目的，肯定不是先在类上定义属性，然后向客户端暴露getter和setter那么简单。那只是在创建纯数据模型。如果只提供setter 和getter 会怎么样？

1. 暴露了 对象的内部结构
1. setter 和getter 并没有业务价值，方法的名字没有业务含义。如果Consumer 只修改了地址 而没修改邮政编码会发生什么呢？显然是一种**领域逻辑的泄漏**。这要求开发对对象很熟悉（随着迭代并不总能办到）；**如果软件留下太多的地方让用户自己去理解，用户往往需要培训才能做出操作决定**。

## 限界上下文/Bounded Context

领域上下文是一个显式的边界，领域模型便存在于这个边界之内。创建边界的原因在于：每个模型概念，包括它的属性和操作，在边界之内都具有特殊的含义。在很多情况下， 在不同模型中存在名字相同或相近的对象，但是它们的意思却不同。 当模型被一个显式的边界所包围时，其实每个概念的含义便是确定的了。 

考虑一个图书出版机构，它需要处理图书生命周期的不同阶段

1. 概念设计，计划出书。此时，连书名都没有
2. 联系作者，签订合同
3. 图书编辑、设计布局、插图。此时，图书是一些列稿件、注释、校正
3. 出版纸质书
5. 市场营销。此时，营销人员只关心书的简介
6. 将图书卖给销售商或读者。此时，重点是书的价格、重量、物流目的地。

如果整个系统只有一个Book对象，概念混淆、意见分歧和争论是不可避免的。如果我们将系统划分为3个上下文，每个上下文都有Book

1. 创作上下文，Book 是一个“作品”
2. 出版上下文，Book 可以视为一个印刷品（可能不准确）、出版物
3. 销售上下文，Book 可以视为一个 商品

如果你在不同的界限上下文中看到了完全相同的对象，通常意味着你的模型是错误的。有些相似的对象拥有不同的属性和行为（一个对象在不同上下文的“分身”），此时通常可以认为上下文边界的划分是合理的。 

## 名词解释（暂定）

[DDD战略设计相关核心概念的理解](https://www.cnblogs.com/netfocus/p/DDD.html)

![](/public/upload/ddd/ddd_concept.png)

1. 领域是一个边界，所以可以划分领域的大小，即领域划分，划分出来的子领域简称子域，每个子域对应一个小的问题域和和小的业务；
2. BC和子域的关系？没有关系。因为它们是不同的东西被划分后的产物，对解决方案空间进行划分产生了BC，对领域划分后产生了子域。
3. 领域模型和业务模型是不同的

叫什么不重要，我们真正要学会的是划分的原则、依据、经验

需要特别注意的是，领域模型设计只是整个软件设计中的很小一部分。除了领域模型设计之外，要落地一个系统，我们还有非常多的其他设计要做，比如：容量规划；架构设计；数据库设计；缓存设计；框架选型；发布方案；数据迁移、同步方案；分库分表方案；回滚方案；高并发解决方案；一致性选型；性能压测方案。

## DDD 与架构整合

架构描述了如何划分系统的各个部分以及各个部分的关系（说的直观点，就是会影响项目中package的命名）。包括分层、六边形、CQRS等架构

### DDD 与分层架构


DDD 与分层架构整合有多种方式，这是比较传统的一种

![](/public/upload/ddd/layered_architecture.png)

1. 领域层实现业务逻辑，领域层映射到领域模型，是问题域的领域模型在软件中的反映。包含实体、值对象和领域服务等领域对象，在实体、值对象和领域服务等领域对象的方法中封装实现业务规则和保证完整性约束。领域对象在实现业务逻辑上具备坚不可摧的完整性，意味着不管外界代码如何操作，都不可能创建不合法的领域对象（例如没有账户号码或余额为负数的借记卡对象），亦不可能打破任何业务规则（例如在多次转账之后，钱凭空丢失或凭空产生）。**领域对象的功能是高度内聚的，具有单一的职责，任何不涉及业务逻辑的复杂的组合操作都不在领域层而在应用层中实现**。领域层中的全部领域对象的总和在功能上是完备的，意味着系统的所有行为都可以由领域层中的领域对象组合实现。
2. 应用层映射到系统用例模型，是系统用例模型在软件中的反映。它的职责可表示为“编排和转发”，即将它要实现的功能委托给一个或多个领域对象来实现，它本身只负责安排工作顺序和拼装操作结果。
3. 基础设施层为其余各层提供技术支持。**注意基础设施层不只负责数据库访问**，它实现了系统的全部技术性需求，比如持久化、消息通知等
4. 用户接口层为外部用户访问底层系统提供交互界面和数据表示。用户接口层有两个任务：（1）从用户处接收命令操作，改变底层系统状态；（2）从用户处接收查询操作，将底层系统状态以合适的形式呈现给用户。PS：相当于输入输出设备

### DDD 与 CQRS

1. 代码层面：一个方法要么是执行某种动作的命令，要么是返回数据的查询，而不是两者皆是。
2. 对象设计层面：如果一个方法修改了对象的状态，该方法便是一个命令，它不应该返回数据。在java和C#中， 这样的方法应该声明为void。如果一个方法返回了数据，该方法便是一个查询，此时它不应该通过直接的或间接的手段去修改对象的状态。
3. 对于同一个（领域）模型，考虑将那些纯粹的查询功能从命令功能中分离出来。聚合将不再有查询方法，而只有命令方法。 资源库也将变成只有add或save方法（分别支持创建和更新操作），同时只有一个查询方法，比如fromId()。这个唯一的查询方法将聚合的身份标识作为参数， 然后返回该聚合实例。在将所有的查询方法移除之后，我们将此时的模型称为命令模型。但我们仍需要向用户显示数据，为此我们创建第二个模型——查询模型，专门用于优化查询。领域模型被一分为二。


## 实体

开发者趋向于将关注点放在数据上，而不是领域上。在软件开发中，数据库依然占据着主导地位。我们应首先考虑的是数据的属性（对应数据库的列）和关联关系（外键关联），而是富有行为的领域概念。这样做的结果是将数据模型直接反映在对象模型上，导致那些表示领域模型的实体包含了大量getter和setter方法。

唯一身份标识和可变性特征将实体对象和值对象区分开来。 

## 其它

无论你选择做什么，总有人说你是错的，又总有这样那样的困难诱使你相信批评你的人是对的。要找到一条正确之路并坚持到最后，你需要的是勇气。 

一旦你没有被击倒，那么你所做的选择将双倍的补偿你




