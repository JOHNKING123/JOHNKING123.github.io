---

layout: post
title: java io涉及到的一些linux知识
category: 技术
tags: Linux
keywords: network 

---

## 简介

## io设备

磁盘(和内存)是一个可寻址的大数组（内存寻址：段 ==> 页 => 字节，磁盘寻址 磁盘 ==> xx ==> 字节），而os和应用都无法直接访问这个大数组（**强调，即便是os，也是通过文件系统，即`/xx/xx`的方式来访问文件的**）。文件系统则是更高层抽象，文件系统定义了文件名、路径、文件、文件属性等抽象，文件系统决定这些抽象数据保存在哪些块中。

||设备|
|---|---|
|面向流|tty、socket|
|面向块|磁盘|

当我们需要进行文件操作的时候，5个API函数是必不可少的。Create，Open，Close，Write和Read函数实现了对文件的所有操作。我们很多时候，觉得close方法没用，但一个文件io都会占用一个fd句柄啊。

## 中断和挂起

中断和挂起不是一回事儿，中断不一定引起当前进程的挂起。中断只是当前cpu停止执行进程代码。这里有两个重点：

1. 当前cpu，这意味着进程可以立刻被其它cpu执行
2. 进程代码，当前cpu转而执行中断处理程序

挂起则是，进程等待一定的条件，在条件满足之前，不会被调度到任何cpu执行。

||触发者|反应|其它|
|---|---|---|---|
|硬中断|硬件|当前cpu保存当前进程现场，执行中断处理程序|时钟中断会引起当前进程的挂起，其它中断则不一定|
|软中端|当前使用cpu的进程|cpu将当前运行的现场状态保存在堆栈中，为的不是切换进程，而是执行完系统调用处理程序后，接着执行该进程|某些系统调用处理程序会挂起当前进程|

## 硬中断和软中断

删改自[进程内核栈、用户栈](http://www.cnblogs.com/shengge/articles/2158748.html)

内核在创建进程的时候，在创建task_struct的同时，会为进程创建相应的堆栈。每个进程会有两个栈，一个用户栈，存在于用户空间，一个内核栈，存在于内核空间。当进程在用户空间运行时，cpu堆栈指针寄存器里面的内容是用户堆栈地址，使用用户栈；当进程在内核空间时，cpu堆栈指针寄存器里面的内容是内核栈空间地址，使用内核栈。

当进程因为中断或者系统调用而陷入内核态之行时，进程所使用的堆栈也要从用户栈转到内核栈。

如何相互切换呢？

进程陷入内核态后，先把用户态堆栈的地址保存在内核栈之中，然后设置堆栈指针寄存器的内容为内核栈的地址，这样就完成了用户栈向内核栈的转换；当进程从内核态恢复到用户态执行时，在内核态执行的最后，将保存在内核栈里面的用户栈的地址恢复到堆栈指针寄存器即可。这样就实现了内核栈和用户栈的互转。

那么，我们知道从内核转到用户态时用户栈的地址是在陷入内核的时候保存在内核栈里面的，但是在陷入内核的时候，我们是如何知道内核栈的地址的呢？

关键在进程从用户态转到内核态的时候，进程的内核栈总是空的。这是因为，一旦进程从内核态返回到用户态后，内核栈中保存的信息无效，会全部恢复。因此，每次进程从用户态陷入内核的时候得到的内核栈都是空的，直接把内核栈的栈顶地址给堆栈指针寄存器就可以了。

联系下下文的read、write、select、 fcntl(fd, F_SETFL, flags | O_NONBLOCK)等系统调用，或许对java nio有一些会心的体会。

## 同步异步

[多种I/O模型及其对socket效率的改进](http://mickhan.blog.51cto.com/2517040/1586370)


对于一次IO访问（以read举例），数据会先被拷贝到**操作系统内核的缓冲区**中（socket有一个send buffer和receive buffer），然后才会从操作系统内核的缓冲区拷贝到**应用程序的地址空间**。所以说，当一个read操作发生时，它会经历两个阶段：

1. 等待数据准备 (Waiting for the data to be ready)
2. 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)

正式因为这两个阶段，linux系统产生了下面五种网络模式的方案。参见[Linux IO模式及 select、poll、epoll详解](https://segmentfault.com/a/1190000003063859)

文中关于异步io的描述：用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。

也就是说，不管是阻塞、非阻塞、多路复用io，其本质都是用户进程主动去发现socket send/receive buffer是否ready，而异步io则是内核主动向用户进程发起通知的。在多线程模型下，多路复用io和异步io从感官上不太明显，netty甚至完全可以将多路复用io封装为异步的。但在单线程模型下，两者还是有本质差异的。
        

## 阻塞非阻塞

	ssize_t read(int fd, void *buf, size_t count);
	ssize_t write(int fd, const void *buf, size_t count);

为socket设置nonblocking

		// 设置一个文件描述符为nonblock
		int set_nonblocking(int fd){
		    int flags;
		    if ((flags = fcntl(fd, F_GETFL, 0)) == -1)
		        flags = 0;
		    return fcntl(fd, F_SETFL, flags | O_NONBLOCK);
		}

[浅谈TCP/IP网络编程中socket的行为](http://www.cnblogs.com/promise6522/archive/2012/03/03/2377935.html)讲到了两个关键问题

1. read/write的语义：为什么会阻塞？
2. blocking（默认）和nonblocking模式下read/write行为的区别。
      
或者，我们可以说，**blocking和nonblocking的本质，就是影响了read/write（可能还有connect）的语义**

## select

java nio中，介绍channel用的是：A nexus（连结、连系） for I/O operations.那么selector便是 a nexus for `int select(int nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, struct timeval *timeout);`

据此，我们可以认识到，我们感觉的java nio是一系列机制的综合体现：

1. io操作分为两个部分：是否可以进行io操作（socket的send buffer和receive buffer是否可用）；实际进行io操作（不同地址空间复制buffer）
2. fd option 设置为 O_NONBLOCK，即将上述第一部分的判断交给了select系统调用。也就是说，原先一个系统调用可以完成的事情，现在交给了两个系统调用，触发这两个系统调用的可能不是一个线程。


## 引用

[存储之道 - 51CTO技术博客 中的《一个IO的传奇一生》](http://alanwu.blog.51cto.com/3652632/d-8)



