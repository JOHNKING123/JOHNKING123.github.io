---

layout: post
title: 《趣谈Linux操作系统》笔记
category: 技术
tags: Linux
keywords: linux命令 

---

## 简介（持续更新）

* TOC
{:toc}

所谓成长，就是知道自己目前**在哪里**，清楚将要**去哪里**，然后通过学习和行动到达目的地。

## 进程——为啥创建进程的 系统调用起名叫fork（分支） 

**一句看似废话的废话：进程是进程创建出来的**

创建进程的系统调用叫fork。这个名字很奇怪，中文叫“分支”为啥启动一个新进程叫“分支”呢？在 Linux 里，要创建一个新的进程，需要一个老的进程调用fork 来实现，其中老的进程叫作父进程（Parent Process），新的进程叫作子进程（Child Process）。当父进程调用 fork 创建进程的时候，子进程将各个子系统为父进程创建的数据结构也全部拷贝了一份，甚至连程序代码也是拷贝过来的。


对于 fork 系统调用的返回值，如果当前进程是子进程，就返回0；如果当前进程是父进程，就返回子进程的进程号。这样首先在返回值这里就有了一个区分，然后通过 if-else 语句判断，如果是父进程，还接着做原来应该做的事情；如果是子进程，需要请求另一个系统调用execve来执行另一个程序，这个时候，子进程和父进程就彻底分道扬镳了，也即产生了一个分支（fork）了。

    public static void main(String[] args) throws IOException {
        Process process = Runtime.getRuntime().exec("/bin/sh -c ifconfig");
        //
        //  jvm这里隐藏了一个 父子进程  判断的过程
        //
        Scanner scanner = new Scanner(process.getInputStream());
        while (scanner.hasNextLine()) {
            System.out.println(scanner.nextLine());
        }
        scanner.close();
    }

新进程 都是父进程fork出来的，那到底谁是第一个呢？这就是涉及到系统启动过程了。

突然想起来，linux 和 git 都是大佬Linus的 杰作。

## 内存管理 brk和mmap

内存空间都是”按需分配“的，但在OS层面上，都是整存整取的。对于`int[] array = new int[100];`

|层次|表现|array对应的感觉|
|---|---|---|
|java 语言|申请一个数组，得到一个引用array|进程标识 + 进程内 偏移地址|
|jvm|在堆里申请一段空间|进程数据段地址 + 偏移地址|
|os|对于一般进程，就是申请时给进程的堆一段空间。<br>对于jvm 就是jvm 启动时申请一段连续的空间，然后再由jvm自行管理内存分配|物理内存地址|

## 一切皆文件

“一切皆文件”的优势，就是统一了操作的入口

## x86 架构

![](/public/upload/linux/hardware_architecture.jpeg)

### “指令格式-cpu结构-总线”的暧昧关系

![](/public/upload/linux/cpu_architecture.jpeg)

我们以一段x86汇编代码为例

    mov [ebp-4], edi   ; Move EDI into the local variable
    add [ebp-4], esi   ; Add ESI into the local variable
    add eax, [ebp-4]   ; Add the contents of the local variable

CPU 的控制单元里面，有一个指令指针寄存器，执行的是下一条指令在内存中的地址。控制单元会不停地将代码段的指令拿进来，先放入指令寄存器。当前的指令分两部分，一部分是做什么操作，例如是加法还是位移；一部分是操作哪些数据。**要执行这条指令，就要把第一部分交给运算单元，第二部分交给数据单元**。数据单元根据数据的地址，从数据段里读到数据寄存器里，就可以参与运算了。运算单元做完运算，产生的结果会暂存在数据单元的数据寄存器里。最终，会有指令将数据写回内存中的数据段。

CPU 里有两个寄存器，专门保存当前处理进程的代码段的起始地址，以及数据段的起始地址。这里面写的都是进程 A，那当前执行的就是进程 A 的指令，等切换成进程 B，就会执行 B的指令了，这个过程叫作进程切换（Process Switch）（注意跟线程切换做区别）

CPU 和内存来来回回传数据，靠的都是总线。其实总线上主要有两类数据，一个是地址数据，也就是我想拿内存中哪个位置的数据，这类总线叫地址总线（Address Bus）；另一类是真正的数据，这类总线叫数据总线（Data Bus）。

|程序|算法|数据结构|
|---|---|---|
|指令|操作码|立即数/地址|
|cpu|运算单元|数据单元|
|整体结构|cpu|内存|地址总线/数据总线|

![](/public/upload/linux/cpu_architecture_detail.jpeg)

程序是代码写的，所以一定要有”代码段“。代码的执行过程 会产生临时数据，所以要有”数据段“（当然数据段根据数据特点，一般分为堆和栈）。PS：这种描述方式很有感觉。[进程管理信息数据结构](http://qiankunli.github.io/2017/02/14/linux_art_review.html) 二进制文件分段 ==> 进程分段 ==> 指令操作码/操作数 ==> cpu运算单元/数据单元 ==> cpu代码段寄存器/数据段寄存器/堆栈段寄存器等 有一种软硬件融合的味道。

一切运算即加法，一切分支代码即jump

### 为什么要有保护模式？

1. CPU的位数是指CPU能一次同时寄存和处理二进制数码的位数，这和CPU中寄存器的位数对应，一般和数据总线的宽度一致（过宽了数据寄存器也存不下）
2. 数据总线DB用于传送数据信息。数据总线是双向三态形式的总线，即他既可以把CPU的数据传送到存储器或I／O接口等其它部件，也可以将其它部件的数据传送到CPU。”地址总线AB是专门用来传送地址的，由于地址只能从CPU传向外部存储器或I／O端口，所以地址总线总是单向三态的，这与数据总线不同。

[Intel CPU 发展简史](http://chengqian90.com/%E6%9D%82%E8%B0%88/Intel-CPU-%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2.html)

![](/public/upload/linux/cpu_x86.png)

[关于“实模式”和“保护模式”](https://www.kancloud.cn/digest/linuxnotes/161268) [实模式与保护模式解惑之（一）——二者的起源与区别](https://blog.csdn.net/trochiluses/article/details/8954527)

1. 最开始 数据总线与地址总线宽度一致
2. “段:偏移”模式。后来，8086cpu可以处理的二进制码是16位，也就是cpu能够表达的地址最大是16位的。需要一个16位内存地址到20位实际地址的转换的过程。为什么是20 不是32呢？[CPU的历史疑惑当初8086cpu为什么不直接设计成32根地址总线呢,弄成20根,用段+偏移的寻址方式不觉得尴尬吗？]
(https://www.zhihu.com/question/23567412/answer/498882312) 因为当时的程序猿感觉1M内存就够大了。但”段地址“确实是个不错的副产品
3. 到这个时候，无论数据总线与地址总线宽度一致，程序员指定的地址就是物理地址，物理地址对程序员是可见的。但是，由此也带来两个问题：

    1. 无法支持多任务
    2. 程序的安全性无法得到保证(用户程序可以改写系统空间或者其他用户的程序内容)

4. “段选择符:段内偏移地址”，保护模式和实模式的区别在于它是用段选择符而非段基地址，段选择符中包含特权级 信息

## 操作系统是一个main函数

从加载顺序可以看到

1. BIOS、Bootloader 与 os 的边界
2. os 内核（是一个单独的内核镜像，也对应内核态） 与 os其它部分的边界（对应用户态）

### 为什么不直接加载操作系统？

||存储|加载到内存|功能|
|---|---|---|---|
|BIOS（Basic Input and Output System）|ROM|ROM 直接映射到内存|检查硬件<br>简单的中断表使你可以使用鼠标和键盘<br>加载启动盘|
|GRUB|磁盘MBR|第一个扇区直接映射到内存 ==> 加载第二阶段引导程序 ==> 加载内核镜像|展示内核列表<br>加载用户选中的linux内核文件|
|内核|文件系统某个(img)文件|
|用户态init进程|文件系统某个可执行文件|

从上到下

1. 所需内存空间越来越大；
2. 对于内核代码还值得信任，启动用户代码时，就要开启保护模式了
3. 地址/直接引用（BIOS地址，MBR地址） ==> (内存/磁盘)文件系统引用；中断表等符号引用

1. 启动的第一个动作为什么不是字节将内核镜像copy至内存 然后执行？因为不知道内核镜像在哪？不知道用户要启动哪个？不知道用户镜像有多大（也就不知道拷贝多少）？
1. 文件系统驱动太大，无法弄到内核，就先弄一个内存文件系统`initrd16 /boot/initramfs-3.10.0-862.el7.x86_64.img` ，等内核启动成功后再加载。PS：内核也玩懒加载这一套
2. GNU GRUB（GRand Unified Bootloader简称“GRUB”）是一个来自GNU项目的多操作系统启动程序。GRUB是多启动规范的实现，它允许用户可以在计算机内同时拥有多个操作系统，并在计算机启动时选择希望运行的操作系统。

### 操作系统是一个main函数/中断处理程序的集合

[操作系统是一个main函数](http://qiankunli.github.io/2017/02/14/linux_art_review.html) 提出了两个问题：

1. 为什么没有最先调用main函数？
2. 为什么加载工作完成后，仍然没有执行main函数，而是打开A20、pe和pg，建立IDT和GDT…，然后才开始执行main函数？
3. 当我们说写一个操作系统，是从main函数开始写么？
3. **为什么可以单独升级内核？**一个重要原因就是 内核从本质上看是一种软件，系统调用是其为上层提供的访问接口。就像docker 看着像一个整体，但docker client 与docker daemon 是分开的。系统调用作为一个接口，是一个协议和约定（比如80中断号），但不是一个代码引用。

内核的启动从入口函数 start_kernel() 开始。在 init/main.c 文件中，start_kernel 相当于内核的 main 函数。打开这个函数，你会发现，里面是各种各样初始化函数 XXXX_init。

![](/public/upload/linux/start_kernel.jpeg)








