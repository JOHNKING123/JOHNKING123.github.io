---

layout: post
title: Linux内核基础知识
category: 技术
tags: Linux
keywords: linux 内核

---

## 简介

* TOC
{:toc}

[Linux虚拟地址空间布局以及进程栈和线程栈总结](https://www.cnblogs.com/sky-heaven/p/7112006.html)

## 虚拟地址空间：用户空间和内核空间

### 进程“独占”虚拟内存及虚拟内存划分

为了保证操作系统的稳定性和安全性。用户程序不可以直接访问硬件资源，如果用户程序需要访问硬件资源，必须调用操作系统提供的接口，这个调用接口的过程也就是系统调用。每一次系统调用都会存在两个内存空间之间的相互切换，通常的网络传输也是一次系统调用，通过网络传输的数据先是从内核空间接收到远程主机的数据，然后再**从内核空间复制到用户空间**，供用户程序使用。这种从内核空间到用户空间的数据复制很费时，虽然保住了程序运行的安全性和稳定性，但是牺牲了一部分的效率。

如何分配用户空间和内核空间的比例也是一个问题，是更多地分配给用户空间供用户程序使用，还是首先保住内核有足够的空间来运行。在当前的Windows 32位操作系统中，默认用户空间：内核空间的比例是1:1，而在32位Linux系统中的默认比例是3:1（3GB用户空间、1GB内核空间）（这里只是地址空间，映射到物理地址，可没有某个物理地址的内存只能存储内核态数据或用户态数据的说法）。

||用户地址空间|内核地址空间|备注|
|---|---|---|---|
|地址类型|虚拟地址|虚拟地址|都要经过 MMU 的翻译，变成物理地址|
|生存期|随进程创建产生|持续存在|
|共享|进程独占|所有进程共享|
|地址映射方式|走四级页表来翻译|线性映射|内核空间也必须有一部分是非线性映射，比如下图的vmalloc|
|地址映射/页表创建|随进程创建产生|内核在初始化时，就创建内核空间的映射，所有进程共享|
|对应物理空间|分散且不固定|提前固定下来一片连续的物理地址空间，所有进程共享|

“进程独占内存”的内涵：每个进程有自己独立的页表映射，当然内核地址空间是一样的，页表映射也是共享的，在创建进程时候，就可以直接“拷贝”内核的页表，作为该进程 的页表的一部分。进程用户地址空间部分另外映射。

![](/public/upload/linux/virtual_memory_space.jpg)

左右两侧均表示虚拟地址空间，左侧以描述内核空间为主，右侧以描述用户空间为主。

### 在代码上的体现

    // 持有task_struct 便可以访问进程在内存中的所有数据
    struct task_struct {
        ...
        struct mm_struct                *mm;
        struct mm_struct                *active_mm;
        ...
        void  *stack;   // 指向内核栈的指针
    }

内核使用内存描述符mm_struct来表示进程的地址空间，该描述符表示着进程所有地址空间的信息

![](/public/upload/linux/mm_struct.png)

## 地址空间内的栈：用户栈和内核栈

### 栈的切换

删改自[进程内核栈、用户栈](http://www.cnblogs.com/shengge/articles/2158748.html)

内核在创建进程的时候，在创建task_struct的同时，会为进程创建相应的堆栈。每个进程会有两个栈，一个用户栈，存在于用户空间，一个内核栈，存在于内核空间。**当进程在用户空间运行时，cpu堆栈指针寄存器里面的内容是用户堆栈地址，使用用户栈；当进程在内核空间时，cpu堆栈指针寄存器里面的内容是内核栈空间地址，使用内核栈**。

当进程因为中断或者系统调用而陷入内核态之行时，进程所使用的堆栈也要从用户栈转到内核栈。

如何相互切换呢？

进程陷入内核态后，先把用户态堆栈的地址保存在内核栈之中，然后设置堆栈指针寄存器的内容为内核栈的地址，这样就完成了用户栈向内核栈的转换；当进程从内核态恢复到用户态执行时，在内核态执行的最后，将保存在内核栈里面的用户栈的地址恢复到堆栈指针寄存器即可。这样就实现了内核栈和用户栈的互转。

那么，我们知道从内核转到用户态时用户栈的地址是在陷入内核的时候保存在内核栈里面的，但是在陷入内核的时候，我们是如何知道内核栈的地址的呢？

**关键在进程从用户态转到内核态的时候，进程的内核栈总是空的**。这是因为，一旦进程从内核态返回到用户态后，内核栈中保存的信息无效，会全部恢复。因此，每次进程从用户态陷入内核的时候得到的内核栈都是空的，直接把内核栈的栈顶地址给堆栈指针寄存器就可以了。

### 为什么需要单独的进程内核栈？

内核地址空间所有进程空闲，但内核栈却不共享。为什么需要单独的进程内核栈？**因为同时可能会有多个进程在内核运行**。

所有进程运行的时候，都可能通过系统调用陷入内核态继续执行。假设第一个进程 A 陷入内核态执行的时候，需要等待读取网卡的数据，主动调用 schedule() 让出 CPU；此时调度器唤醒了另一个进程 B，碰巧进程 B 也需要系统调用进入内核态。那问题就来了，如果内核栈只有一个，那进程 B 进入内核态的时候产生的压栈操作，必然会破坏掉进程 A 已有的内核栈数据；一但进程 A 的内核栈数据被破坏，很可能导致进程 A 的内核态无法正确返回到对应的用户态了。

进程内核栈在**进程创建的时候**，通过 slab 分配器从 thread_info_cache 缓存池中分配出来，其大小为 THREAD_SIZE，一般来说是一个页大小 4K；


## 中断栈

[Java和操作系统交互细节](https://mp.weixin.qq.com/s/fmS7FtVyd7KReebKzxzKvQ)中断有点类似于我们经常说的事件驱动编程，而这个事件通知机制是怎么实现的呢，硬件中断的实现通过一个导线和 CPU 相连来传输中断信号，软件上会有特定的指令，例如执行系统调用创建线程的指令，而 CPU 每执行完一个指令，就会检查中断寄存器中是否有中断，如果有就取出然后执行该中断对应的处理程序。

当系统收到中断事件后，进行中断处理的时候，也需要中断栈来支持函数调用。由于系统中断的时候，系统当然是处于内核态的，所以中断栈是可以和内核栈共享的。但是具体是否共享，这和具体处理架构密切相关。ARM 架构就没有独立的中断栈。

## 进程调度

![](/public/upload/linux/process_schedule.png)

    struct task_struct{
        ...
        unsigned int policy;

        int prio, static_prio, normal_prio;
        unsigned int rt_priority;
        ...
        const struct sched_class *sched_class;
    }




