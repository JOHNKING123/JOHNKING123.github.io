---

layout: post
title: Redis 学习
category: 技术
tags: Data
keywords: Redis

---

## 前言（未完成）

建议看下前文 [缓存系统](http://qiankunli.github.io/2015/06/26/cache_system.html)

java 使用层面，参见[Jedis分析](http://qiankunli.github.io/2016/06/07/jedis_sdr.html)

## redis 为什么快？

[为什么说Redis是单线程的以及Redis为什么这么快！](https://blog.csdn.net/xlgen157387/article/details/79470556)

1. 单线程

	* 避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU
	* 不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；

2. 使用多路I/O复用模型，非阻塞IO。用java 表示就是该线程

		while(true){
			key = selector.select(...)
			// 有请求的连接才会返回，没请求的连接就一边呆着
			// 有本启奏，无事退朝
		}
		
	采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），线程不被会一个连接的io操作（connect/accept/read/write） 阻塞住
	
3. 基于内存


|范畴|多路|复用|
|---|---|---|
|io|多个连接|一个线程|
|key读写|多个key|缓存必须设定最大容量 ==> 清除操作<br>evict 在 read 和write 操作中进行|
	
## 为什么Redis是单线程的
	
[Redis is single threaded. How can I exploit multiple CPU / cores?](https://redis.io/topics/faq)

It's not very frequent that CPU becomes your bottleneck with Redis, as usually Redis is either memory or network bound. For instance, using pipelining Redis running on an average Linux system can deliver even 1 million requests per second。cpu 以及内存读写 的速度足够快，以至于一个线程便支持了100w QPS。很多时候， 瓶颈是内存大小及带宽。也就是说，即便支持了多线程，支持了更高的QPS， 更有可能的是你的网卡带宽先被打满了。

However, to maximize CPU usage you can start multiple instances of Redis in the same box and treat them as different servers. 

However with Redis 4.0 we started to make Redis more threaded. For now this is limited to deleting objects in the background, and to blocking commands implemented via Redis modules. For the next releases, the plan is to make Redis more and more threaded.

单线程机制在进行sunion之类的比较耗时的命令时会使redis的并发下降。因为是单一线程，所以同一时刻只有一个操作在进行，所以，耗时的命令会导致并发的下降，不只是读并发，写并发也会下降。

[为什么说Redis是单线程的以及Redis为什么这么快！](https://blog.csdn.net/xlgen157387/article/details/79470556)我们不能任由操作系统负载均衡，因为我们自己更了解自己的程序，所以，我们可以手动地为其分配CPU核，而不会过多地占用CPU。**类似于netty的arena类似，在极端追求性能的场合，一些中间件会亲自插手cpu调度、内存分配，而不是听从语言的runtime 或操作系统。**

## bitmap

[Bitmap的秘密](http://www.infoq.com/cn/articles/the-secret-of-bitmap/)

概念、原理、使用、代码

[Redis BitMap 介绍及使用](https://toutiao.io/posts/89id5l/preview)

## codis

github 地址[CodisLabs/codis](https://github.com/CodisLabs/codis) 基于go 语言开发，是一个很好的了解go 及 分布式开发的项目。

[Codis 使用文档](https://github.com/CodisLabs/codis/blob/release3.2/doc/tutorial_zh.md)
Codis 是一个分布式 Redis 解决方案, 对于上层的应用来说, 连接到 Codis Proxy 和连接原生的 Redis Server 没有显著区别 (不支持的命令列表), 上层应用可以像使用单机的 Redis 一样使用, Codis 底层会处理请求的转发, 不停机的数据迁移等工作, 所有后边的一切事情, 对于前面的客户端来说是透明的, 可以简单的认为后边连接的是一个内存无限大的 Redis 服务。

### 源码分析

主要是两个package

cmd 命令入口，即通过命令行 启动 socket server 程序等
pkg 各个组件的源码文件