---

layout: post
title: 学习并发
category: 技术
tags: Concurrency
keywords: concurrency

---

## 前言


## java并发的发展历程

1. 使用原始的synchronized关键字，wait和notify等方法，实现锁和同步。

2. jkd1.5和jdk1.6提供了concurrent包，包含Executor，高效和并发的数据容器，原子变量和多种锁。更多的封装减少了程序员自己动手写并发程序的场景，并提供lock和Condition对象的来替换替换内置锁和内置队列。

3. jdk1.7提供ForkJoinTask支持，还未详细了解，估计类似于MapReduce，其本身就是立足于编写可并行执行程序的。

通过阅读《java并发编程实战》全书的脉络如下

1. 什么是线程安全，什么导致了线程不安全？
2. 如何并行程序串行化，常见的并行化程序结构是什么？Executor，生产者消费者模式
3. 如何构造一个线程安全的类（提高竞争效率），如何构造一个依赖状态的类（提高同步效率）？提高性能的手段有哪些？ 使用现有工具类 or 扩充已有父类？

性能优化的基本点就是：减少上下文切换和线程调度（挂起与唤醒）操作。从慢到快的性能对比：

1. synchronized操作内置锁，wait和notify操作内置队列。考虑到现在JVM对其实现进行了很大的优化，其实性能也还好。
2. AQS及AQS包装类
3. Lock和Condition（如果业务需要多个等待线程队列的话）

从上到下，jvm为我们做的越少，灵活性越高，更多的问题要调用者自己写在代码里（执行代码当然比劳烦jvm和os效率高很多），使用的复杂性越高。


## 理念变化

[并发之痛 Thread，Goroutine，Actor](http://lenix.applinzi.com/archives/2945)中的几个基本要点：

1. 那我们从最开始梳理下程序的抽象。开始我们的程序是面向过程的，数据结构+func。后来有了面向对象，对象组合了数结构和func，我们想用模拟现实世界的方式，抽象出对象，有状态和行为。但无论是面向过程的func还是面向对象的func，**本质上都是代码块的组织单元，本身并没有包含代码块的并发策略的定义。**于是为了解决并发的需求，引入了Thread（线程）的概念。

2. We believe that writing correct concurrent, fault-tolerant and scalable applications is too hard. Most of the time it’s because we are using the wrong tools and the wrong level of abstraction. —— Akka。，有论文认为当前的大多数并发程序没出问题只是并发度不够，如果CPU核数继续增加，程序运行的时间更长，很难保证不出问题

3. 最让人头痛的还是下面这个问题：系统里到底需要多少线程？从外部系统来观察，或者以经验的方式进行计算，都是非常困难的。于是结论是：让"线程"会说话，吃饱了自己说，自管理是最佳方案。

4. 能干活的代码片段就放在线程里，如果干不了活（需要等待，被阻塞等），就摘下来。我自己的感觉就是：**按需（代码被阻塞）调度，有别于cpu的按时间片调度。**

	* 异步回调方案 典型如NodeJS，遇到阻塞的情况，比如网络调用，则注册一个回调方法（其实还包括了一些上下文数据对象）给IO调度器（linux下是libev，调度器在另外的线程里），当前线程就被释放了，去干别的事情了。等数据准备好，调度器会将结果传递给回调方法然后执行，执行其实不在原来发起请求的线程里了，但对用户来说无感知。
	* GreenThread/Coroutine/Fiber方案 这种方案其实和上面的方案本质上区别不大，关键在于回调上下文的保存以及执行机制。为了解决回调方法带来的难题，这种方案的思路是写代码的时候还是按顺序写，但遇到IO等阻塞调用时，将当前的代码片段暂停，保存上下文，**让出当前线程**。等IO事件回来，然后再找个线程让当前代码片段恢复上下文继续执行，写代码的时候感觉好像是同步的，仿佛在同一个线程完成的，但实际上系统可能切换了线程，但对程序无感。
	* 小结一下：前者即全异步操作，代码直观体现。后者还是阻塞操作，代码顺序写，只是阻塞的是goroutine 之类。

[Scala与Golang的并发实现对比](https://zhuanlan.zhihu.com/p/20009659)













