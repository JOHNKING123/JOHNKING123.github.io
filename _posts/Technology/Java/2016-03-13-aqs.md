---

layout: post
title: AQS1——并发相关的硬件与内核支持
category: 技术
tags: Java
keywords: AQS

---

## 简介

AQS其实就是`java.util.concurrent.locks.AbstractQueuedSynchronizer`。这个类是整个java.util.concurrent的核心之一，是理解整个java并发包的突破口。

有些时候，名词限制了我们对事物的认识。我们谈到锁、信号量这些，分析它们如何实现，或许走入了一个误区。[Locks, Mutexes, and Semaphores: Types of Synchronization Objects](https://www.justsoftwaresolutions.co.uk/threading/locks-mutexes-semaphores.html) 中认为锁是一个抽象概念，包括：

1. 竞态条件。只有一个进入，还是多个进入，还是读写进入，线程能否重复获取自己已占用的锁
2. 获取锁失败时的反应。提示失败、自旋还是直接阻塞，阻塞能不能被打断

按照这些不同，人们给他mutex、信号量等等命名

**所以，本文更愿意将锁描述为：抽象并发问题、提供并发支持。**


## 硬件对并发的支持

实现原子操作：

* 关中断指令、内存屏障指令、停止相关流水线指令
* 对于单核cpu，禁止抢占。
* 对于SMP，提供lock 指令。lock指令是一种前缀，它可与其他指令联合，用来维持总线的锁存信号直到与其联合的指令执行完为止。比如基于AT&T的汇编指令`LOCK_PREFIX xaddw %w0,%1`，xaddw 表示先交换源操作数和目的操作数，然后两个操作数求和，存入目的寄存器。为了防止这个过程被打断，加了LOCK_PREFIX的宏（修饰lock指令）。

这些指令，辅助一定的算法，就可以包装一个自旋锁、读写锁、顺序锁出来。os中，lock一词主要指自旋锁。
	
## 操作系统对并发的支持

操作系统内部，本就存在对资源的并发访问。

通过对硬件指令的包装，os提供原子整数操作等系统调用。本质上，通过硬件指令，可以提供对一个变量的独占访问。

	int atomic_read(const atomic_t *v)
	// 将v设置为i
	int atomic_set(atomic_t *v,int id);


通过对硬件指令的封装，操作系统可以封装一个自旋锁出来。

1. 获取锁spin_lock_irq：用变量标记是否被其他线程占用，变量的独占访问，发现占用后自旋，结合关中断指令。
2. 释放锁spin_unlock_irq：独占的将变量标记为未访问状态

那么在获取锁与释放锁之间，可以实现一个临界区。

	spin_lock_irq();
	// 临界区
	spin_unlock_irq();


操作系统中，semaphore与自旋锁类似的概念，只有得到信号量的进程才能执行临界区的代码；不同的是获取不到信号量时，进程不会原地打转而是进入休眠等待状态

	struct semaphore{
		spinlock_t lock;
		unsigned int count;
		struct list_head wait_list;
	}
	// 获取信号量，会导致睡眠
	void down(struct semaphore *sem);
	// 获取信号量，会导致睡眠，但睡眠可被信号打断
	int down_interruptible(struct semaphore *sem);
	// 无论是否获得，都立即返回，返回值不同，不会导致睡眠
	int down_trylock(struct semaphore *sem);
	// 释放信号量
	void up(struct semaphore *sem))
	

通过自旋锁，os可以保证count 修改的原子性。线程尝试修改count的值，根据修改后count值，决定是否挂起当前进程，进而提供semaphore和mutex（类似于semaphore=1）等抽象。**也就是说，semaphore = 自旋锁 + 线程挂起/恢复。**

[大话Linux内核中锁机制之原子操作、自旋锁](http://blog.sina.com.cn/s/blog_6d7fa49b01014q7p.html)

[大话Linux内核中锁机制之内存屏障、读写自旋锁及顺序锁](http://blog.sina.com.cn/s/blog_6d7fa49b01014q86.html)

[大话Linux内核中锁机制之信号量、读写信号量](http://blog.sina.com.cn/s/blog_6d7fa49b01014q8y.html)

[大话Linux内核中锁机制之完成量、互斥量](http://blog.sina.com.cn/s/blog_6d7fa49b01014q9b.html)

		
## java对并发的支持

|进程的基本状态|运行|就绪|阻塞|退出|
|---|---|---|---|---|
|Linux| TASK_RUNNING ||TASK_INTERRUPTIBLE、TASK_UNINTERRUPTIBLE|TASK_STOPPED/TASK_TRACED、TASK_DEAD/EXIT_ZOMBIE|
|java|| RUNNABLE | BLOCKED、WAITING、TIMED_WAITING|TERMINATED|

![](/public/upload/java/thread_status.jpg)

从中可以发现，linux没按os课本上的来，java没按os的来。为了管理进程时方便，都会在进程基本状态里细分几种状态。这里主要讲下java中的blocked、waiting

1. blocked，过去分词，被卡住的。线程进入这个状态完全是无辜的，只要别的线程退出临界区，jvm自动解除线程的blocked状态
2. waiting，主动卡住自己，别的线程调用notify后，jvm解除线程的waiting状态
3. time_wating，通过`Thread.sleep()` 进入该状态。相当于使用某个时间资源作为锁对象，当时间达到时，触发线程回到工作状态。

从linux内核来看， BLOCKED、WAITING、TIMED_WAITING都是等待状态。做这样的区分，是jvm出于管理的需要（两个原因的线程放两个队列里管理，如果别的线程运行出了synchronized这段代码，jvm只需要去blocked队列，放个出来。而某人调用了notify()，jvm只需要去waitting队列里取个出来。），本质上是：who when how唤醒线程。

[Java线程中wait状态和block状态的区别? - 赵老师的回答 - 知乎](
https://www.zhihu.com/question/27654579/answer/128050125)

## cas 与锁


||可以保护的内容|临界区描述|执行体竞争失败的后果|
|---|---|---|---|
|硬件|一个内存的值|某时间只可以执行一条指令|没什么后果，继续执行|
|os-自旋|变量/代码|多用于修改变量（毕竟lock指令太贵了）|自旋|
|os-信号量|变量/代码|代码段不可以同时执行|挂起|

一个复杂项目由n行代码实现，一行代码由n多系统调用实现，一个系统调用由n多指令实现。那么从线程安全的角度看：锁住系统总线，某个时间只有一条指令执行 ==> 安全的修改一个变量 ==> 提供一个临界区。通过向上封装，临界区的粒度不断地扩大。

在语言层面，也可以借助一些api模拟这个过程：


[高性能队列——Disruptor](https://tech.meituan.com/disruptor.html)

锁实现

  	final ReentrantLock lock = this.lock;
    lock.lock();
    try {
    	这个区域的代码可以认为是线程安全的
       
    } finally {
        lock.unlock();
    }

cas实现
	
    for (;;) {
        int current = get();
        
        这个区域的代码可以认为是线程安全的
        
        int next = current + delta;
        if (compareAndSet(current, next))
            return current;
    }
	

## 引用

[AbstractQueuedSynchronizer的介绍和原理分析][]

[Java并发包源码学习之AQS框架][]

[AbstractQueuedSynchronizer的介绍和原理分析]: http://ifeve.com/introduce-abstractqueuedsynchronizer/
[队列的操作的C语言实现 ]: http://blog.chinaunix.net/uid-20788636-id-1841327.html
[Java并发包源码学习之AQS框架]: http://www.cnblogs.com/zhanjindong/p/java-concurrent-package-aqs-overview.html