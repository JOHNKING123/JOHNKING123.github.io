---

layout: post
title: 《jdk8 in action》笔记2
category: 技术
tags: Java
keywords: java forkjoin

---

## 简介

## 使用java8 重构现有代码

### 提高可读性

1. from anonymous classes to lambda expressions ==> from lambda expressions to method references
2. from imperative data processing to Streams

### 提高灵活性

1. adopting functional interfaces

	* conditional deferred execution。看go 语言中的defer 关键字异曲同工

		比如log4j 写日志`logger.debug("the message is {}",executeMessage())`，意味着，即便日志级别是INFO，debug 日志不会打出，但executeMessage() 仍要执行一次。如果将api 换成 `void debug(String format,Supplier<String> msg Supplier)` ==> `logger.debug("the message is {}",() -> executeMessage())` 则可以相机执行 `executeMessage()` **从中也可以看到，将Supplier 和 实际对象作为 参数的不同之处，绝不是多此一举。** 更进一步，以函数作为输入，同时返回一个函数，就是高阶函数，要尝试多用 高阶函数
	* execute around
2. refactoring object-oriented design patterns with lambdas。你会看到

	* 工厂模式成了一个map
	* 责任链模式，链的组成过程成了Function.andThen().andThen()


## 测试

lambda 是anonymous function，连名字都没有，所以

1. 你没有办法直接测试它。可以使用Stream.peek 方法；单独提出来作为一个方法测试；
2. debug 时， stack trace 给出的是一个非常模糊的名字

## Optional

1. java 努力隐藏指针，而null 是 一个hole
2. java 语言是有类型的，而null carries no type, meaning it can be assigned to any reference type，也是一个hole
3. 将一个元素 是否为null 显式的表达出来很有必要，Haskell 为此专门提供了一个maybe 的数据类型。这对设计api 很有好处。
4. **you should never forgot that the first purpose of a language,even a programming language, is communication. Optional allows you to make explicit through the type system something that otherwise would remain implicit in your knowledge of the domain model**
5. 如果业务上要求一个元素不能为空，那么这个元素不适合采用 Optional，因为这是数据问题，npe 提示下很有必要
6. Optional 可以作为参数、返回值，还可以作为成员（作为成员要看情况）。java language architect Brian Goetz clearly stated the purpose of Optional is to support the optional-return idiom only. it does not implement the serializable interface.
7. Opitonal 可以跟 Stream 一样进行map、flatMap和filter操作，以帮助你减少 if 语句。

链式使用Optional

old java code

	public String getCarInsuranceName(Person person){
		return person.getCar().getInsurance().getName();
	}

Chaining Optional

	 String name = optionalPerson
	.flatMap(Person::getCar)
	.flatMap(Car::getInsurance)
	.map(Insurance::getName)
	.orElse("Unknown")

## CompletableFuture

书中在本节开头重申了两个趋势

1. 硬件多核，所以有了fork/jion 以及 Stream 等来充分利用多核cpu
2. 线程处理的任务中，io 耗费占比越来越大。具体说，一个业务由多个step组成，这几个step 都有io操作，彼此 相关或不相关。  自然地，提高cpu 利用率就得异步化（jdk 提供了future），那么彼此依赖的任务如何异步化？ 一个完全 asynchronous application 是什么样子？如何 composing synchronous and asynchronous operations?

其它

1. Future is just a handle for a value
2. future的一个最简单 用场

		public Future<Double> getPriceAsync(String product){
			CompletableFuture<Double> futurePrice = new CompletableFuture();
			new Thead(()->{
				double price = calculatePrice(product);
				futurePrice.complete(price);
			}).start();
			return futurePrice;
		}
		
	异步api 的本质就是 delegating its remaining computation to a thread. 异步api 的时间耗费只是new 一个future 和提交下task。
	
3. 使用thenApply compose synchronous operations, thenCompose pipeline two dependent asynchronous operations, thenCombine combine two independent operations.

CompletableFutures use lambda expresstions to provide **a declarative API** that offers the possibility of easily defining a recipe that combines and composes different synchronous and asynchronous tasks to perform a complex operation in the most effective way. CompletableFuture thenApply,thenCompose, thenComposeAsync,thenCombine, thenCombineAsync 组合起来，形成一个清单， 最终被指派给一个Executor（或者默认的） 执行，这就有点BFF的味道了

## tips


1. 感觉都是组合

	对于继承，子类通过super 可以访问父类的相关方法。对于java8 interface，也是类似。从这个角度看，如果将 this、super 理解为 类成员，继承父类、实现接口，像是组合的一种特殊形态。在c++里面，子类拥有父类的数据拷贝。那么java的内存对象模型和c的内存对象模型，研究一下，做个对比，还是蛮有意思的。
	
2. 以前分析java 项目，通常会有一个复杂的类图 描述基本抽象及依赖关系。那么通过高阶函数，可以减少类的数量，依赖关系直接成了参数。因此，高阶函数 有利于 简化复杂项目类图的 层次 及 一些边缘抽象。 实现相同效果的 还有多继承。

## 小结

通过《java8 in action》 学习，我们可以知道，即便在java专家看来，java仍有很多不足之处，其设计有很多妥协和漏洞。这就坚定了笔者掌握多门语言的决心，博采众长，以避免小山村呆久了还认为世界就是 这样的 局限。