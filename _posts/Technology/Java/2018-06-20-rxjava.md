---

layout: post
title: rxjava 学习
category: 技术
tags: Java
keywords: rxjava

---

## 简介（未完成）

[RxJava系列1(简介)](https://zhuanlan.zhihu.com/p/20687178)

[RxJava2 响应式编程介绍](https://zouzhberk.github.io/rxjava-study/)

几个名词

1. 响应式编程
2. 函数响应式编程

## 响应式编程

[剖析响应式编程的本质](https://www.jianshu.com/p/3bdb8dbaa35c) 要点如下：

1. 响应式编程（Reactive Programming）到底是什么？从名词定义来讲，中文的响应式并没有很好地展现Reactive的本意
2. 传统的**顺序编程**（将顺序编程作为 响应式编程的对立面，有助于理解响应式编程）采用每条指令依次执行的方式，倘若上一条指令没有执行结束，当前的线程就得等着，任你如何提升机器性能还是代码性能，如果本质不变，始终改变不了响应需要等待的现实。若要响应迅速，就得把顺序执行指令的方式换一换——同步换成异步，方法执行换做消息发送，于是乎，我们可以精简地定义：**响应式编程就是异步数据流编程。** 
3. 这其实是一种编程范式，是编程理念的一种思想转型。因为采用响应式编程，我们就不再将软件要处理的业务视为对象，又或者函数，而是直接透析到本质：数据流（Data Stream）。一言以蔽之：万事万物皆为流 [everything is a stream](http://slides.com/robwormald/everything-is-a-stream)。这种流动差不多可以归纳为：`Command -> CommandHandler -> Event -> EventHandler -> Command ...`
4. 响应式编程 和CQRS 不谋而合，按照CQRS的设计思想，任何业务都可以分解为两种形式的消息：Query与Command。
5. 执行Command本身是要改变业务对象值的，然而，如果我们将每次变更都视为是一种“状态的迁移”，然后利用事件去记录每次变更，就可以将可变转换为不变。
6. 响应式编程的设计原则是：

	* 保持数据的不变性
	* 没有共享
	* 阻塞是有害的


 [领域驱动 + CQRS](http://qiankunli.github.io/2017/12/25/ddd.html)


## 笔者的理解

参见[领域驱动 + CQRS](http://qiankunli.github.io/2017/12/25/ddd.html) 笔者实践的一个小例子

	public class AService{
		@Autowire
		private BService b;
		@Autowire
		private CService c;
		@Autowire
		private DService d;
		public void buy(User user,String goods){
			b.xx(user, goods);
			c.xx(user, goods);
			d.xx(user, goods);
		}
	}
	
这种 代码 的难受之处就是，一旦业务发生变化，改动起来很难受（顺序流编程离不开大量的if else等控制语句）

如果按照 程序=Control + logic，那么顺序流编程 即将 控制与logic 耦合。所以后来，笔者将代码改造为

	public class AService{
		public void add(User user,String goods){
			Context.call(UserBuyListener.class,user,goods);
		}
	}
	interface UserBuyListener{
		void buy(User user,String goods);
	}
	public class BService implements UserBuyListener{
		// 指定执行顺序，可选
		@Before(C.class)
		public void buy(User user,String goods){
			xx
		}
	}
	public class CService implements UserBuyListener
	public class DService implements UserBuyListener


[深入浅出RxJava三--响应式的好处](https://blog.csdn.net/lzyzsd/article/details/44891933)

1. OnError的优势在于，异常的统一化处理，而改变的原有的四处TryCatch

2. 调度

		// 从url 下载图片，但这个操作可能很耗时
		myObservableServices.retrieveImage(url)
			// 下载操作交给 Schedulers.io 线程池
		    .subscribeOn(Schedulers.io())	
		    // 下载成功后 使用main thread 执行 订阅者逻辑
		    .observeOn(AndroidSchedulers.mainThread())
		    // 指定订阅者逻辑
		    .subscribe(bitmap -> 	myImageView.setImageBitmap(bitmap));


目前看到绝大多数的Rxjava教程都是在Android上使用的,说实话, RxJava虽然很酷, 但服务端使用RxJava的优势真心很少.Hystrix使用RxJava简洁的window API来构建metric应该算是一种不错的后端使用场景吧.主要的原因还是大多数的Java服务端还是以同步逻辑为主, 迁移成本太高了.RxJava的响应式优势只有在异步逻辑占主导时才会体现出来. 异步和同步的夹杂使用, 还不如整体使用NodeJS的异步处理协调.


若是为了充分 利用rxjava的能力，你业务代码 通常不是在驱动线程下执行的。

现在仍然没有什么直观的感受，先放一放。


## 另一个角度看rxjava

[Rxjava - 异步设计思想](https://blog.csdn.net/JohanMan/article/details/76460998)

假设一个业务逻辑

	A = callA(input);
	B = callB(A);
	C = callC(B);
	
除了顺序写，还可以

	callA(input,new Callback<A>(){
		callB(A,new Callback<B>(){
			callC(B);
		})
	})

这样写有几个好处

1. 比如log`log4j.debug(calResult())`，如果日志级别配的是info的话，其实`calResult()` 是不必执行的，但顺序调用时，就必须执行。
2. callA 本身就是异步调用

要是3层以上的异步，“迷之缩进”便会很明显，会影响我们阅读代码，必须改进。

	public interface Callback <T> {
        void onSuccess(T result);
        void onError(Exception e);
    }
    public abstract class AsyncJob <T> {
        abstract void execute(Callback<T> callback);
    }
    AsyncJob<A> callA(input){
    	return new AsyncJob<A>(){
    		void execute(Callback<A> callback){
    			inputA ==> A
    			callback.onSuccess(A)
    		}
    	}
    }
    AsyncJob<B> callB(input){
    	return new AsyncJob<B>(){
    	
    	}
    }

`AsyncJob<A>` 的execute 逻辑 = callA 原有逻辑 + callback 逻辑。这么一腾挪，callA 的工作就是 生成了一个AsyncJob 对象，没有执行原来的业务逻辑，`AsyncJob<A>.execute` 才是真正干事儿的。 但是这样解决不了 代码的缩进问题。

  	public interface Func <T, R> {
        R fun(T data);
  	}
  	public abstract class AsyncJob <T> {
        abstract void execute(Callback<T> callback);
        AsyncJob<R> map(Func<T,R> func){
        	 return new AyncJob<R>(){
        	 	  void execute(Callback<R> callback){
        	 			this.execute(new Callback<T>(){
        	 				void onSuccess(T t){
        	 					R data = func.fun(t);
        	 					callback.onSuccess(data);
        	 				}
        	 				void onError(Exception e){
        	 					callback.onError(e);
        	 				}
        	 			});
        	 	  }
        	 }
        }  
    }
    // 执行起来就是
    AsyncJob<A> asyncJobA = callA(input);
    AsyncJob<B> asyncJobB = asyncJobA.map(A => callB())
    AsyncJob<C> asyncJobC = asyncJobB.map(B => callC())
    asyncJobC.execute(new Callback(){xx});
    

callback 接口作为一个函数式接口，其作用就是将函数对象化，函数对象化的作用就是，函数虽然作为参数，但不用立即执行。上述代码所有的业务逻辑都转移到了 `asyncJobC.execute` 中。`asyncJobC.execute` 本质就是

	A = callA(input);
	B = callB(A);
	C = callC(B);
	
或者 
	
	callA(input,new Callback<A>(){
		callB(A,new Callback<B>(){
			callC(B);
		})
	})
	
但给我们的感受，要远比 起初简洁的多。尤其是加上异常处理、提前退出等逻辑的话。

所谓异步数据流，就是对一个输入源，经过步骤1，步骤2，步骤3，最终得到一个输出（这也是为什么rxjava 跟函数式编程很亲密，一个步骤用函数描述最简单了）。rxjava 通过api 让你描述了 这个过程。然后加了点私货

数据流 可以由驱动线程执行，也可以由其它线程执行， 甚至不同阶段由不同线程执行，这意味着每一个步骤 都可以 由一个线程或线程池执行。

笔者曾经处理过一个业务

1. 从hdfs中读取文件，一行为一个id
2. 根据id 查询数据库
3. 做数据分类、过滤
4. 调用rpc，为提高效率，最好批量调用
5. 因为hdfs id数量比较多，因此采用了多线程执行。

代码的演化历程

1. hdfs 读取代码，线程代码，分类、过滤代码，rpc 调用代码混在一起，最多就是分一下函数
2. 现状：`HdfsUtils.read(path,LinesListener)` id 的读取逻辑 封装在 LinesListener 中
3. 计划：改成rxjava的形式。线程与逻辑隔离，逻辑与逻辑隔离，比如等待批量 不与 rpc 调用混杂

## 与java8 stream 的区别

[Difference between Java 8 streams and RxJava observables](https://stackoverflow.com/questions/30216979/difference-between-java-8-streams-and-rxjava-observables)

1. Streams are pull-based, Observables are push-based. 假设有一个数组，求出里面所有的偶数，stream和rxjava 都可以实现。但数字 是 random 函数 或 其它函数 吐出来的，stream 就来不了了。
2. A J8 Stream is a utility to modify the collection.