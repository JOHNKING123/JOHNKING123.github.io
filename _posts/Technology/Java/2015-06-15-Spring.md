---

layout: post
title: 《Spring技术内幕》笔记
category: 技术
tags: Java
keywords: JAVA Spring

---

## 前言 ##

Spring是什么？

1. 是一个应用平台，它不像hibernate等只是解决某一个领域的问题，它对企业应用资源（比如数据库、事务处理等）都提供了简化的、模板化的操作方式。类似于os简化了我们对计算机各种硬件资源的使用。
2. 简化了J2EE开发。用户使用POJO或者简单的javabean即可实现复杂的业务需求。POJO类有一些属性及其getter setter方法的类,基本没有业务逻辑，不具有任何特殊角色和不继承或不实现任何其它Java框架的类或接口。换句话说，一个项目可以仅依靠pojo类和几个配置文件来描述。

## ioc 带来的改变：“解耦”

假设有两个类A和B

    class A{
        private B b;
        void fun(){
            xx
        }
    }

    class B{
        void fun2(){}
    }
    
在A的fun方法中，为调用b的fun2方法，需要先创建b对象，如果b对象的创建过程比较复杂（比如B还依赖其它类），`a.fun`方法将非常臃肿，并且大部分代码都有点“不务正业”，事实上，`a.fun`方法只是想单纯的运行`b.fun2()`。

按照书中的说法：许多非凡的应用都是由两个或多个类通过彼此的合作来实现业务逻辑的，这使得每个对象都需要与其合作的对象的引用（有时候这个获取过程会占用多行代码）。如果这个获取过程要靠自身实现，将导致代码高度耦合并且难以测试。

对于一个应用系统包含的多个类，每个类都有一些代码，其目的是获取其依赖对象的引用。如果，把面向对象编程中需要执行的诸如新建对象、为对象引用赋值等操作交由容器统一完成，这样一来，这些散落在不同代码中的功能相同的部分就集中成为容器的一部分，也就是成为面向对象系统的基础设施的一部分。（这样，简化了java类代码，大多数情况下，POJO类即可描述相关需求）

## ioc的实现

什么是ioc容器？

BeanFactory是最简单的ioc容器，看了BeanFactory接口方法，也许会更直观(主要包括获取bean、查询bean的特性等方法)。

    interface BeanFactory{
        FACTORY_BEAN_PREFIX
        object getBean(String)
        T getBean(String,Class<T>)
        T getBean(Class<T>)
        boolean containsBean(String)
        boolean isSingleton(String)
        boolean isPrototype(String)  
        boolean isTypeMatch(String,Class<T>)   
        class<?> getType(String)
        String[] getAliases    
    }


ioc容器对针对bean的不同（比如bean是否是单例），对bean的实例化有不同的处理，下面排除各种特例，描述下最常见的bean实例化过程。

1. ioc初始化

        BeanFactory bf = new XmlBeanFactory(new ClassPathResource("beans.xml"));
        
    - 验证并加载xml文件
    - 依次读取`<bean></bean>`（或扫描所有java类中的注解信息），并将其信息转化为BeanDefinition类（将bean信息由文本存储方式转换为内存存储（以java类的形式存在））


2. 执行`bf.getBean("beanid")`得到bean的实例

    - 根据beanid获取到相应的BeanDefinition
    - 根据BeanDefinition创建bean实例（此时还未注入属性）
    - 属性（包括其依赖对象）注入

    ioc在实例化bean的过程中，还夹了不少“私货”：

    - 在属性或依赖注入逻辑的前后留有处理函数（或回调函数）
    - 如果bean实现了一些接口，ioc将其注入该接口指定的属性
    

## AOP

来自《spring源码深度解析》：我们知道，使用面向对象编程有一些弊端，当需要为多个不具有继承关系的对象引入同一个公共行为时，例如日志、安全检测等，我们只有在每个对象里引入公共行为，这样程序中就产生了大量的重复代码，程序就不便于维护了，所以就有了一个面向对象编程的补充，即面向方面编程，AOP所关注的方向是横向的，不同于OOP的纵向。(**也就是说，AOP为面向对象范式提供了很好的补充**)

AOP中有以下基本概念：

- 基础：实现业务逻辑的方法
- 增强：为业务逻辑方法扩充的功能
- 配置：将“基础”和“增强”“连接”在一起


AOP应用了java动态代理技术（或者cglib）：基于反射在运行时生成代理类的字节码，下面是一个简单的例子：

    public class BookFacadeProxy implements InvocationHandler {  
        private Object target;  
        /** 
         * 绑定委托对象并返回一个代理类 
         * @param target 
         * @return 
         */  
        public Object bind(Object target) {  
            this.target = target;  
            //取得代理对象  
            return Proxy.newProxyInstance(target.getClass().getClassLoader(),  
                    target.getClass().getInterfaces(), this);   //要绑定接口(这是一个缺陷，cglib弥补了这一缺陷)  
        }  
      
        @Override  
        /** 
         * 调用方法 
         */  
        public Object invoke(Object proxy, Method method, Object[] args)  
                throws Throwable {  
            Object result=null;  
            System.out.println("事物开始");  
            //执行方法  
            result=method.invoke(target, args);  
            System.out.println("事物结束");  
            return result;  
        }  
    }  
    
而在上面章节提到多，ioc在实例化bean时，预留了很多回调函数。所谓的回调函数，具体到java中就是一系列BeanPostProcessor链，BeanPostProcessor包括两个方法：

Object postProcessBeforeInitialization(Object, String)   // 实例化bean前执行
Object postProcessAfterInitialization(Object, String)    // 实例化bean后执行

在postProcessAfterInitialization方法中：

    
    Object postProcessAfterInitialization(Object obj, String beanName){
        1. 根据beanName收集匹配的“增强”
        2. 判断采用何种动态代理技术
        3. 根据obj及相关“增强”获取动态代理后的实例result
        4. retrun result;
    }
    



## 其它

从另外一个角度，如果不使用spring

    class A{
        private B b = new B();
        void fun(){
            xx
        }
    }
    
java类代码和内存中对应的java实例还比较“一致”，而使用了spring之后，对于A对象在内存中的实例，其b成员可能指向一个B类的子类，而`a.fun`实际的执行逻辑可能不是我们看到的样子，甚至整个A类的字节码整个被spring换成了“代理类”的字节码。

书中的两个句子，相信对我们理解框架有很大的启示：

- 对于ioc容器（beanfactory）的使用，spring提供了许多的参数配置，每一个参数配置实际上代表了一个ioc容器的实现特性，这些特性的实现很多都需要在依赖注入的过程中或者对bean进行生命周期管理的过程中完成。

- 框架一般都会在真正的实现逻辑前后留有处理函数，（我们通过实现处理函数）提高可扩展性。

##  引用
[java动态代理（JDK和cglib）][]



[java动态代理（JDK和cglib）]: http://www.cnblogs.com/jqyp/archive/2010/08/20/1805041.html