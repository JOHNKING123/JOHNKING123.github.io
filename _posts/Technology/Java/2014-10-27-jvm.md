---
layout: post
title: JVM1——jvm小结
category: 技术
tags: Java
keywords: JAVA JVM
---

## 前言

* TOC
{:toc}

大纲

1. jvm 在java 体系中的位置
2. 类的加载
3. 类的执行
4. 类的回收

## jvm 在java 体系中的位置

![](/public/upload/java/jdk_jre_jvm.png)

jdk 安装目录含义

![](/public/upload/java/jdk_install_directory.png)

[Class Loaders in Java](https://www.baeldung.com/java-classloaders)

Class loaders are responsible for loading Java classes during runtime dynamically to the JVM (Java Virtual Machine). Also, they are part of the JRE (Java Runtime Environment). Hence, the JVM doesn’t need to know about the underlying files or file systems in order to run Java programs thanks to class loaders. 潜台词：Class loaders 是jre 类库的一部分但不是JVM 的一部分

## 类加载

与c/c++语言不同，c的二进制代码是c代码 + 库函数 编译链接的结果，实际程序进程的执行也是从`void main()`开始的。而对于java，实际的程序进程是一个jvm，该jvm加载java 代码，从`public static void main(String[] args)`开始执行。**换句话说，如果条件允许，jvm启动起来，空转都是可以的，os进程和java代码没有直接的对应关系。**

所以java有一个类加载过程，jvm把描述类的数据从Class文件加载到内存，并对数据进行校验，转化解析和初始化，最终形成可以被虚拟机直接使用的java类型，这就是虚拟机的类加载机制。

[JVM类加载器与ClassNotFoundException和NoClassDefFoundError](http://arganzheng.life/jvm-classloader-ClassNotFoundException-NoClassDefFoundError.html)在”加载“阶段，虚拟机需要完成以下三件事：

1. 通过一个类的全限定名来获取此类的二进制字节流。类似的 [maven的基本概念](http://qiankunli.github.io/2019/02/14/maven_concept.html) 中提到`URL construction scheme` 概念，根据一个jar 的groupId + artifactId + version 即可构造一个http url ，从maven remote Repository 下载jar 文件。
2. 将字节流代表的静态存储结构转换为方法区的运行时数据结构 
3. 在内存中创建一个代表此类的java.lang.Class对象，作为方法区此类的各种数据的访问入口。

![](/public/upload/java/class_load_process.png)

![](/public/upload/java/classloader_object.png)

### 类加载器的双亲委派模型

ClassLoader源码注释：The ClassLoader class uses a delegation model to search for classes and resources. 

双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都必须有自己的父类加载器，类加载器间的父子关系不会以继承关系实现，而是以组合的方式来复用父类加载的代码。

双亲委派模型的工作过程：当一个类加载器收到类加载请求的时候，它会首先把这个请求委托给父类加载器去执行，因此所有的类加载请求最终都会传送到顶层的启动类加载器中，只有当父类加载器也无法找到时才会交给自己去加载。

双亲委派模型的关键就是定义了类的加载过程，先尝试用父类加载器加载，再使用自定义加载器加载，以确保关键的类不被篡改。

使用场景：

1. 热部署
2. 代码加密
3. 类层次划分

### 延迟加载

    class X{
        static{   System.out.println("init class X..."); }
        int foo(){ return 1; }
        Y bar(){ return new Y(); }
    }

The most basic API is ClassLoader.loadClass(String name, boolean resolve)

    Class classX = classLoader.loadClass("X", resolve);

If resolve is true, it will also try to load all classes referenced by X. In this case, Y will also be loaded. If resolve is false, Y will not be loaded at this point.

### ClassNotFoundException和NoClassDefFoundError

[Why am I getting a NoClassDefFoundError in Java?](https://stackoverflow.com/questions/34413/why-am-i-getting-a-noclassdeffounderror-in-java)

1. ClassNotFoundException This exception indicates that the class was not found on the classpath.
1. NoClassDefFoundError, This is caused when there is a class file that your code depends on and it is present at compile time but not found at runtime. Look for differences in your build time and runtime classpaths. 引起的原因比较少见，还未掌握到精髓。

## JVM内存区域新画法 

我觉得《深入理解java虚拟机》，那张jvm内存区域图只是体现了内存区域的组成，我这个可能更好点：

![Alt text](/public/upload/java/jvm_memory.png)

一个cpu对应一个线程，我们从cpu的根据pc指向的指令的一次执行开始：

1. cpu执行pc指向方法区的指令
2. 指令=操作码+操作数，jvm的指令执行是基于栈的，所以需要从栈帧中的“栈”区域获取操作数，栈的操作数从栈帧中的“局部变量表”和堆中的对象实例数据得到。
3. 当在一个方法中调用新的方法时，根据栈帧中的对象引用找到对象在堆中的实例数据，进而根据对象实例数据中的方法表部分找到方法在方法区中的地址。根据方法区中的数据在当前线程私有区域创建新的栈帧，切换PC，开始新的执行。

### OOM

不同的区域存储不同性质的数据，除了程序计数器区域不会OOM外，其它的都有可能因为存储本区域数据过多而OOM。

## 垃圾收集算法

### 如何判断对象已经死亡

说白了，判断还有“引用”引用它么？

1. 引用计数法

    记录对象被引用的次数
  
2. 可达性分析算法

    以一系列GC Roots对象作为起点，从这写节点向下检索，当GC Roots到这些对象不可达时，则证明此对象是不可用的。

### 回收已死对象所占内存区域

当我们知道哪些对象可以回收时，它们分散在堆的各个地方，如何提高回收效率呢？一次回收完成后，理想状态是：内存是“整齐”的，活着的在一边，空闲的在一边。

1. 标记-清除算法

    - 实现： 第一遍，标记堆中哪些对象需要被回收；第二遍，回收被标记的对象。
    - 特点：效率不高，一次回收后，堆区碎片化

2. 复制算法

    - 实现：将区域分成两块（或多块），先紧着一块使用，这块用完后，将活着的对象复制到另一块，然后回收这一整块。
    - 特点：一部分区域会被浪费，如果对象都是“朝生夕死”的，则非常适合
3. 标记-整理算法

    - 实现：让所有活着的对象都向边界一端移动，清理端边界以外的堆区域
4. 分代收集算法

    - 实现：将堆区根据对象生存期分为几块，比如分为新生代和老年代，新生代采用“复制算法”，老年代采用“标记-清理”或“标记-整理”算法。

## 一个计算机可以运行多少线程

[并发之痛 Thread，Goroutine，Actor](http://lenix.applinzi.com/archives/2945)

1. 内存：每个线程都需要一个栈（Stack）空间来保存挂起（suspending）时的状态。Java的栈空间（64位VM）默认是1024k，不算别的内存，只是栈空间，启动1024个线程就要1G内存。虽然可以用-Xss参数控制
2. 调度成本：在个人电脑上做的一个非严格测试，模拟两个线程互相唤醒轮流挂起，线程切换成本大约6000纳秒/次。这个还没考虑栈空间大小的影响。国外一篇论文专门分析线程切换的成本，基本上得出的结论是**切换成本和栈空间使用大小直接相关**。

来一句废话就是：如果线程是一直处于运行状态，我们只需设置和CPU核数相等的线程数即可。

### 应用问题（未完成）

笔者曾写过一个框架，用户在代码中通过注解使用。注解参数包括类的全类名（用户自定义的策略类），框架通过注解拿到用户的全类名，加载类，然后调用执行。

但当框架给scala小组使用时，scala小组因使用的play框架的classloader是spring classload的子类。用户自定义策略类是scala实现的，写在用户的项目中。

框架实现主流程，其中的某个环节，load 用户自定义的策略类执行。此时，框架代码`Class.forName(class name)`去load scala class name就力不从心了。为何呀？

## jvm 那些水面下的对象

[Unsafe](http://qiankunli.github.io/2018/05/30/java_unsafe.html)


## 小结

知道垃圾回收的机理没有意义，有意义的是

1. 观察所做系统的对象生存时间，从而更改jvm垃圾收集算法配置以提高效率，这个比较高大上，一般人干不了
2. 在程序中留点心，尽量减少“无引用”对象的产生。比如，尽量不要在for循环中创建对象。