---

layout: post
title: 多线程
category: 技术
tags: Java
keywords: 多线程 JAVA

---

## 前言 

关于多线程这块，要是看书，一会儿说一个类，一会儿讲一个知识点，感觉很快就被带入细节中。所以本篇讲讲我对java多线程的一个初略理解，应该讲的都是“人话”。

## 操作系统中的线程

### 单线程

我们如何影响线程的行为呢？

1. 创建它：继承Thread，实现Runnable，实现TimerTask（现在不推荐）
2. 启动它：start
3. 暂停它：sleep
4. 停止它：
    
    a. interrupt，注意这种停止并不是抢占式的。
    
    b. 设置一个变量
        
        class thread{
            public boolean isRun = "true";
            void run(){
                 while(isRun){
                     xx
                 }
            }
            void stop(){
                isRun = false;
            }
        }
       


### 多线程

多个线程同时执行时，有以下几种可能：

1. 乱序执行

    ![Alt text](/public/upload/java/threads_wuxu.png)    
2. 协作执行（部分有序）

    - 某一部分不能被中断
 
        ![Alt text](/public/upload/java/threads_bufenyouxu.png)  
      
    - 部分有序的
  
        ![Alt text](/public/upload/java/threads_bufenyouxu2.png)  
   

3. 有序执行（执行完一个，再执行另一个）
    
    比如java的join方法

So，从乱序、部分有序、到有序执行，这是一个渐近的过程。这也从另一个侧面证明，java的多线程程序，本质上就是在线性程序上加了一些限定。这比起现在新兴的、原生支持多核和并行化的编程语言（比如Go语言），逊色不少。

### 锁与线程同步

线程的运行需要一定的资源，硬件如打印机、磁盘、数据库和显示屏等，软件如变量等数据结构（其实也是某个特定的内存资源），因为大家都在使用，所以并不能确保资源“申请即得到（这里描述为“可以访问”）”，“得到即可用（这里描述为可以使用）”。

硬件资源的分配，由操作系统提供。而软件资源的分配与协调则由开发人员通过代码主动控制。

锁与同步，本质上都是通过程序，人为的改变线程的状态（由运行改为挂起），**都是通过线程的挂起和恢复机制**：当前线程检测无法访问（或使用）时被挂起，由别的线程执行完毕后触发 恢复被挂起的线程。

1. 锁只是负责资源的独占访问，但该资源是否**语义上可用**，并不保证。比如现在没有其他线程访问资源池，消费者线程可以访问资源池，但资源池没有资源时，消费者线程也是需要等待的。因而锁的应用场景比较通用和固定，程序语言可以方便的进行抽象。比如java提供一个synchronized关键字便包装了线程申请锁，（锁被占用时挂起），锁被其他线程释放时，触发被该锁挂起的线程执行  的过程。（这个包装给我带来了很大困惑，让我误以为锁和线程同步是两个事情，其实本质是一样的）
2. 线程同步，确保了线程**在语义上**可以使用共享资源。当线程访问共享资源，检测语义不满足（标志位被占用），会被挂起，需要协作线程满足语义后，触发当前线程的继续执行。但因为应用场景多种多样，所以由开发人员手动写入线程挂起和恢复代码。

## C语言中的多线程

（看看C语言下写多线程程序什么感觉）

在引用的文章中，作者提到

1. 进程简单的说就是把一段代码复制成多份，并让他们同时执行。进程间通信是为了让他们有序的运行
2. 线程简单的说就是让多个函数同时执行，线程间通信是为了让他们有序的运行


        #include <stddef.h>
        #include <stdio.h>
        #include <unistd.h>
        #include <pthread.h>		用到了pthread库
        #include <string.h>
        void print_msg(char *ptr);
        int main(){
            pthread_t thread1, thread2;
            int i,j;
            char *msg1="do sth1\n";
            char *msg2="do sth2\n";
            pthread_create(&thread1,NULL, (void *)(&print_msg), (void *)msg1);
            pthread_create(&thread2,NULL, (void *)(&print_msg), (void *)msg2);
            sleep(1);
            return 0;
        }
        void  print_msg(char *ptr){
            int retval;
            int id=pthread_self();
            printf("Thread ID: %x\n",id);
            printf("%s",ptr);
            pthread_exit(&retval);
        }
    
从c语言中线程的代码实例和操作系统的基本原理（进程通常是执行一个命令，或者是fork），我们可以看到，线程可以简单认为，同时执行一个函数。


## java提供的多线程

1. 从代码的感觉上讲，我经常很困惑，比如

        class ThreadA extends Thread{
            public void run(){
                codeA;
                threadb.join();    //threadB.join()的意思是向threadB发送jion消息，加入到当前线程中来，完事执行codeB;
                codeB;
            }
        }
        class MyThread extends Thread{
            public void run(){
                synchronized(b){
                     xx
                     b.wait();    //此处是将当前线程挂起
                }
            }
        }

我的直观感觉是：挂起当前线程，当前线程应提供一个方法，比如wait，然后thread.wait()。而事实是通过锁对象调用wait方法来做到的，也就是通过另一个对象的操作改变了当前对象状态，我在**ThreadLocal小结**中也提到了类似的情形。原因便是：任何一个方法在执行时都可以通过Thread.currentThread()获取当前线程对象，从而通过线程对象调用线程方法对线程进行一定操作。


## java线程池

对于一个简单的java线程池

1. 线程池初始化时，即启动其管理的所有线程
2. 线程池中的线程运行逻辑：

    1. 从任务队列中取任务（取不到任务会阻塞）
    2. 执行任务
    3. 转至步骤1


**注意：**

1. 线程池中的线程跟  线程池要执行的任务（我们习惯为让任务成为一个Runnable对象，但实际上这个任务是什么类型都可以，只要它和线程池运行了任务的方法名）  运行逻辑不一样。

2. 线程池中的线程所执行的任务，不是线程池赋予的，而是线程自己“取”的


## java编写并发程序的历程

1. 使用原始的wait和notify等方法，或者使用lock和condition对象的，这些是细粒度的、基本的进程控制。其实就是在线性程序的基础上确保了线程安全，对程序员能力要求较高。
2. jkd1.5和jdk1.6提动了concurrent包，提供了执行器，高效和并发的数据容器，原子变量和多种锁，更多的封装减少了程序员自己动手写并发程序的场景。
3. jdk1.7提供ForkJoinTask支持，还未详细了解，估计类似于MapReduce，其本身就是立足于编写可并行执行程序的。
