---

layout: post
title: Thrift基本原理与使用
category: 技术
tags: Java
keywords: future

---

## 简介（待整理）

## 同步调用

thrfit调用客户端例子

    TTransport transport = new TSocket("localhost", 1234);
    TProtocol protocol = new TBinaryProtocol(transport);
    RemotePingService.Client client = new RemotePingService.Client(protocol);
    transport.open();
    client.ping(2012);
    transport.close();

TTransport ==> TIOStreamTransport ==> TSocket

TTransport 提供字节数组的read和write接口，底层可以是内存间的io，文件io，网络io可以是http，tcp，实现方式可以是netty等

    class TIOStreamTransport extends TTransport{
        protected InputStream inputStream_ = null;
        protected OutputStream outputStream_ = null;
    }

上述的TTransport的read和write接口，由inputStream和outputStream成员具体实现。

    TSocket extends TIOStreamTransport{
        private Socket socket_ = null;
        private String host_  = null;
        private int port_ = 0;
        private int socketTimeout_ = 0;
        private int connectTimeout_ = 0;
    }

初始化Socket，并为其父类的inputStream和outputStream赋值。


TProtocol ==> TBinaryProtocol

TProtocol一堆writeBool,readBool等基本数据类型的方法。



假设有以下实例

    namespace java org.lqk.thrift
    service RemotePingService{
        void ping(1: i32 length)
    }

通过thrift程序会生成RemotePingService.java，里面提供了

- RemotePingService.Iface			ping(int length)
- RemotePingService.syncIface	    ping(int length, org.apache.thrift.async.AsyncMethodCallback resultHandler)
- RemotePingService.Client
- RemotePingService.AsyncClient
- RemotePingService.Processor
- RemotePingService.AsyncProcessor

RemotePingService.Client extends org.apache.thrift.TServiceClient implements Iface

    TServiceClient{
         void sendBase(String methodName, TBase<?,?> args)
         void sendBaseOneway(String methodName, TBase<?,?> args)
         sendBase(String methodName, TBase<?,?> args, byte type)
         receiveBase(TBase<?,?> result, String methodName)
    }
    
TServiceClient提供发送数据（方法名和参数）和接收数据的一般抽象，将方法名和参数按一定的约定发出。

RemotePingService.client作为客户端关于RemotePingService的代理类，实现Iface接口，模拟出远程方法就在本地的感觉，将ping的调用转化成对sendBase和receiveBase的调用。

 	public void ping(int length) throws org.apache.thrift.TException{
      send_ping(length);
      recv_ping();
    }

    public void send_ping(int length) throws org.apache.thrift.TException{
      ping_args args = new ping_args();
      args.setLength(length);
      sendBase("ping", args);
    }

    public void recv_ping() throws org.apache.thrift.TException{
      ping_result result = new ping_result();
      receiveBase(result, "ping");
      return;
    }


从这个角度，我们可以看到，任何rpc框架的实现都逃不过以下几个基本问题：

1. 基本的网络通信，bio，nio，http，tcp，原生socket，netty等。
2. 通信数据的序列化与反序列化
3. 通信协议的制定

同步调用代码，只要耐心分析，还是比较简单的，并且是一种很有代表性的rpc基本实现，其类划分设计非常值得学习。

## 异步调用

- RemotePingService.Iface			void ping(int length)
- RemotePingService.syncIface	    void ping(int length, org.apache.thrift.async.AsyncMethodCallback resultHandler)

解释下自己理解的一个误区，异步调用方法一般要传一个callback，但对于网络调用来说，这个callback不会传到服务端，callback是负责网络io的线程在接到数据后触发执行的。

AsyncClient extends org.apache.thrift.async.TAsyncClient implements AsyncIface

通过观察TAsyncClient，一个初步结论是：异步调用，底层网络通信和和上层数据处理都要改动

    abstract class TNonblockingTransport extends TTransport{
        public abstract boolean startConnect() throws IOException;
        public abstract boolean finishConnect() throws IOException;
        public abstract SelectionKey registerSelector(Selector selector, int interests) throws IOException;
        public abstract int read(ByteBuffer buffer) throws IOException;
        public abstract int write(ByteBuffer buffer) throws IOException;
    }
    
可以看到，如果说thrift同步调用对通信模型的选择基本没有限定的话，那么thrift异步调用就只能选nio（至少nio相对其它方案是比较好的选择）。

class TNonblockingSocket extends TNonblockingTransport 基本逻辑就是初始化SocketChannel，并使用SocketChannel实现TNonblockingTransport和TTransport定义的方法


	//AsyncClient.ping
	public void ping(int length, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      ping_call method_call = new ping_call(length, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }
    //TAsyncClientManager
    public void call(TAsyncMethodCall method) throws TException {
        if (!isRunning()) {
          throw new TException("SelectThread is not running");
        }
        method.prepareMethodCall();
        pendingCalls.add(method);
        selectThread.getSelector().wakeup();
    }
    
TAsyncClientManager,Contains selector thread which transitions(过渡，转场) method call objects