---

layout: post
title: Future
category: 技术
tags: Java
keywords: future

---

## 简介


    interface Future<T>{
         boolean cancel(boolean mayInterruptIfRunning);
         boolean isCancelled();
         boolean isDone();
         V get() throws InterruptedException, ExecutionException;
         V get(long timeout, TimeUnit unit)
            throws InterruptedException, ExecutionException, TimeoutException;
    }
    
A Future represents the result of an asynchronous computation.  Methods are provided to check if the computation is complete, to wait for its completion, and to retrieve the result of the computation.  The result can only be retrieved using method get when the computation has completed, blocking if necessary until it is ready.  Cancellation is performed by the cancel method.  Additional methods are provided to determine if the task completed normally or was cancelled. Once a computation has completed, the computation cannot be cancelled.
    
《java并发编程实战》第二部分的着重讲了任务的执行和**取消与关闭**，如何启动线程我们知道，那么如何取消、关闭和拿到一个线程的结果，却没有引起足够的重视。**我们理解一个Future的关键，一个切入点就是它如何取消一个线程的执行。**

取消一个任务本质上两个方法（当然，任务已经开始或结束就无法取消了）：

1. 线程run方法里有interrupt判断，在另外一个地方拿到线程的引用thread，然后`thread.interrupt()`
2. 线程run方法在实际执行前，会判断state。那么能改变state即可。


## FutureTask

    ExecutorService executor = Executors.newFixedThreadPool();
    Future<Integer> future = executor.submit(new MyJob()));
    
Executors.newFixedThreadPool() ==> ThreadPoolExecutor ==> extends AbstractExecutorService

    public <T> Future<T> submit(Callable<T> task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture<T> ftask = newTaskFor(task);
        execute(ftask);
        return ftask;
    }
    protected <T> RunnableFuture<T> newTaskFor(Runnable runnable, T value) {
        return new FutureTask<T>(runnable, value);
    }
    
   返回的future是一个FutureTask，FutureTask是`interface RunnableFuture<V> extends Runnable, Future<V>`的实现类。
   


以FutureTask为例，future如何取消一个任务。

executor执行FutureTask，最终运行的是FutureTask的run方法，那么在FutureTask的run方法中埋一些点（加一些检测），在cancel方法中改变下状态值就可以影响run方法的执行（如果此时这个run方法被某个线程执行）。

FutureTask的特别之处是它同时拥有run和cancel方法，所以执行cancel可以影响run方法的执行。那么，如果run和cancel不在一起，其它Future的实现类如何实现cancel呢？

## guava ListenableFuture和AbstractFuture

    ListeningExecutorService executorService =             MoreExecutors.listeningDecorator(Executors.newCachedThreadPool());
    final ListenableFuture<Integer> listenableFuture = executorService.submit(new MyJob<Integer>());
    // 添加监听事件
    Futures.addCallback(listenableFuture, new FutureCallback() {
        public void onSuccess(Integer result) {
          
        }
        public void onFailure(Throwable thrown) {
          
        }
    });


ListeningExecutorService ==> AbstractListeningExecutorService ==>extends AbstractExecutorService

    public abstract class AbstractListeningExecutorService extends AbstractExecutorService{
        protected final <T> ListenableFutureTask<T> newTaskFor(Runnable runnable, T value){
            return ListenableFutureTask.create(runnable, value);
        }
        public <T> ListenableFuture<T> submit(Callable<T> task) {
            return (ListenableFuture)super.submit(task);
        }
    }
    public abstract class AbstractExecutorService implements ExecutorService{
        public <T> Future<T> submit(Callable<T> task) {
            if (task == null) throw new NullPointerException();
            RunnableFuture<T> ftask = newTaskFor(task);
            execute(ftask);
            return ftask;
        }
    }

实际执行的submit方法和上节的submit方法一样一样的，但在submit方法中，上节执行的是`AbstractExecutorService.newTaskFor`返回FutureTask，此处执行的是`AbstractListeningExecutorService.newTaskFor`返回ListenableFutureTask，其实际也是个`java.util.concurrent.FutureTask`。所以一个ListenableFuture具有cancel的能力就不奇怪了。**看来本质上，取消任务的方式还是和FutureTask一样。**

ListenableFuture所具备的addListener方法则是任务挂在一个地方，当run方法执行完毕后，执行这些任务。（不同的guava版本实现代码由很大不同）

## 可以设置结果的Future

FutureTask中，get方法和run方法共享成员变量outcome，所以run方法跑完，设置下outcome，get方法就可以拿到返回outcome。（当然，涉及到状态判断与线程安全问题）

在可以设置结果的Future中，比如netty的Promise，outcome除run方法可以设置外，还提供了set方法设置outcome（当然，涉及到状态判断与线程安全问题）。

为什么要有set？一个可能的原因是，那些监听结果的listener有了一个统一的执行位置，比如NettyPromise的实现

    public Promise<V> setSuccess(V result){
        if(setSuccess0(result)){
            notifyListeners();
            return this;
        }
        throw new ILLegalStateExeception("complete already : " + this);
    }

否则，类似notifyListeners的操作，就需要自己监听状态了。

## 小结

在很多java库提供的Future实现中，其本质是FutureTask，即既包含执行逻辑，又包含对执行逻辑的控制（获取结果和取消等）。而有些框架的Future实现中，Future只包含线程安全的设置与获取结果的方法（或者说，只是对一个Object或变量的封装，使其安全访问），并不包含执行逻辑。