---

layout: post
title: Java多线程设计模式
category: 技术
tags: Java
keywords: 多线程 JAVA

---

## 前言（未完待续）

java性能的提高，io和多线程是其中两个重要部分，io方面java实现了nio和aio，后者则有一系列的设计模式和lambda表达式的支持，相信java在以后的很长一段时间，还会继续发光发热的。

了解一些设计模式，不仅可以提高编程能力，对学习一些框架的源码也是很有帮助的。

## 线程安全

编写多线程程序时，一个逃不过的坑就是线程安全。

### 什么导致线程不安全

大学课本上的操作系统原理，只说了多线程要处理资源的争用，没有直接说下面的事

1. 重排序：编译器，为了优化所做的重排序；处理器，硬件指令重拍排序
2. 缓存：CPU各个核心虽然共用一个内存，但都有自己的缓存
3. 非原子性：比如count++，再字节码中则体现为"读取-修改-写入"。在多线程环境下，某个线程操作的值可能已经失效。

### 如何确保线程安全

1. 我们自己写代码时，尽量安全的操作共享变量。比如在Servlet类中操作实例变量时加锁。
2. 编写并使用线程安全对象。比如使用ConcurrentHashMap来替代HashMap，通过继承和组合等方式，在现有的线程安全类的基础上扩展新的类等

## 工具类

1. 同步类，比如vector等，同一个时刻只有一个线程可以操作容器数据
2. 并行类，比如ConcurrentHashMap，同一个时刻可以有多个线程操作容器数据，其本身负责线程安全。
3. 同步工具类，同步工具类都包含一些特定的结构化属性，它们封装了一些状态，这些状态将决定了执行同步工具类的线程是继续执行还是等待（即可以根据自身的状态来协调线程的控制流），此外还提供了一些方法对状态进行操作，以及另一些方法用于高效的等待同步工具类进入到预期状态。（来自《Java并行编程实战》）


## 传统方式 VS AQS

AQS，线程申请锁时，如果拿不到，不是被挂起等待，而是按一定的策略重新申请，直到申请到为止。即，线程申请不到锁时，会执行一些“无用”代码以“消磨时间”，这节省了线程被挂起和恢复的耗费。

传统的方式，有一整套的工具类，进而在编写线程安全的程序时，有一套代码模式。AQS也是如此。

## 其它

FutureTask的实现原理

## 引用

[Java多线程设计模式（一）][]

[Promise, Future 和 Callback][]

[JAVA并发设计模式学习笔记（一）—— JAVA多线程编程][]

[JAVA并发设计模式学习笔记（一）—— JAVA多线程编程]: http://www.cnblogs.com/chenying99/p/3321866.html
[Java多线程设计模式（一）]: http://www.cnblogs.com/chenying99/p/3322032.html
[Promise, Future 和 Callback]: http://isouth.org/archives/354.html