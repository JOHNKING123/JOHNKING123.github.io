---

layout: post
title: class jvm VS 可执行文件 linux
category: 技术
tags: Java
keywords: jvm

---

## 前言（未完待续）

在linux中，可执行文件没有唯一的后缀名，本文以exe统称 

class文件对应于linux中的可执行文件，jvm对应于os，两者有很多相象的地方。但毕竟机理不同，class文件和exe文件的不同正是两个os机理不同的反映。

而本质上的不同，则要追溯到java的起源：面向网络，为了让“可执行文件”在网络上传输并在不同的系统上执行，发散出很多机制。

本文以jvm为“主场”，以传统os为“客场”，在讲述jvm的过程中，对比jvm与传统os的不同。

## jvm 

学习jvm主要有以下几大块


1. class文件格式
2. class文件加载
3. jvm内存模型（内存回收）

    java区域和native区域，每个区域分为堆栈两个部分。java区域中，还有一个永久代，存储共享的，生命周期基本上跟java进程一样的数据。（永久代在有的jvm实现产品中没有）   
    
4. jvm对象模型 
5. jvm解释器（字节码指令执行）


反过来讲，类似于《程序员的自我修养》的书在阐述传统os时，也并没有“内存模型”之类的术语（只会讲述通过分段和分页来管理内存的基本原理）。以jvm如何清晰的划分来看待传统可执行文件的格式、加载和执行过程，也是非常有意义的。

## 内存模型和解释器

java是一种跨平台的编程语言，为了跨平台，jvm抽象出了一套内存模型（堆）和基于栈的解释器。（这也是本文不像其它书籍一样先从"class文件格式"讲起的原因）

1. 为了跨平台，不能假定平台特性，因此抽象出一个新的层次来屏蔽平台特性，因此推出了基于栈的解释器，与以往基于寄存器的cpu执行有所区别（笼统的说）
2. `字节码指令 = 操作码 + 操作数`,（操作数可以是立即数，可以是指向堆的引用） `传统的指令 = 操作码 + 操作数`,（操作数据可以是立即数，也可以是指向内存的引用）**此处的栈，说的是栈帧，跟传统的栈还是有不同的**，粗略的讲，我们可以说在jvm体系中，用栈取代了原来寄存器的功能。这句话的不准确在于，对于传统cpu执行，线程之间共用的寄存器，只不过在线程切换时，寄存器数据会被保存在线程私有的空间（线程数据所在内存页）中。而在jvm体系中，每个线程的栈空间是私有的，不论线程是否正在执行（因而省了切换的开销，谁让jvm内存模型属于更上一层的模型呢）。（此处描述有臆想的成分，待补充）

## 堆的管理

其实跟内存的碎片管理是一样的。程序的加载因为程序大小的不一致，导致内存分配的碎片化。对象的加载，因为对象大小的不同，导致堆的碎片化。

双方有些共同点

1. 都不按实际的大小分，程序会占用整数个页，对象占用的空间则会补齐（整字长倍）。
2. 在内存中都有“热门”和“冷门”的区别，有的对象（或程序）经常被调用，有些用过即不用了。因此大家想了不同的办法解决，传统os选择“向外扩展”，把暂时不用的扔到硬盘上。jvm选择对内区别对待，堆区域分代。
3. 程序和对象本身，都将“方法之类”的数据共享，“数据之类”的数据保存多份。

## class文件格式

因为指令中包含了操作数，可执行文件不只是指令的堆砌。

## class文件的加载

加载的本质，从磁盘上加载，得到的是一个字节数组，然后按照自己的内存模型，把字节数组中对应的数据放到对应的地方。




