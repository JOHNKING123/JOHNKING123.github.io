---

layout: post
title: spring aop 其它细节
category: 技术
tags: Java
keywords: proxyFactoryBean

---

## 简介（未完待续）

搁我以前的理解，spring aop就是对现有方法的增强。其实，“增强”是不准确的，是完全替换了原有方法的执行，只不过替换后的方法包含了原有方法的逻辑。换句话说，如果替换后的方法没有包含原有方法的逻辑，则aop完全可以“挂羊头，卖狗肉”。

比如，基于http协议的远程调用，只需声明一个InterfaceA，spring便可以通过ProxyFactoryBean返回一个代理实例，该实例方法封装了调用信息，调用http客户端（比如httpclient）发送给服务端，拿到结果后解析成InterfaceA所定义方法的返回值。整个过程中，客户端无需实现InterfaceA。

## Proxy和ProxyFactory

    public class ProxyFactory extends ProxyCreatorSupport{
        public ProxyFactory() {}
        public ProxyFactory(Object target) {}
        public ProxyFactory(Class[] proxyInterfaces) {}
        public ProxyFactory(Class proxyInterface, Interceptor interceptor) {}
        public ProxyFactory(Class proxyInterface, TargetSource targetSource) {}
        public Object getProxy() {
            return createAopProxy().getProxy();
        }
        public Object getProxy(ClassLoader classLoader) {
            return createAopProxy().getProxy(classLoader);
        }
        public static <T> T getProxy(Class<T> proxyInterface, Interceptor interceptor) {
            return (T) new ProxyFactory(proxyInterface, interceptor).getProxy();
        }
        public static <T> T getProxy(Class<T> proxyInterface, TargetSource targetSource) {
            return (T) new ProxyFactory(proxyInterface, targetSource).getProxy();
        }
        public static Object getProxy(TargetSource targetSource) {
            if (targetSource.getTargetClass() == null) {
                throw new IllegalArgumentException("Cannot create class proxy for TargetSource with null target class");
            }
            ProxyFactory proxyFactory = new ProxyFactory();
            proxyFactory.setTargetSource(targetSource);
            proxyFactory.setProxyTargetClass(true);
            return proxyFactory.getProxy();
        }
    }

## AopProxy和AopProxyFactory



