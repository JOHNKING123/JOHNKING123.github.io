---

layout: post
title: spring aop 前言
category: 技术
tags: Java
keywords: proxyFactoryBean

---

## 简介（未完待续）

搁我以前的理解，spring aop就是对现有方法的增强。其实，“增强”是不准确的，是完全替换了原有方法的执行，只不过替换后的方法包含了原有方法的逻辑。换句话说，如果替换后的方法没有包含原有方法的逻辑，则aop完全可以“挂羊头，卖狗肉”。

AOP本身较为复杂，我们先抛弃一些跟本质不太相关的东西，从最简单的例子开始。

## 从基于HTTP协议的远端调用开始说起

基于http协议的远程调用。对于客户端，只需声明一个InterfaceA，spring便可以通过ProxyFactoryBean返回一个代理实例，该实例方法封装了调用信息，调用http客户端（比如httpclient）发送给服务端，拿到结果后解析成InterfaceA所定义方法的返回值。

没有InterfaceA的实现类，`调用其接口方法 = 封装数据，发送http请求，解析响应，返回结果`。如何做到呢？FactoryBean！




    public class HttpInvokerProxyFactoryBean extends HttpInvokerClientInterceptor
    		implements FactoryBean<Object> {
    	private Object serviceProxy;
    	@Override
    	public void afterPropertiesSet() {
    		super.afterPropertiesSet();
    		if (getServiceInterface() == null) {
    			throw new IllegalArgumentException("Property 'serviceInterface' is required");
    		}
    		// 返回代理类的实例
    		this.serviceProxy = new ProxyFactory(getServiceInterface(), this).getProxy(getBeanClassLoader());
    	}
    	public Object getObject() {
    		return this.serviceProxy;
    	}
    	public Class<?> getObjectType() {
    		return getServiceInterface();
    	}
    	public boolean isSingleton() {
    		return true;
    	}
    
    }

很明显，我们有必要了解下Proxy和ProxyFactory

    public class ProxyFactory extends ProxyCreatorSupport{
        // 构造方法
        public ProxyFactory() {}
        public ProxyFactory(Object target) {}
        public ProxyFactory(Class[] proxyInterfaces) {}
        public ProxyFactory(Class proxyInterface, Interceptor interceptor) {}
        public ProxyFactory(Class proxyInterface, TargetSource targetSource) {}
        // 获取代理对象
        public Object getProxy() {
            return createAopProxy().getProxy();
        }
        public Object getProxy(ClassLoader classLoader) {
            return createAopProxy().getProxy(classLoader);
        }
        public static <T> T getProxy(Class<T> proxyInterface, Interceptor interceptor) {
            return (T) new ProxyFactory(proxyInterface, interceptor).getProxy();
        }
        public static <T> T getProxy(Class<T> proxyInterface, TargetSource targetSource) {
            return (T) new ProxyFactory(proxyInterface, targetSource).getProxy();
        }
        public static Object getProxy(TargetSource targetSource) {
            if (targetSource.getTargetClass() == null) {
                throw new IllegalArgumentException("Cannot create class proxy for TargetSource with null target class");
            }
            ProxyFactory proxyFactory = new ProxyFactory();
            proxyFactory.setTargetSource(targetSource);
            proxyFactory.setProxyTargetClass(true);
            return proxyFactory.getProxy();
        }
    }
    
观察ProxyFactory提供的方法，以`T getProxy(Class<T> proxyInterface, Interceptor interceptor)`为例，我们提供一个接口，再提供一个interceptor，就可以返回一个代理类的实例。

如果依我的意思，`T getProxy(Class<T> proxyInterface, Interceptor interceptor)`方法的实现可以这样

    public static <T> T getProxy(Class<T> proxyInterface, InvocationHandler invocationHandler) {
        return Proxy.newProxyInstance(classLoader, proxiedInterfaces, invocationHandler);
    }

然后我们传入一个InvocationHandler实例，在其invoke方法中，实现`封装数据，发送http请求，解析响应，返回结果`的逻辑。

事实上，传入interceptor实例的逻辑就是这样。然而，ProxyFactory中getProxy是依靠AopProxy实现的，ProxyFactory的功能只是AopProxyFactory这一整套模型功能的子集。针对基于HTTP协议的远程调用而言，使用InvocationHandler的invoke方法实现调用接口已经够用，但对于更复杂的需求，比如将`封装数据，发送http请求，解析响应，返回结果`分割成几个步骤，每个步骤由用户提供实现类，并且在配置文件中可配，进而“横切”业务逻辑，则需要更复杂的模型支持。

但本例已经阐述了AOP的基本流程，难点已经从AOP变成了，如何将散落在配置文件中的配置和方法，组成一个完整的执行流程，“实现”目标接口的方法。

## AopProxy和AopProxyFactory

AopProxy和AopProxyFactory的具体使用可以参照上文，AopProxy的一个关键就是获取方法对应的拦截器链，当然这个活由AdvisedSupport实现。AdvisedSupport含有用户的所有配置，将用户的配置信息加载到内存，需要一整套模型，比如Advice和PointCut。但拦截器链的基本构成Interceptor，是另一套模型。

因此我们可以将AOP划分为两个部分

1. 如何根据方法获取对应的拦截器链？拦截器链的执行逻辑就是代理方法的执行逻辑
2. 有一个接口，有一个该接口定义方法的实现逻辑（也就是拦截器链），如何将它们整合到一起。
