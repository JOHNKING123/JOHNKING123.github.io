---

layout: post
title: JVM4——《深入拆解java 虚拟机》笔记
category: 技术
tags: Java
keywords: jvm

---

## 简介

笔者之前零零散散 学习过jvm，到现在已经是第四篇文章，平时说起一些细节 都知道，却太零散，因此借着付费课程的机会串一下jvm 的相关知识点，中间夹杂一些自己的理解。

## 为什么java 要在虚拟机里运行？

1. java 作为高级语言，语法复杂，抽象程度高， 直接在硬件上运行难度大
2. 可移植性
2. 提供一个托管环境

	* 帮我们处理一些代码冗长且容易出错的部分，比如垃圾回收
	* 提供数据越界、动态类型检查等

3. 就前两点来说，go runtime 也有同样的特性。go 也独立出一个 runtime 来支持如goroutine, channel, 以及Garbage collection，但Go语言程序是编译为机器代码来执行的。[Analysis of the Go runtime scheduler](http://101.96.10.63/www.cs.columbia.edu/~aho/cs6998/reports/12-12-11_DeshpandeSponslerWeiss_GO.pdf)

	![](/public/upload/java/java_note_1.png)
	
4. java 运行时可以动态加载 磁盘或网络上的 class 文件运行，这是go runtime 所不支持的。

为什么jvm支持的指令序列称为字节码，因为其操作码被固定为一个字节。 

## java 代码是怎么运行的

[《程序员的自我修养》小结](http://qiankunli.github.io/2015/04/22/programer.html)

![](/public/upload/java/java_note_2.png)


针对以下概念

1. linux c 可执行文件格式（通常是elf）
2. class 文件格式
3. 进程 内存结构

可以肯定的是

1. 为什么会有数据段。我们知道冯诺依曼体系将指令和数据存在一起。汇编指令，调用数据就那么几种方式：立即数，寄存器，和直接寻址，间址寻址。除了立即数，就必须是数据存在在一个地方，由指令根据地址去访问，这就是为什么要有数据段。可见，所谓指令和数据存在一起，直观上大部分更像是指令和地址存在一起。
2. 指令访问 内存数据，内存地址 是 数据段地址 + 偏移 算出来的。
1. jvm 进程 或者 其它linux 进程 都秉承同一个 进程内存结构，即主体是代码段 + 数据段（其它的如文字常量区 啥的也都一样）。数据段 分为 静态数据段 + 动态数据段。 
2. 动态数据段 分为 堆和栈，为什么要分开 参见[《程序员的自我修养》小结](http://qiankunli.github.io/2015/04/22/programer.html)
3. 堆区 和 代码区 是所有线程共享的，栈区 是线程 独有的，或者说栈区 是thread safe的

jvm 进程有以下不同：

1. jvm 将栈细分为面向 java方法的java 方法栈、C++ native 方法的本地方法栈 以及 存放各个线程 执行位置的 pc 寄存器
2. 与elf 文件与 进程 内存结构 比较 简单的对应关系不同，class 文件 会被jvm加载 到 方法区中。也就是说，不准确的说，class 文件所有内容 会进入jvm 方法区。

所以，不要将jvm 内存区域 看的那么特别。比如对于堆区，jvm 中的垃圾回收，c/c++ 因为是手动回收，自然没有gc问题。但两者 都有内存碎片问题，只是jvm 在内存回收的同时顺带 做了碎片整理。c主要是 还是靠os 基于页的管理来部分解决（碎片只会在虚拟内存中产生，是不会映射到物理内存上的），部分追求性能的 可以采用程序内部的局部内存池。

      	