---

layout: post
title: java NIO
category: 技术
tags: Java
keywords: JAVA

---

## 前言 ##

我从大二开始学习Java，一直偏重于J2EE领域，写多了SSH、SSM代码之后，Java让我失去了新鲜感，以为调调接口就完事了。笔者一度开始拥抱Go语言，直到我知道“JAVA NIO”这回事，才发现，JAVA能做的有很多。并且，java慢慢的开始在多线程(java.util.concurrent)及网络领域(java.nio)提高自己的性能，老树开新花。


## IO基础

### 用户空间和内核空间

为了保证操作系统的稳定性和安全性。用户程序不可以直接访问硬件资源，如果用户程序需要访问硬件资源，必须调用操作系统提供的接口，这个调用接口的过程也就是系统调用。每一次系统调用都会存在两个内存空间之间的相互切换，通常的网络传输也是一次系统调用，通过网络传输的数据先是从内核空间接收到远程主机的数据，然后再**从内核空间复制到用户空间**，供用户程序使用。这种从内核空间到用户空间的数据复制很费时，虽然保住了程序运行的安全性和稳定性，但是牺牲了一部分的效率。

如何分配用户空间和内核空间的比例也是一个问题，是更多地分配给用户空间供用户程序使用，还是首先保住内核有足够的空间来运行。在当前的Windows 32位操作系统中，默认用户空间：内核空间的比例是1:1，而在32位Linux系统中的默认比例是3:1（3GB用户空间、1GB内核空间）（这里只是地址空间，映射到物理地址，可没有某个物理地址的内存只能存储内核态数据或用户态数据的说法）。

## linux0.11内核文件读取的过程


1. 应用程序调用系统调用read（包含文件路径等参数），进入内核态。
2. 内核根据文件路径找到对应的设备号和磁盘数据块。（磁盘的索引块事先会被加载到内存）
3. 先申请一个缓冲区块，将磁盘数据块挂到缓冲区块上（如果该缓冲区块已存在，就算了），进程挂起（直到缓冲块数据到位）。
4. 将缓冲区块挂接到一个请求项上（struct request）。（该struct描述了请求细节：将某个设备的某数据块读到内存的某个缓冲区块上）
5. 将请求项挂到该设备的请求队列上
6. 该设备处理这个请求项时，根据设备号和块设备struct（预先初始化过），找到该设备的请求项处理函数
7. 请求项处理函数取出该设备请求项队列的队首请求项，根据请求项的内容（操作什么设备，读还是写操作，操作那个部分，此处以读操作为例）给设备下达指令（将相应数据发送到指定端口），并将读盘服务程序与硬盘中断操作程序挂接。
8. 硬盘读取完毕后发生中断，硬盘中断程序除进行常规操作（将数据读出到相应寄存器端口）外，调用先前挂接到这里的读盘服务程序
9. 读盘服务程序将硬盘放在数据寄存器端口的数据复制到请求项指定的缓冲块中，并根据数据是否读取完毕（根据请求项内容判断），决定是否停止读取。
10. 如果读取完毕，唤醒因为缓冲块挂起的进程。否则，继续读取。

上述叙述主要涉及了内核态操作，并不完全妥当，但整体感觉是有了。缓冲区读取完毕后，内核随即把数据从内核空间的临时缓冲区拷贝到进程执行read()调用时指定的缓冲区。

## 文件IO

io即输入输出，输入输出的源头与目的地主要是网络和文件，我们先从比较简单的文件IO说起。

以读取文件为例：

    // FileInputStream或BufferedInputStream
    Byte[] b = new byte[1024]; // 开启1m的缓冲区
    while(in.read(b) != -1){
        Xxx
    }
    
    # nio方式
    FileInputStream fin = new FileInputStream( "readandshow.txt" );
	FileChannel fc = fin.getChannel();
    ByteBuffer buffer = ByteBuffer.allocate(1024);
    fc.read(buffer);
   

read一次读取一个字节，java先将其存入Stream中，我们再将其存到自定义"缓冲区"中（这也是为什么io操作都让我们传一个byte[],如果只读取一个byte，则将数据存到函数返回值），然后集中处理。这里，这个缓冲区是程序员约定俗成的行为。在java nio中，这个缓冲区被固定下来，数据直接被读取到缓冲区中（没有先存到Stream中这个环节）。或者说，原先的Stream是Channel和Buffer的组合，Stream的buf成员不可以直接使用，但nio的buffer可以直接拿出来使用，少了一次内存复制。


Channel用于在字节缓冲区和位于通道另一侧的实体（通常是一个文件或套接字）之间有效地传输数据。使用buffer则使read()和write()调用得到了极大的简化，因为许多工作细节都由缓冲区完成了。clear()和flip()方法用于让缓冲区在读和写之间切换。

## 网络IO

鉴于java的nio框架主要基于Reactor模式（nio中的学名叫selector），而Reactor模式又与观察者模式类似，我们先从观察者模式开始。

与Selector一起使用时，Channel必须处于非阻塞模式下。因为FileChannel不能切换到非阻塞模式，FileChannel与Selector一起使用，selector基本只用于套接字通道。

### 从观察者模式讲起

假设有一个目标对象（Objector）和一个观察者对象（Observer），Observer想要知道Objector状态，有两种办法：

1. 轮询（可以理解为pull的方式）
2. Objector状态发生变化时，主动通知Observer（可以理解为push的方式，事件源主动告知Observer）

        class Objector{
            List<Observer> observers;
            change(){
                // 变化
                // 通知观察者
                for(Observer observer : observers){
                    observer.xxxx
                }
            }
        }

我们将这个模型简单的拓展一下，假设Observer要观察两个Objector的变化（Objector1和Objector2），那么我们可以：

    class Objector1{
        List<Observer> observers;
        change(){
            // 变化1
            // 通知观察者
            for(Observer observer : observers){
                observer.xxxx
            }
        }
        change2(){
            // 变化2
            // 通知观察者
            for(Observer observer : observers){
                observer.xxxx
            }
        }
    }
    class Objector2{
        List<Observer> observers;
        change(){
            变化
            for(Observer observer : observers){
                observer.xxxx
            }
        }
    }
    
但这样没有什么扩展性，比如无法支持“change2的只有个别Observer才关心”这样的需求。

计算机里的所有问题，可以试试加个中间层解决。于是，我们将Objector1中保存观察者的容器，以及通知观察者的代码提取出来，

	class Objector1{
        中间件 middleware
        change(){
            middleware.func(变化信息)
        }
    }

    class 中间件{
        Map<感兴趣的事件，观察者列表>
        func(){
            While(true){
                查询object1和object2有没有变化
                有，就根据映射拿到观察者，调用观察者处理
            }
        }
    }

这便是Reactor模式的一个简要雏形。观察者模式与单个事件源关联，而反应器模式则与多个事件源关联。

### 监听新连接的方式

以一个web服务器为例，最简单的例子是这样的

    class SingleThreadWebServer{
        public static void main(String[] args) throws IOException{
            ServerSocket socket = new ServerSocket();
            while(true){
                Socket connection = socket.accept();//看到这个变量名，我好像明白，为什么叫"连接"池了
                handleRequest(connection);
            }
        }
    }
    
上述代码有两个阻塞的点，` socket.accept()`和`connection.read()`，很明显一个线程忙不过来，so

    class ThreadPerTaskWebServer{
        public static void main(String[] args) throws IOException{
            ServerSocket socket = new ServerSocket();
            while(true){
                final Socket connection = socket.accept();//看到这个变量名，我好像明白，为什么叫"连接"池了
                Runnable task = new Runnable(){
                	public void run(){
                    	handleRequest(connection);
                    }
                }
                new Thread(task).start();
            }
        }
    }

如果请求过多，这种方式会无限制创建线程。当然，我们可以使用Executor来执行task。但共同点都是，一个work线程处理一个connection。如果请求不是很繁忙，主线程会阻塞在`socket.accept()`上，work线程会阻塞在`connection.read()`上。

使用nio方式

    public class NIOServer{
        public static void main(String[] args) throws IOException{
            Selector selector = Selector.open();
            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
            serverSocketChannel.configureBlocking(false);
            serverSocketChannel.socket().bind(new InetSocketAddress(80));
            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
            while(true){
            	selector.select(1000);
				Set<SelectionKey> selectedKeys = selector.selectedKeys();
				Iterator<SelectionKey> it = selectedKeys.iterator();
            	SelectionKey key = null;
				while (it.hasNext()) {
                    key = it.next();
                    handleInput(key);
		 		}
            }
        }
        public static void (SelectionKey key) throws IOException{
        	if(key.isAcceptable()) {
                // Accept the new connection
                ServerSocketChannel ssc = (ServerSocketChannel) key.channel();
                SocketChannel sc = ssc.accept();
                sc.configureBlocking(false);
                // Add the new connection to the selector
                sc.register(selector, SelectionKey.OP_READ);
            } else if (key.isReadable()) {
                SocketChannel sc = (SocketChannel) key.channel();
				ByteBuffer readBuffer = ByteBuffer.allocate(1024);
                // handle buffer
            }
        }
    }

上述代码只有一个阻塞的点`selector.select(1000)`（此处用了超时机制），如果使用work线程处理readable SelectionKey，work线程不会被阻塞。除此之外，nio与传统io方式有以下不同：

1. 所有通道上的所有事件集中监听，不管是ServerSocketChannel对应SocketChannel（监听Acceptable事件）还是普通的SocketChannel（监听Readable事件），在selector看来没有区别。
2. 监听集中在`selector.select(1000)`，将分散在主线程和work线程上的等待集中到了selector上（作为一个中间层）。监听到的事件可批量处理，比如一个`selector.select(1000)`返回后得到一个Acceptable事件和两个Readable事件。

selector成为一个全面的，类似消息总线的功能。但java nio 不是万能的

1. selector会降低一些事件的响应速度。
2. 主线程（运行`selector.select(1000)`）的安全变得异常重要

## 其它

如果过多的设备与服务器进行网络通信，那么一个selector有可能把它累着，我们可以引入多个selector，这又引入了多个selector的管理问题，这就用到了mina和netty等框架。

文件的io其实和多线程通信差不多，文件读取线程读取文件，操作系统的硬盘中断处理程序等“返回”文件，这个感觉跟多线程中的生产者和消费者模式是一样一样的。

为了方便对buffer的处理，nio还提供了CharsetDecoder 和 CharsetEncoder，还提供了文件锁等功能，此处不再赘述。

## 引用

[Java NIO示例：多人网络聊天室][]

[Java NIO使用及原理分析 (四)][]

[Java NIO1：I/O模型概述](http://www.cnblogs.com/xrq730/p/5074199.html)

[NIO 入门](http://www.ibm.com/developerworks/cn/education/java/j-nio/)

[NIO学习--缓冲区](http://www.cnblogs.com/xiaoluo501395377/archive/2012/10/30/2747001.html)

[Java NIO示例：多人网络聊天室]: http://www.cnblogs.com/yanghuahui/p/3686054.html
[Java NIO使用及原理分析 (四)]: http://blog.csdn.net/wuxianglong/article/details/6612282