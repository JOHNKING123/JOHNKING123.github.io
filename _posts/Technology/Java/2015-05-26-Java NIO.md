---

layout: post
title: java NIO
category: 技术
tags: Java
keywords: JAVA

---

## 前言 ##

我从大二开始学习Java，一直偏重于J2EE领域，写多了SSH、SSM代码之后，Java让我失去了新鲜感，以为调调接口就完事了。笔者一度开始拥抱Go语言，直到我知道“JAVA NIO”这回事，才发现，JAVA能做的有很多。并且，java慢慢的开始在多线程及网络领域提高自己的性能，老树开新花。


## IO基础

### 用户空间和内核空间

为了保证操作系统的稳定性和安全性。用户程序不可以直接访问硬件资源，如果用户程序需要访问硬件资源，必须调用操作系统提供的接口，这个调用接口的过程也就是系统调用。每一次系统调用都会存在两个内存空间之间的相互切换，通常的网络传输也是一次系统调用，通过网络传输的数据先是从内核空间接收到远程主机的数据，然后再**从内核空间复制到用户空间**（这也是为什么io操作都让我们传一个byte[],如果只读取一个byte，则将数据存到函数返回值），供用户程序使用。这种从内核空间到用户控件的数据复制很费时，虽然保住了程序运行的安全性和稳定性，但是牺牲了一部分的效率。

如何分配用户空间和内核空间的比例也是一个问题，是更多地分配给用户空间供用户程序使用，还是首先保住内核有足够的空间来运行，还是要平衡一下。在当前的Windows 32位操作系统中，默认用户空间：内核空间的比例是1:1，而在32位Linux系统中的默认比例是3:1（3GB用户空间、1GB内核空间）（这里只是地址空间，映射到物理地址，可没有某个物理地址的内存只能存储内核态数据或用户态数据的说法）。

## linux0.11内核文件读取的过程


1. 应用程序调用系统调用read（包含文件路径等），进入内核态。
2. 内核根据文件路径找到对应的设备号和磁盘逻辑块。（磁盘的索引块事先会被加载到内存）
3. 先申请一个缓冲区块，将逻辑块挂到缓冲区块上（如果该缓冲区块已存在，就算了），进程挂起（直到缓冲块数据到位）。
4. 将缓冲区块挂接到一个请求项上（struct request）。（该struct描述了请求细节：将某个设备的某块读到内存的某个缓冲区块上）
5. 将请求项挂到该设备的请求队列上
6. 该设备处理这个请求项时，根据设备号和块设备struct（预先初始化过），找到该设备的请求项处理函数
7. 请求项处理函数取出该设备请求项队列的队首请求项，根据请求项的内容（操作什么设备，读还是写操作，操作那个部分，此处以读操作为例）给设备下达指令（将相应数据发送到指定端口），并将读盘服务程序与硬盘中断操作程序挂接。
8. 硬盘就绪后发生中断，硬盘中断程序除进行常规操作（将数据读出到相应寄存器端口）外，调用先前挂接到这里的读盘服务程序
9. 读盘服务程序将硬盘放在数据寄存器端口的数据复制到请求项指定的缓冲块中，并根据数据是否读取完毕（还是根据请求块），决定是否停止读取。
10. 如果读取完毕，唤醒因为缓冲块挂起的进程。如果没完毕，继续。

上述叙述主要涉及了内核态操作，并不完全妥当，但整体感觉是有了。缓冲区读取完毕后，内核随即把数据从内核空间的临时缓冲区拷贝到进程执行read()调用时指定的缓冲区。

http://www.cnblogs.com/xrq730/p/5074199.html（这个系列，我觉得讲的比较好）

http://www.ibm.com/developerworks/cn/education/java/j-nio/



## 从观察者模式讲起

鉴于java的nio框架主要基于Reactor模式，而Reactor模式又与观察者模式类似，我们先从观察者模式开始。

假设有一个目标对象（Objector）和一个观察者对象（Observer），Observer想要知道Objector状态，有两种办法：

1. 轮询（可以理解为pull的方式）
2. Objector状态发生变化时，主动通知Observer（可以理解为push的方式，事件源主动告知Observer）

        class Objector{
            List<Observer> observers;
            change(){
                // 变化
                // 通知观察者
                for(Observer observer : observers){
                    observer.xxxx
                }
            }
        }

我们将这个模型简单的拓展一下，假设Observer要观察两个Objector的变化（Objector1和Objector2），那么我们可以：

    class Objector1{
        List<Observer> observers;
        change(){
            // 变化1
            // 通知观察者
            for(Observer observer : observers){
                observer.xxxx
            }
        }
        change2(){
            // 变化2
            // 通知观察者
            for(Observer observer : observers){
                observer.xxxx
            }
        }
    }
    class Objector2{
        List<Observer> observers;
        change(){
            变化
            for(Observer observer : observers){
                observer.xxxx
            }
        }
    }
    
但这样没有什么扩展性，比如无法支持“change2的只有个别Observer才关心”这样的需求。

计算机里的所有问题，可以试试加个中间层解决。于是，我们将Objector1中保存观察者的容器，以及通知观察者的代码提取出来，

	class Objector1{
        中间件 middleware
        change(){
            middleware.func(变化信息)
        }
    }

    class 中间件{
        Map<感兴趣的事件，观察者列表>
        func(){
            While(true){
                查询object1和object2有没有变化
                有，就根据映射拿到观察者，调用观察者处理
            }
        }
    }

这便是Reactor模式的一个简要雏形。观察者模式与单个事件源关联，而反应器模式则与多个事件源关联。

## 什么是java nio（待完善）

io即输入输出，输入输出的源头与目的地主要是硬盘，网络和文件。

### Stream = Channel + Buffer

以读取文件为例：

    // FileInputStream或BufferedInputStream
    Byte[] b = new byte[1024]; // 开启1m的缓冲区
    while(in.read(b) != -1){
        Xxx
    }
   

read一次读取一个字节，java先将其存入Stream中，我们再将其存到自定义"缓冲区"中，然后集中处理。这里，这个缓冲区是程序员约定俗成的行为。在java nio中，这个缓冲区被固定下来，数据直接被读取到缓冲区中（没有先存到Stream中这个环节）。或者说，原先的Stream是Channel和Buffer的组合。

仅仅是加个缓冲区，说明不了什么，NIO 将最耗时的 I/O 操作(即填充和提取缓冲区)转移回操作系统

read()和write()调用得到了极大的简化，因为许多工作细节都由缓冲区完成了。clear()和flip()方法用于让缓冲区在读和写之间切换。

http://www.cnblogs.com/xiaoluo501395377/archive/2012/10/30/2747001.html



### 其它

我想通过这个例子告诉大家，java nio对io的读写整个换了个搞法。在传统方式中，读取文件就是file和各种InputStream和OutputStream，网络应用就是Socket和各种Stream。流还是单向的，读取写入是可能被阻塞的。到了java nio中，文件和网络操作成了各种channel（替代流，既能读还能写，且只能从缓冲区读写）在上蹿下跳。还弄了个selector（就是上面的xx类），为我们监察I/O端口，如果有内容进来，会自动通知我们，这样就不必开启多个线程死等。

## 服务器端代码实例

    public class NIOServer {
         public NIOServer(int port) throws IOException {
            // 打开服务器套接字通道
            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
            // 服务器配置为非阻塞
            serverSocketChannel.configureBlocking(false);
            // 检索与此通道关联的服务器套接字
            ServerSocket serverSocket = serverSocketChannel.socket();
            // 进行服务的绑定
            serverSocket.bind(new InetSocketAddress(port));
            // 通过open()方法找到Selector
            selector = Selector.open();        
            /* 
             * 注册到selector，等待连接
             * serverSocketChannel 和 这个key 绑定了
             * 那么当这个key对应的事件发生时，也可以通过这个key获取这个channel
             */
            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
            /*
             * 运行到这一步，其实只注册了一个SelectionKey.OP_ACCEPT（和serverSocketChannel的绑定）
             */
            System.out.println("Server Start----8888:");
        }

        private void listen() throws IOException {
            while (true) {
                selector.select();
                Set<SelectionKey> selectionKeys = selector.selectedKeys();
                Iterator<SelectionKey> iterator = selectionKeys.iterator();
                while (iterator.hasNext()) {        
                    SelectionKey selectionKey = iterator.next();
                    iterator.remove();
                    handleKey(selectionKey);
                }
            }
        }
        public static void main(String[] args) throws IOException {
            // TODO Auto-generated method stub
    
            int port = 8888;
            NIOServer server = new NIOServer(port);
            server.listen();
        }
    }

## java nio 不是万能的

1. 传统方式下，read虽然能引起阻塞，但read只要返回，必定是读了一个字节数据。而在java nio下，read可以立马返回，但缓冲区里有没有数据，可就两说了。
2. selector机制也不是一点毛病没有，可能会降低一些事件的响应速度。

## 其它

如果过多的设备与服务器进行网络通信，那么一个selector有可能把它累着，我们可以引入多个selector，这又引入了多个selector的管理问题，这就用到了mina和netty等框架。

执行io系统调用，如果数据不具备，则会有一个阻塞当前线程的过程。多线程的通信，如果某个操作依赖状态，也会有一个阻塞线程的过程。

## 引用

[Java NIO示例：多人网络聊天室][]

[Java NIO使用及原理分析 (四)][]

[Java NIO示例：多人网络聊天室]: http://www.cnblogs.com/yanghuahui/p/3686054.html
[Java NIO使用及原理分析 (四)]: http://blog.csdn.net/wuxianglong/article/details/6612282