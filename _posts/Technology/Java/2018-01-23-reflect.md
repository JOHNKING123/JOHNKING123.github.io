---

layout: post
title: java 反射
category: 技术
tags: Java
keywords: java reflect

---

## 前言

[Java深度历险（七）——Java反射与动态代理](http://www.infoq.com/cn/articles/cf-java-reflection-dynamic-proxy)

反射的几个基本作用：

1. 获取程序在运行时刻的内部结构。例如Constructor、Field和Method。ide 便运用了这一功能：每当我们敲入点号时，ide 便会根据点号前的内容，动态展示可以访问的字段或者方法。 
2. 在运行时刻对一个Java对象进行操作。
3. 处理泛型
4. 在动态代理中，执行实际的方法

使用场景：

1. 笔者曾开发一个框架，通过注解来整合执行流程。涉及到不同策略，除默认策略外，使用方可以自定义类实现特定接口，通过注解标记，由框架加载执行。
2. kafka，一些策略类依赖特定jar，使用反射加载特定jar的类，因不一定使用该策略，则kafka打默认包时无需依赖特定类。


## 反射的实现

以下来自极客时间付费课程《深入拆解java虚拟机》的笔记。

	public class Test {
	    public static void target(int i){
	        new Exception("#" + i).printStackTrace();
	    }
	    public static void main(String[] args) throws Exception {
	        Method method = Test.class.getMethod("target",int.class);
	        method.invoke(null,0);
	    }
	}

	java.lang.Exception: #0
		at com.xx.xx.Test.target(Test.java:7)
		at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
		at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
		at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
		at java.lang.reflect.Method.invoke(Method.java:498)
		at com.xx.xx.Test.main(Test.java:11)
		

从中可以看到， 	`method.invoke` 最终还是 转换为了执行 `Test.target` 方法。同时， 	`method.invoke` 和 `Test.target` 之间还隔了 

	DelegatingMethodAccessorImpl.invoke
		NativeMethodAccessorImpl.invoke
			NativeMethodAccessorImpl.invoke0

其实际执行过程中，先执行java 代码，再执行 native 代码（也就是c++代码），再执行java 代码（也就是`Test.target`），比较耗时。

扩展：Java编译器将包含本地方法的class对应的方法添加ACC_NATIVE标识，而JVM负责将动态库加载到内存，Java执行引擎执行到本地方法时找到对应的函数，完成本地方法的调用。

为提高效率，当某个反射调用的调用次数在15（默认）以上时，便开始动态生成字节码。直接使用 invoke 指令来调用目标方法。之所以使用 委派模式DelegatingMethodAccessorImpl，便是为了能够在 NativeMethodAccessorImpl 以及 动态实现 中切换。参见下列的GenerateMethodAccessor1, 其在java 代码层面是不存在的，但在字节码层面是存在的。这样 便免掉了java==>c++==> java 的代码切换。
	
	// GenerateMethodAccessor1 伪代码
	public class GenerateMethodAccessor1 extends ...{
		public Object invoke(Object obj,Object[] args)throws ...{
			Test.target((int)args[0]);
			return null;
		}
	}			


## 如何提高反射效率

反射调用的开销

1. 一些反射对象的获取比较麻烦。比如`Class.getMethod` 会遍历该类的公有方法，如果没有匹配到，它还将遍历父类的公有方法。
2. Method.getMethods, Method.getDeclaredMethods 会返回查找结果的一份儿拷贝（方法返回值都是数组）。
3. 调用本身的开销

	* Method.invoke 是一个变长参数方法，在字节码层面它的最后一个参数回事Object 数据。java 编译器会在方法调用处生成一个长度为传入参数数量的Object 数组，并将传入参数传入该数组中
	* 由于Object 数组不能存储 基本类型， java 编译器会对传入的基本类型参数进行自动装箱
	* 反射本身的委派机制
	* 每次反射调用都会检查目标方法的权限。这个检查可以在java 代码里关闭

	
整体来说，使用反射除了带来性能开销外， 还可能占用堆内存（变长参数的分配和释放等），使得gc 更加频繁。

[java面试题：如何提高反射效率？](https://segmentfault.com/q/1010000003004720)

1. 缓存得到的class/method/field/constructor对象，最好在系统启动阶段就一次性完成缓存
2. 高版本jdk
3. `setAccessible(true)` 性能提高完爆前两种

The AccessibleObject class is the base class for Field, Method and
Constructor objects.  It provides the ability to flag a reflected
object as suppressing default Java language access control checks
when it is used.  The access checks--for public, default (package)
access, protected, and private members--are performed when Fields,
Methods or Constructors are used to set or get fields, to invoke
methods, or to create and initialize new instances of classes,
respectively. 当 Field, Method和 Constructor 这些反射对象执行的时候，默认有一个access control check,哪怕是public 方法或字段，`setAccessible(true)`
用于屏蔽这种检查，因而可以极大地提高效率。

## joor 

[jOOQ/jOOR](https://github.com/jOOQ/jOOR)

### 使用

`Reflect.on("java.lang.String").create("Hello World").call("toString")`

* Wrap an Object / Class / class name with the on() method:`on("java.lang.String")`
* Invoke constructors using the create() method: `create("Hello World")`
* Invoke methods using the call() method:`call("toString")`

### 源码分析

只提供Reflect和ReflectException 两个类，核心是Reflect 类

Reflect 有两个成员，本质是对 object 的封装

1. Object   object
2. Class<?> type，object 的类型

Reflect 主要通过 `setAccessible(true)` 提高反射效率，并没有提供缓存机制。

## java 反射执行 scala类的方法（未完成）

[How can I reflectively call a method on a Scala object from Java?
](https://stackoverflow.com/questions/6529362/how-can-i-reflectively-call-a-method-on-a-scala-object-from-java)