---

layout: post
title: AQS3——论文学习
category: 技术
tags: Java
keywords: java aqs

---

## 简介（未完成）

论文地址：[The java.util.concurrent synchronizer framework](http://gee.cs.oswego.edu/dl/papers/aqs.pdf)

## introduction 部分

J2SE-1.5 introduces package java.util.concurrent, **a collection of medium-level concurrency support classes**（medium-level  的并发支持类） created via Java Community Process (JCP) Java Specification Request (JSR) 166.
 
Among these components are a set of synchronizers – abstract data type (ADT) classes that maintain an internal synchronization state (for example, representing whether a lock is locked or unlocked), operations to update and inspect that state, and at least one method that will cause a calling thread to block if the state requires it, resuming when some other thread changes the synchronization state to permit it. Examples include various forms of mutual exclusion locks, read-write locks, semaphores, barriers, futures, event indicators, and handoff queues.

abstract data type (ADT) classes 作者将同步器 描述为一个抽象的数据类型，包含几个要素

1. an internal synchronization state
2. operations to update and inspect that state （也就是release 操作）
3. at least one method that  cause a calling thread to if the state requires it, resuming when some other thread changes the synchronization state to permit it. 也即是acquire 操作，可以阻塞线程，条件允许时也会自动恢复


any synchronizer can be used to implement nearly any other.可以用一个同步器实现另一个同步器，就好像乘法可以换算为加法一样，但有几个问题

1. doing so often entails enough complexity, overhead, and inflexibility to be at best a second-rate engineering option. 比较复杂，有性能瓶颈，是一个二流的实现方案。
2. it is conceptually unattractive. If none of these constructs are intrinsically（本质的） more primitive than the others。 developers should not be compelled to arbitrarily choose one of them as a basis for building others. 所有同步器 都属于同一个抽象层次，以一个为基础实现另一个不科学。

因此，提出了一个AQS，提供了大部分同步器都会用到的基础特性， 比同步器more primitive

## 实现同步器要考虑的几个问题

### 实现什么

同步器有两类（注意不是两个）方法：acquire和release，但java 没有定义类似`interface Synchronizer` 的接口，因此acquire 和 release 就衍生出诸多称谓：

1. Lock.lock
2. Semaphore.acquire
3. CountDownLatch.await
4. FutureTask.get **这次我第一次看到将Future 与 同步器串联起来**

并且acquire 还有tryAcquire非阻塞版本、支持timeout版本、 Cancellability via interruption

同时，synchronizer 维护的state 还有 是否 exclusive的划分，即同时时刻是否允许多个线程通过

### 性能目标

1. 公平性和aggregate throughput 的矛盾。

	* 一个线程，占用了资源，但多久之后释放是不知道的，排队是公平的。对于连接池这类场景来说，公平性很重要。。但业务中若是大部分线程占用的时间短，少部分线程占用的时间长，则排队会影响线程通过的吞吐量
	* 新的线程进来，总是先测试下state，不符合条件时才加入队列。此时，在高并发情况下，当state 可用时，实际上是新加入线程和队列头节点在竞争。按等待时间来说，这是不公平的，并且容易导致队列尾部的线程饥饿。
2. 在cpu time requirements,memory traffic,thread scheduling 之间取得平衡.比如自旋锁，获取锁的速度倒是快，但是浪费cpu cycle，导致大量的**memory contention**，所以大部分时候不适用。

## 设计

synchronizer requires the coordination of three basic components:

* Atomically managing synchronization state
* Blocking and unblocking threads
* Maintaining queues

It might be possible to create a framework that allows each of these three pieces to vary independently。 当然，彼此独立是不合适的。但这段话反映了一个很好的设计思路：

1. 将同步器接口 acquire和release 具体为几个实际组件
2. 组件之前可以各自抽象，彼此独立。（当然，AQS中没有这样做）

Concrete classes based on AbstractQueuedSynchronizer must define methods tryAcquire and tryRelease in terms of these exported state methods in order to control the acquire and release operations.

