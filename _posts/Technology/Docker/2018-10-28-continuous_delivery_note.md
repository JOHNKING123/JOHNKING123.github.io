---

layout: post
title: 《持续交付36讲》笔记
category: 技术
tags: Docker
keywords: 持续交付

---

## 简介

本文来自极客时间《持续交付36讲》教程，收获很大，除了一些具体的技术，更重要的是一套成体系的理念：即为什么要这么做？每一个小的优化在整体研发效率优化中的位置、作用及意义。

* TOC
{:toc}

## 持续交付的“三观”

组织、团队、工具

1. 持续交付必须以平台化的思想去看待，单点突破是无力的
2. 持续交付的实施，也要顺应技术的变迁，善于利用技术红利
3. 持续交付与系统架构、运维体系息息相关，已经不分彼此

个人再强，放在一个低效的环境下，也无力可施

持续交付是软件研发人员，如何将一个好点子，以最快的速度交付给用户的方法。

标准、规范、流程的落地，都需要载体，而最好的载体就是平台工具

持续交付体系也如同中间件一样，能够从日常的业务研发工作中抽象出来，其不同只在于中间件解决架构问题，而持续交付解决工程问题。这样研发团队能够全力应付业务的需求，而不用总是重复奔波于一些烦人且耗时的工程问题，比如安装测试机、准备编译服务器等等。

学习一下持续交付的内容，它能让你看到更多与编码有关的其他东西，比如不同的编码方式等；也能让你站在更高的角度去看待自己的工作：研发效率的提高往往不是个人能力的提高，而是集体协同效率的提高。


![](/public/upload/docker/continuous_delivery_36_note_1.JPG)

虽然持续交付着重打造的是发布流水线的部分，但它所要达到的目标是在“最终用户”和“研发团队”之间建立紧密的反馈环：通过持续交付新的软件版本，以验证新想法和软件改动的正确性，并衡量这些改动对软件价值的影响。 这里说的“软件价值”，说白了就是收入、日活、GMV 等 KPI 指标了。在保证交付质量的前提下，加快交付速度，从而更快地得到市场反馈，引领产品的方向，最终达到扩大收益的目的。

![](/public/upload/docker/continuous_delivery_36_xmind.png)

## 和devops 的关系

1. DevOps 的本质其实是一种鼓励协作的研发文化
2. 持续交付与 DevOps 所追求的最终目标是一致的，即快速向用户交付高质量的软件产品；
3. DevOps 的概念比持续交付更宽泛，是持续交付的继续延伸；
4. 持续交付更专注于技术与实践，是 DevOps 的工具及技术实现


## 代码分支策略，一切的源头

不同的代码分支策略，意味着实施不同的代码集成与上线流程，这会影响整个研发团队每日的协作方式

1. 主干开发

	* 特征切换在本质上是条件语句中使用的变量，切换为关的代码块类似于被注释的代码，主要用途是避免在发布前的最后一刻因软件合并而产生的冲突。
	* 特性切换需要健壮的工程过程、可靠的技术设计和成熟的特性切换生命周期管理，如果不具备这些能力反而误事。
2. 特性分支开发

	* 包括git flow、github flow、gitlab flow
	* 特点：极端情况下，对代码的任何修改，包括 Bug 修复、热修复、新功能开发等都在单独的分支中进行。具体的分支策略做出一定的简化。

作者有一个周一到周五的最佳协作案例，可以学习一下。

## 依赖管理

操作系统级，centos的yum、macos的homebrew等
编程语言的依赖管理工具，比如 Java 的 Maven，Golang 的 go get，Python 的 pip

这些平台的解决思路都是将依赖放到共同的仓库，然后管理工具通过依赖描述文件去中央仓库获取相应的包。

Maven 最佳实践

1. 生产环境尽量不使用 SNAPSHOT 或者是带有范围的依赖版本
2. 将 POM 分成多个层次的继承关系，比如定义公司级的pom.xml（super-pom）、部门级的pom.xml、项目级别的pom.xml,每个项目必须直接或间接的继承super-pom

## 测试环境治理

### 分类及什么是好的环境

||使用者||
|---|---|---|
|开发环境|开发||
|功能测试环境|开发、测试||
|验收测试环境|产品、测试||
|预发布环境|测试||
|生产环境|用户||


当一个环境可以满足其真正核心用户的需求时, 就是一个好用的测试环境。

1. 开发关注效率
2. 测试关注可靠性
3. 产品关注真实的用户体验和产品完整性
4. 预发布环境的需求其实来自于运维同学，他们需要保证生产环境的稳性，减少生产环境的变更，所以需要将预发布环境与线下环境完全隔离（PS：用真实的环境帮助发现错误）。


容器技术已经解决了很多问题。比如，服务器操作系统级别的依赖的标准化更容易了；当出现硬件故障时，迁移和恢复服务也更加方便了。但容器/云计算不是银弹，比如容器技术并没有解决故障定位的问题。

### 环境配置

#### 什么是环境配置

环境配置，此配置非彼匹配，配置是环境管理中最核心的内容，包括：

1. 以环境中每台服务器为对象的运行时配置，以一个 Java Web 应用为例，需要哪些运行时配置呢？

	* 安装 war 包运行依赖的基础环境，比如 JDK，Tomcat等
	* 修改 Tomcat 的配置文件
	* 配置 Jvm 参数
	* 考虑操作系统参数，比较常见的一个配置是 Linux 的文件句柄数

	
2. 以一个环境为整体目标的独立环境配置。

	* 这个环境所依赖的数据库、缓存该如何配置
	* 如果是微服务架构，就需要考虑微服务治理框架、配置中心等一系列中间件的配置问题。
	* 环境对应的基础服务，比如监控，短信，搜索等。


#### 环境配置理念

1. 环境一定要标准化。解决复杂问题的办法：分拆、简化、标准化
2. 约定大于配置
3. 让环境自己能开口说话，通过环境的自描述文件，让环境能讲清楚自己的作用、依赖，以及状态，而不是由外部配置来解释这些内容。PS：比如部署文件是写在项目里（告诉调度胸系统，要如何部署这个项目），还是由用户额外配置？

	* 服务器生成时，写入它自己的描述文件。我们通常把这个文件命名为“Server Spec”。在这个文件里，记录了这台服务器的所有身份信息，包括：IDC，型号，归属环境，作用，所属应用，服务类型，访问路径等。**PS，这个是一个新鲜的搞法，每个容器可以搞一个Container.Spec，你在新建一个容器时，可以向容器写入一个Container.Spec，告知所属的环境，作为各个中间件的约定信息源**
	* 中间件根据 Server Spec 的描述，寻找到它所在环境对应的配置中心。
	* 完成服务自发现，根据服务类型，访问路径等，还可以自动生成对应的路由配置，负载均衡配置等。我们是在尝试把环境配置的方向调个个儿：由原来外部通过配置告知环境应该干什么，转变成环境根据自身的能力和属性，决定自己应该去干什么。PS：以前负载均衡配置都是外部软件监控调度系统写入负载均衡组件，外部做和自描述，得好好体味一下，**感觉可以做个调度系统框架嵌在项目中来完成这些事儿**。另外，google jib 也有点这个意思，根据代码做镜像，而不是将代码无差别的打成war做镜像。

#### 环境配置方法

1. 构建时配置，比如maven的profile。问题，改配置就要重新构建一次。
2. 打包时配置，以java 为例，作者应该指的是生成class 之后不要立即打成war，而是延迟到发布时。为什么要从构建独立分离出打包这个步骤呢？为了一次构建，多次部署。打包时配置的基本思想是：构建时完全不清楚程序所要部署的环境，因此可根据环境信息，进行相关配置的替换。具体可参见作者举的内部工具的例子。
3. 运行时配置

	* 修改后实时生效
	* 支持灰度发布
	* 能分环境、分集群管理配置；
	* 有完善的权限、审核机制。

	特有问题：配置不会随着代码回滚。

#### 环境创建、拆分与合并



1. 环境创建，就是不断提高虚拟机准备和应用部署两个流水线的速度和稳定性

	* 环境构建流水线
	* 应用部署流水线
2. 环境拆分，当有新项目时，开发人员会挑选部分应用，组成一个独立的子环境。这里的重点是，要保证子环境和完整环境的调用是互相隔离的。
3. 环境合并，当存在多个子环境时，可能在某个时间点需要做多个项目的集成，这时开发人员需要合并多个环境。需要注意合并后的环境冲突，一般将这些冲突罗列出来，交由用户选择决策。

环境的创建和拆分，最主要的问题就是如何复制和重新配置环境中的各个零件。此外要处理：

1. 用户访问应用的入口管理
2. 应用之间调用链的管理
3. 对数据库的访问

	* 数据库连接串的维护问题，与 SOA 调用链（即服务之间的调用关系）的维护类似
	* 二是，数据库的快速创建策略。提供基准库和数据库脚本变更接口，创建环境时根据基准库执行变更接口

## 其它（未完成）

Jenkins主要用作异步任务驱动，携程只有编译系统使用Jenkins


![](/public/upload/docker/continuous_delivery_36_post.JPG)

个人微信订阅号

![](/public/upload/qrcode_for_gh.jpg)