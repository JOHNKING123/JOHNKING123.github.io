---

layout: post
title: 纯java项目的公司是否要用docker
category: 技术
tags: Docker
keywords: Docker,jvm

---

## 前言

docker的宗旨是：an open platform to build, ship, and run any app, anywhere。而java也说自己：一次编写，处处运行。

对比docker的隔离性，jvm也可以约束自己需要的资源。当然，有些隔离性jvm做不到，但我们貌似也不是特别需要。

c项目对一些环境有苛刻要求，但对于java项目，为什么一定要用docker呢？

我首先想到的是扩容缩容。但仔细想想，依托现有架构，扩容缩容也不是做不到，提高扩容缩容的速度也不是很困难。

对于一个以java项目为主的公司，使用docker的意义何在？


## devops

从devops的角度看，面对一大堆物理机资源，我们想自动化，自动化的前提是规范化。比如，我们要为一个tomcat分配端口，以前是随便分配，现在要根据一定的规则来分配。

从整个devops的生命周期来说，要规范化的东西很多，docker在运行环境这块打包了一下，省去了很多工作。但即便不用docker，我们仍然可以做到代码打包完毕后，部署到线上运行。

不过docker可以更进一步，你可以在项目的约定位置新增一个文件（对于k8s或mesos来说，文件名有所不同），说明该项目应该有几个实例，依赖了什么服务（如果有可能，最好将它们部署在一起），而不是在打包好后，转入一个网页进行一系列的配置。对于运维人员来说，他的工作从帮你配置变成了维护整个系统的正常运行。

即便如此，到现在为止，我们依然可以优化原来的运维系统，实现我们想要的自动化。

说到底，devops不是有了docker才有的，也就谈不上没有docker就做不到的问题。

## 粒度

但是，对于可移植性和隔离性，docker的可移植性是os级别的，给个linux环境就可以。正因为如此，container可以在os之间自由的、轻便的“漂移”。而jvm提供的可移植性只是代码的运行本身，并不包含代码的运行环境。这就意味着，代码要搬家，除了移动代码本身，还要移动或适配代码的运行环境。比如，rm container和rmi image，你就可以抹掉项目在os上的一切痕迹（特殊配置除外）。run image就可以给代码安个新家。而对于传统方式（比如将web项目部署到tomcat上）首先要记录项目与tomcat的位置映射，然后stop tomcat、rm tomcat dir。在新的os上，create tomcat dir,config tomcat。看起来，就麻烦多了。

所以，使用docker之后，我们并不是在做以前做不到的事，但能更简单的做以前的事。

