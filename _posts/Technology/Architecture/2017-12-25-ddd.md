---

layout: post
title: ddd(一)——领域驱动理念入门
category: 技术
tags: Architecture
keywords: ddd

---

## 简介


2018.6.20 补充 [大家一直在谈的领域驱动设计（DDD），我们在互联网业务系统是这么实践的](https://mp.weixin.qq.com/s/jMWuMuIvI1cFThC-WQGbHQ?utm_medium=hao.caibaojian.com&utm_source=hao.caibaojian.com) 本文字字珠玑，适合细读。

## 用java 写面向过程式代码

**在我们习惯了J2EE的开发模式后，Action/Service/DAO这种分层模式，会很自然地写出过程式代码**，而学到的很多关于OO理论的也毫无用武之地。使用这种开发方式，对象只是数据的载体，没有行为。以数据为中心，**以数据库ER设计作驱动。** PS，对这句深有体会，此时一个系统最有含量的部分就是数据库设计，数据库表定了，剩下的就是腾挪数据了。

分层架构在这种开发模式下，可以理解为是对数据移动、处理和实现的过程。

	public class User{
		private Long id;
		private String name;
		private int age;
		// 看着有方法，其实只是一个数据类
		public void setId(Long id){
			this.id = id;
		}
		...
	}

业务逻辑都是写在Service中，domain充其量只是个数据载体，没有任何行为。简单的业务系统采用这种过程化设计是没有问题的，但在业务逻辑复杂了，业务逻辑、状态会散落到在大量方法中，原本的代码意图会渐渐不明确。

久而久之，看到需求，直接就想到数据库表如何设计，页面也慢慢做成了crud的模样。

[阿里盒马领域驱动设计实践](http://www.infoq.com/cn/articles/alibaba-freshhema-ddd-practice) 形容这类代码“面条代码”，从（客户）端上一条线杀到数据库完成一个操作，仅有的一些设计集中在数据库上。

## 领域驱动的由来——业务分治

解决复杂和大规模软件的武器可以被粗略地归为三类：抽象、分治和知识。

1. 分治 **把问题空间分割为规模更小且易于处理的若干子问题**。分割后的问题需要足够小，以便一个人单枪匹马就能够解决他们；其次，必须考虑如何将分割后的各个部分装配为整体。分割得越合理越易于理解，在装配成整体时，所需跟踪的细节也就越少。
2. 抽象 **使用抽象能够精简问题空间**，而且问题越小越容易理解。举个例子，从北京到上海出差，可以先理解为使用交通工具前往，但不需要一开始就想清楚到底是高铁还是飞机，以及乘坐他们需要注意什么。
3. 知识 顾名思义，DDD可以认为是知识的一种。DDD提供了这样的知识手段，让我们知道如何抽象出限界上下文以及如何去分治。

**在系统复杂之后，我们都需要用分治来拆解问题。一般有两种方式，技术维度和业务维度。**技术维度是类似MVC这样，业务维度则是指按业务领域来划分系统。**微服务架构更强调从业务维度去做分治来应对系统复杂度**，而DDD也是同样的着重业务视角。

我们将架构设计活动精简为以下三个层面：

1. 业务架构——根据业务需求设计业务模块及其关系
2. 系统架构——设计系统和子系统的模块
3. 技术架构——决定采用的技术及框架

DDD的核心诉求就是将业务架构映射到系统架构上，**在响应业务变化调整业务架构时，也随之变化系统架构**。

[DDD领域驱动设计基本理论知识总结](http://www.cnblogs.com/netfocus/archive/2011/10/10/2204949.html)

[浅谈我对DDD领域驱动设计的理解](https://www.cnblogs.com/netfocus/p/5548025.html)

1. 很多项目（尤其是互联网项目，为了赶工）都是一开始模型没想清楚，一上来就开始建表写代码，代码写的非常冗余，完全是过程式的思考方式，最后导致系统非常难以维护。


## ddd的基本理论

[阿里盒马领域驱动设计实践](http://www.infoq.com/cn/articles/alibaba-freshhema-ddd-practice)

1. 传统项目中，架构师交给开发的一般是一本厚厚的概要设计文档，里面除了密密麻麻的文字就是分好了域的数据库表设计。言下之意：**数据库设计是根本**，一切开发围绕着这本数据字典展开
2. 我经常会做一个假设：假设你的机器内存无限大，永远不宕机，在这个前提下，我们是不需要持久化数据的，也就是我们可以不需要数据库，那么你将会怎么设计你的软件？这就是我们说的 Persistence Ignorance：持久化无关设计。首先一点，领域模型无法通过数据库表来表示了，就要基于程序本身来设计了。
3. 按照 object domain 的思路，领域模型存在于内存对象里，**意味着得 通过 类图 而不是ER图来描述业务**。用类 比用 数据库表 有更丰富的表达方式：通过引用来表达多对多关系、封装、继承和多态等。

对于第三点，笔者最近项目碰到一个例子。要实现一个弹屏管理系统，弹屏可能有多重类型：图片、h5、视频等，那么关于每种弹屏类型的存储

1. 以数据库表来描述，则借助电商系统方案

	* 弹屏表 包括 所有弹屏类型的所有属性
	* 每一种弹屏类型建一个表
	* 弹屏表包括type 和 data 字段，弹屏数据 json序列化后 存在data 中，以type标记弹屏类型，供代码判断如何处理data

	很明显，第三种方案好一些，但显然不论哪种方案，系统中要有很多工具类

2. 以类图来表述，就是一个弹屏父类 与 各个子类的继承关系，数据表采用 上诉那种方式无所谓。此时，按数据表 构造 具体的弹屏类是很自然的，且构造具体弹屏类的代码 自然地放在 弹屏类中。

### 领域模型设计：基于数据库 vs 基于对象

基于数据库设计

![](/public/upload/architecture/ddd_data_model.png)

将表现 领域模型的 层次 提升至 domain 层

![](/public/upload/architecture/ddd_object_model.png)

领域模型是用于领域操作的，当然也可以用于查询（read），不过这个查询是有代价的。在这个前提下，一个 aggregate 可能内含了若干数据，这些数据除了类似于 getById 这种方式，不适用多样化查询（query），领域驱动设计也不是为多样化查询设计的。
查询是基于数据库的(比如 获取某数据的列表，这是一个查询需求，不算业务模型之内。业务模型一般侧重于 几个抽象 以及 抽象之间的相互作用)，所有的复杂变态查询其实都应该绕过 Domain 层，直接与数据库打交道。

![](/public/upload/architecture/ddd_object_model_2.png)

### 领域模型：失血、贫血、充血

假设有父亲和儿子两个表

1. 失血模型

		public class Father{…}
		public class Son{
    		private String fatherId;//son 表里有 fatherId 作为 Father 表 id 外键
    		public String getFatherId(){
        		return fatherId;
    		}
    		……
		}
		
	如果 父亲想教训一下儿子，Father 类是干不了的，得有一个XXService 或 XXManager 来代劳。

2. 贫血模型

		public class Father{
	    	private Son son;
	    	private Son getSon(){return this.son;}
		}		
    父亲不知道自己的儿子是谁是不对的，不能每次都通过中间机构（Manager）验 DNA(son.fatherId) 来找爸爸
		
3. 充血模型

		public class Father{
		    //private Son son; 删除这个引用
		    private SonRepository sonRepo;// 添加一个 Son 的 repo
		    private getSon(){return sonRepo.getByFatherId(this.id);}
	 	}
	 	
	充血模型的存在让 domain object 失去了血统的纯正性，他不再是一个纯的内存对象，这个对象里埋藏了一个对数据库的操作。

## 小结

一般表述 领域驱动的文章，都是各种 domain 图等等，若没有一定的实践背景，读者往往无法进入状态。

其实简单点讲，就是传统方式 本质为 以数据库表来描述 业务模型，而领域驱动 以 类图（类及相互作用关系）来描述业务模型。明显的，表达手段越多（类图丰富的表达手段，比如继承、多态等） ，便越容易 描述复杂事物，也更容易应对变化。


