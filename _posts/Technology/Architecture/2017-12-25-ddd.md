---

layout: post
title: 领域驱动 + CQRS
category: 技术
tags: Architecture
keywords: fileupload

---

## 简介


[大家一直在谈的领域驱动设计（DDD），我们在互联网业务系统是这么实践的](https://mp.weixin.qq.com/s/jMWuMuIvI1cFThC-WQGbHQ?utm_medium=hao.caibaojian.com&utm_source=hao.caibaojian.com) 2018.6.20 补充，本文字字珠玑，适合细读。

**在我们习惯了J2EE的开发模式后，Action/Service/DAO这种分层模式，会很自然地写出过程式代码**，而学到的很多关于OO理论的也毫无用武之地。使用这种开发方式，对象只是数据的载体，没有行为。以数据为中心，以数据库ER设计作驱动。分层架构在这种开发模式下，可以理解为是对数据移动、处理和实现的过程。

	public class User{
		private Long id;
		private String name;
		private int age;
		// 看着有方法，其实只是一个数据类
		public void setId(Long id){
			this.id = id;
		}
		...
	}

业务逻辑都是写在Service中，domain充其量只是个数据载体，没有任何行为。简单的业务系统采用这种过程化设计是没有问题的，但在业务逻辑复杂了，业务逻辑、状态会散落到在大量方法中，原本的代码意图会渐渐不明确。

久而久之，看到需求，直接就想到数据库表如何设计，页面也慢慢做成了crud的模样。

解决复杂和大规模软件的武器可以被粗略地归为三类：抽象、分治和知识。

1. 分治 **把问题空间分割为规模更小且易于处理的若干子问题**。分割后的问题需要足够小，以便一个人单枪匹马就能够解决他们；其次，必须考虑如何将分割后的各个部分装配为整体。分割得越合理越易于理解，在装配成整体时，所需跟踪的细节也就越少。
2. 抽象 **使用抽象能够精简问题空间**，而且问题越小越容易理解。举个例子，从北京到上海出差，可以先理解为使用交通工具前往，但不需要一开始就想清楚到底是高铁还是飞机，以及乘坐他们需要注意什么。
3. 知识 顾名思义，DDD可以认为是知识的一种。DDD提供了这样的知识手段，让我们知道如何抽象出限界上下文以及如何去分治。

**在系统复杂之后，我们都需要用分治来拆解问题。一般有两种方式，技术维度和业务维度。**技术维度是类似MVC这样，业务维度则是指按业务领域来划分系统。**微服务架构更强调从业务维度去做分治来应对系统复杂度**，而DDD也是同样的着重业务视角。

我们将架构设计活动精简为以下三个层面：

1. 业务架构——根据业务需求设计业务模块及其关系
2. 系统架构——设计系统和子系统的模块
3. 技术架构——决定采用的技术及框架

DDD的核心诉求就是将业务架构映射到系统架构上，**在响应业务变化调整业务架构时，也随之变化系统架构**。

[DDD领域驱动设计基本理论知识总结](http://www.cnblogs.com/netfocus/archive/2011/10/10/2204949.html)

[浅谈我对DDD领域驱动设计的理解](https://www.cnblogs.com/netfocus/p/5548025.html)

1. 很多项目（尤其是互联网项目，为了赶工）都是一开始模型没想清楚，一上来就开始建表写代码，代码写的非常冗余，完全是过程是的思考方式，最后导致系统非常难以维护。

ddd领域驱动一般与cqrs架构结合在一起，[谈一下关于CQRS架构如何实现高性能](http://www.cnblogs.com/netfocus/p/4055346.html)。本文直接从一个实现框架入手，通过阅读代码阐述ddd及cqrs的一些理念。


## 笔者实践

或许直接说ddd对笔者不是一个很容易接收的理念，反而“发布者发布事件，监听者监听事件”这种完成框架的方式，更容易理解。

笔者曾经尝试将一个业务逻辑改造为发布订阅模型，原来的代码是：

	public class AService{
		@Autowire
		private BService b;
		@Autowire
		private CService c;
		@Autowire
		private DService d;
		public void buy(User user,String goods){
			b.xx(user, goods);
			c.xx(user, goods);
			d.xx(user, goods);
		}
	}
	
这种 代码 的难受之处就是，一旦业务发生变化，改动起来很难受（顺序流编程离不开大量的if else等控制语句）。改造后代码

	public class AService{
		public void add(User user,String goods){
			Context.call(UserBuyListener.class,user,goods);
		}
	}
	interface UserBuyListener{
		void buy(User user,String goods);
	}
	public class BService implements UserBuyListener{
		// 指定执行顺序，可选
		@Before(C.class)
		public void buy(User user,String goods){
			xx
		}
	}
	public class CService implements UserBuyListener
	public class DService implements UserBuyListener

改造完毕后

1. 发现AService不需要成员bcd，自然bcd也不需要提供那么多接口方法供AService 在不同场景下调用。
2. 那么abcd 硕果仅存的、不能被砍掉的那几个public 方法，刚好反映了a bcd 各自的领域。
3. bcd监听事件，ifelse 写在各自的类中，自由选择处理、不处理事件，或者直接中断处理流程。

再进一步

	class Controller{
		public String buy(long uid,String goods){
			User user = xx.queryById(uid);
			user.buy(goods);
		}
	}

代码逻辑将更清晰。以这个为思维起点：

1. 主逻辑分散在 各个 eventhandler 中，整合的时候可以玩点花活儿，比如部分业务event handler异步执行。异步执行本质是将事件包装成任务，交给引擎执行。此时，合并请求、降低资源争用等方面又可以玩一点花活儿。
2. 其整体的执行要符合事务一致性的要求或配置。
3. 业务是由发布事件+执行eventHandler串起来的，那么由谁发布事件，发布什么事件，这需要对业务进行仔细的梳理，这就是领域划分问题了。

从数据对象的角度看，ddd中 User对象不会只有一个，而是包括

1. DTO，信息传输对象,完成与外界的数据交互 
2. DO，领域对象
3. PO，数据库持久化对象

## 实现框架

1. [changmingxie/aggregate-framework](https://github.com/changmingxie/aggregate-framework)
2. [banq/jdon framework](https://github.com/banq/jdonframework)

aggregate-framework 主要由公司大牛实现，所以通过分析它的源码来深入理解ddd和cqrs

领域驱动思想的 跟响应式编程 也有异曲同工之妙，[剖析响应式编程的本质](https://www.jianshu.com/p/3bdb8dbaa35c)。将顺序式的命令编程 改为 事件/数据流。

### 示例使用

假设订单PricedOrder 有place和confirm 两个行为，其后续处理都是通过PricedOrder.apply(xxEvent)来进行的，dao类负责crud（这个没变）。service 只是负责 操作dao类以及（直接或间接）PricedOrder.apply(xxEvent) 方法。

1. 订单的创建，触发了支付过程
2. 支付过程


model 只是apply，剩下的交给eventHandler来做。那么handler之间如何编组，如何揉和成一个统一的关系。

猜测，复杂的业务逻辑通过event 的形式交给后续处理。

问题来了

1. 后续处理是同步还是异步进行
2. 一致性如何保证
3. 业务处理如何接入
4. 整个工作流程什么样

### 源码分析

domainObject
Repository

在AggregateRoot接口里定义了一个方法apply，用来注册Domain Event。当调用Repository方法save来保存AggregateRoot时，将注册的Domain Event发布。

有三条线：

1. 领域驱动
2. 事务执行
3. 异步执行

###  领域驱动

![](/public/upload/architecture/domain_object.png)

代码执行的核心是：

	public interface EventBus {
	    public void subscribe(EventListener eventListener);
	    void publishInTransaction(EventMessage[] messages, LocalTransactionExecutor localTransactionExecutor);
	}

从一个例子看执行流程：

	public class OrderService {
		@Transactional
    	public PricedOrder placeOrder(int productId, int price) {
        	PricedOrder pricedOrder = OrderFactory.buildOrder(productId, price);
        	return orderRepository.save(pricedOrder);
    	}
	}
	@Service
	public class OrderHandler {
		@EventHandler
    	public void handleOrderCreatedEvent(OrderPlacedEvent event) {
        	Payment payment = PaymentFactory.buildPayment(event.getPricedOrder().getId(),
                String.format("p000%s", event.getPricedOrder().getId()), event.getPricedOrder().getTotalAmount());
        	paymentRepository.save(payment);
    	}
	}
	
1. 系统启动的时候，EventHandler 标记的类和方法会被封装为EventListener，加入到EventBus中
2. `PricedOrder pricedOrder = OrderFactory.buildOrder(productId, price);`中执行了PricedOrder构造函数，执行了`pricedOrder.apply(new OrderPlacedEvent(this));` 本质上将pricedOrder 转换成了 EventMessage
3. `orderRepository.save(pricedOrder)` 触发执行`eventBus.publishInTransaction(EventMessage[] messages, LocalTransactionExecutor localTransactionExecutor);` 然后各个eventhandler 就被触发执行了。当然，在spring Transaction场景下，eventBus.publishInTransaction也可以由事务调用触发。

	* 向threadlocal 挂一个clientSession
	* 向clientSession 加入 AggregateEntry，AggregateEntry 聚合了pricedOrder 和一个全局的eventBus。同时挂一个实际的save逻辑
	* clientSession commit，主体就是执行 eventBus.publishInTransaction

		* 因为eventBus是全局的，里面的EventListener太多， 所以要找到和EventMessage匹配的EventListener
		* EventListener 根据 EventMessage 执行逻辑
		* 执行save domain 逻辑本身
		
	* clientSession flush、postHandle、closeClientSession 等完成后续流程

仅仅靠注解，如何知道`OrderHandler.handleOrderCreatedEvent` 处理的就是`pricedOrder.apply(new OrderPlacedEvent(this));` ？根据参数类型。**这也是整个eventbus的意义所在：发布者发布事件，监听者监听事件。框架将整个过程整合在一起并处理。**

“发布者发布事件，监听者监听事件”的优势在于：举一个例子， 笔者实现配置中心系统时，新增一个配置需要进行很多关联操作：

1. 打掉系统中的缓存
2. 新增ConfigChange数据
3. 新增ChangeLog数据

并且随着业务需求的调整，新增一个配置要做的工作越来越多，并且在不断变化。新增配置如此，更改配置就更不用多说。后来，笔者提供了一个ConfigAddListener、ConfigChangeListener等。关心这些事件的人实现这个listener即可。


### 事务

	@Transactional
	public PricedOrder placeOrder(int productId, int price) {
    	PricedOrder pricedOrder = OrderFactory.buildOrder(productId, price);
    	return orderRepository.save(pricedOrder);
	}
	
此处只是借用了spring-tx 的 Transactional 注解的调用接口做外壳，在其回调方法中塞的是[compensable-transaction](http://qiankunli.github.io/2018/01/07/compensable_transaction.html)的事务处理逻辑。

### 异步执行

当eventhanlder 标记为异步任务时，将任务加入到Disruptor中。Disruptor是一个高性能队列，可以当做一个高性能的ArrayBlockingQueue 使用。然后有一个独立的Executor从Disruptor 取出任务并执行。

