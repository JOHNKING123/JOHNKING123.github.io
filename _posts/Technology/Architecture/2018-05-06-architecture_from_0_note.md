---

layout: post
title: 《从0开始学架构》笔记
category: 技术
tags: Architecture
keywords: 分布式系统

---

## 简介

内容来自 李运华 在 极客时间 《从0开始学架构》 的 分享

优秀的人总是会做一件事，对于一个领域，发现一些tip，提炼一个方法论，试错和完善这个方法论。

## tips

架构设计的 关键思维是 判断和 取舍，程序设计 的关键思维 是逻辑和实现。

架构是什么？

1. 首先 梳理几个概念：系统与子系统、模块与组件、框架与架构
2. 系统的定义，维基百科：系统泛指由一群有关联的个体组成，根据某种规则运作，能完成个别元件不能单独完成的工作的群体。包含多个有关联的个体，个体按定义好的规则运行。
3. 逻辑角度拆分，划分模块的主要目的是职责分离。物理角度拆分，划分组件的主要目的是 单元复用。比如做一个学生信息管理系统，从逻辑角度拆分可以分为登陆注册、个人信息、个人成绩等，从物理角度来拆分，可以分为Nginx、Web服务器、MySQL
4. 框架 通常指的是为了实现 某个业界标准或完成特定基本 任务的软件组件规范，提供规范所要求之基础功能。软件架构：软件系统的顶层结构。

优秀程序猿和架构师之间一个明显的鸿沟是：不确定性。对于程序猿 编程来说，程序是确定的（有语法约束等），执行结果是确定的。而对架构设计来说，A和B公司可能架构完全不同，但都运转的挺好。面对不确定性，就要选择，就要取舍。

1. 业界很多领先的方案，都是逼出来的。
2. 演化优于一步到位，经常拿软件架构和建筑架构举例，但建筑架构一旦完成就不再改变，软件却需要根据业务不断地变化。在迭代中保留优秀的设计，修复有缺陷的设计，改正错误的设计，去掉无用的设计

笔者说一个自己的体会，笔者负责一个项目，与一般的业务处理不同，其更偏向于数据处理，笔者经过调研发现，很像apache 的commons-pipeline. 于是尝试用commons-pipeline 来改写项目，但改动起来发现非常的别扭

1. commons-pipeline  与 spring 整合起来不是很顺。不是很顺的原因是， commons-pipeline的构建是自成一体的（也就是new 出来的）。同时，一般业务也离不开 对数据库的、redis等第三方数据源。 
2. 笔者对项目的抽象 也未能完全摸清，对项目得理解 通常也无法一步到位

此时，以重构的方法 来慢慢 演化项目，向commons-pipeline 上靠，改一点上线一点，逐步验证，无疑更稳重的多。

## 架构设计的历史背景

1. 如果要深入理解一个事物的本质，最好的方式就是去追寻这个事物出现的历史背景和推动因素
2. 随着软件 系统规模的增加，计算相关 的算法 和 数据结构不再构成 主要的设计问题，当系统由许多部分组成时，整个系统的组织，也就是所说的“软件架构”，导致了一系列 新的设计问题。 笔者想起昨天 学习的paxos 算法，虽说是算法，但paxos 明显不再关注 各个节点如何存储、检索本地存储的通信数据 这类事儿，而是提出proposer、acceptor 等角色，规定了它们的 交流规则，这才是难点。

不好的架构有什么特点：不容易写，不容易读/懂，不容易改/debug

架构设计 的主要目的是 为了解决 软件系统复杂度带来的问题（复杂度 变大 带来了第一次和第二次软件危机）。

复杂度来源

1. 高性能
2. 高可用
3. 可扩展性
4. 低成本、安全和规模。

	* 低成本通常不是首要目标，往往只有创新才能达到低成本目标。 
	* 规模变大后，量变可能会引起质变，如大数据就独立成为一门热门技术。
5. 

## 高性能

* 硬件性能的提升。通常不会带来复杂度的提升，比如存储从纸带,磁带,磁盘,ssd，替换就完事了
* 软件系统性能的提升，通常会带来复杂度的提升

软件这块
	
1 单机内部为提高性能带来的复杂度。单进程 ==> 多进程/多进程通信方案 ==> 多进程/多线程/多线程“通信”方案  
2 多台计算机为了高性能带来的复杂度

	* 任务分配，调度算法、负载均衡、负载监控报警、动态扩容缩容
	* 任务分解

## 高可用

系统无中断的执行其功能的能力，主要通过冗余来实现高可用。

1. 计算高可用
2. 存储高可用，存储高可用的难点不在于如何备份儿数据，而在于如何减少或者规避数据不一致对业务造成的影响（因为网络延迟、中断等不可避免）
3. 高可用状态决策

## 可扩展性

1. 面向对象思想的提出
2. 设计模式
3. 两个基本条件：正确预测变化，完美封装变化

完美封装变化

1. 系统需要拆分出变化层和稳定层
2. 需要设计变化层和稳定层之间的接口

## 如何学习一个开源项目

1. 不要一上来就看源码，而是要基本掌握了功能、原理、关键设计之后再去看源码。看源码的主要目的是学习其代码的写作方式，以及关键技术的实现。

	* 不建议通读源码
	* 写demo 故意打断点 来查看调用栈
2. 安装一遍很有意义。可以了解系统有哪些 组件，依赖哪些库，配置文件有哪些配置（可以说明一些问题）
3. 原理研究

	* 关键特性的基本实现原理
	* 项目的设计文档、白皮肤，了解一个系统有哪些基本点
	* 阅读以后的分析文档
	* demo 验证

## 其它材料

[优秀架构师必须掌握的架构思维](https://mp.weixin.qq.com/s?__biz=MzI4MTY5NTk4Ng==&mid=2247484527&idx=2&sn=252d8b5bd0330036de8493739191d472&chksm=eba407f2dcd38ee45f3b84a47712f8dfeea2737d6ab4a5d5e94e7d930e25c8a2c1b1995ae1dc&mpshare=1&scene=23&srcid=0515YYrhZguaeaLjTDiK5Ubu%23rd) 要点如下：

1. 架构的本质是管理复杂性，抽象、分层、分治和演化思维是我们工程师 /架构师应对和管理复杂性的四种最基本武器。
2. 抽象能力的强弱，直接决定我们所能解决问题的复杂性和规模大小。
2. 有经验的程序员写代码会保持抽象层次的一致性，代码读起来像讲故事，比较清晰易于理解；而没有经验的程序员会有明显的抽象层次跳跃问题，比如一个购买流程：更新库存、打折计算、支付校验、支付、送货。那么你在buy 方法里，突然蹦出来 某个银行的调用api，这就是抽象层次跳跃。《clean code》中也在强调避免这个问题。
3. 对于互联网系统，基本上可以说是三分设计，七分演化。架构师除了要利用自身的架构设计能力，同时也要学会借助用户反馈和进化的力量，推动架构的持续演进，这个就是演化式架构思维。从另一个角度说，微服务架构就是单体架构逐渐演化来的。

## 脑图

会随着阅读的深入，继续补充

![](/public/upload/architecture/learn_architecture_from_0_mind_map.png)

## 个人


个人感觉，首先是分层，最上层是用户怎么操作。最底层 是你有什么东西。中间 是 最上层和最底层 的 适配，可能有多层。每一层 都是多个子模块，划分子模块的依据是

1. 业务层面

	* 具有明确的领域边界。比如用户管理、订单管理
	* 复用。比如红包和打赏 都要用到支付系统

2. 技术层面：

	* 易变和不易变的分开
	* 流量大和流量小的分开
	
3. 还是实践

    1. 纠结一个方案的时候，拿高性能、高可用、可扩展套一套
    2. 大理论与小细节的把握。笔者曾碰到一个问题，查询数据耗时。有两种意见， 一种认为mysql 针对特定字段加索引，速度不会很慢的；一种是使用pika（redis的持久化实现） 存储。从指标上，前者几ms，后者可以做到1ms 以下，在对性能极端要求的场合，适合采用pika方案。这个问题里，如果你对 性能指标没有 什么认识，则极容易陷入模棱两可中。

	
实现架构的时候，做好目标管理。先实现主要的，再实现次要的，这句其实不是废话。为什么？因为主要功能 很多时候决定了架构设计，**而在迭代的过程中**，上层架构会做微调，一旦微调，细节相关的代码就有可能会作废。