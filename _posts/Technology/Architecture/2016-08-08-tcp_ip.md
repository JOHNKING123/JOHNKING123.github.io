---

layout: post
title: tcp/ip
category: 技术
tags: Architecture
keywords: network tcp/ip

---

## 简介

说起tcp/ip，大家都知道“三次握手，四次分手”。聊起为什么？都会打比方。这说明我对tcp/ip的了解还很不够，是时候整理一下了。

## tcp协议字段组成

一个协议由：字段 + 基于字段之上的策略 组成

![Alt text](/public/upload/architecture/tcp_protocol.png)

比如图中的“window size",是不是看起来很耳熟。

## 序列号和确认号

TCP会话的每一端都包含一个32位（bit）的序列号，该序列号被用来跟踪该端发送的数据量。每一个包中都包含确认号，在接收端则通过确认号用来通知发送端数据成功接收。

从序列号和确认好的角度看，三次握手是这样的：

1. 客户端向服务器发送一个同步数据包请求建立连接，该数据包中，初始序列号（ISN）是客户端随机产生的一个值。

2. 服务器收到这个同步请求数据包后，会对客户端进行一个同步确认ACK（确认号是客户端的初始序列号+1 ）。这个数据包中，序列号是服务器随机产生的一个值。

3. 客户端收到这个同步确认数据包后，再对服务器进行一个确认。该数据包中，序列号是上一个同步请求数据包中的确认号值，确认号是服务器的初始序列号+1。

假设初始序列号是0（不管是客户端请求，还是服务端响应），那么序列号为当前端成功发送的数据位数，确认号为当前端成功接收的数据位数。握手过程中，尽管没有传输有效数据，确认号还是被加1，这是因为接收的包中包含SYN或FIN标志位（占1bit）。

由此，我们就可以知道为什么一些linux命令可以统计流量，为什么说tcp是可靠地？序列号、确认号、checksum即可以保证交互双方正确传输了n字节的数据。序列号来保证所有传输的数据可以按照正常的顺序进行重组，从而保障数据传输的完整。 

## backlog

To understand the backlog argument, we must realize that for a given listening socket, the kernel maintains two queues :

1. An incomplete connection queue, which contains an entry for each SYN that has arrived from a client for which the server is awaiting completion of the TCP three-way handshake. These sockets are in the SYN_RCVD state .
2. A completed connection queue, which contains an entry for each client with whom the TCP three-way handshake has completed. These sockets are in the ESTABLISHED state 

A completed connection queue, which contains an entry for each client with whom the TCP three-way handshake has completed. These sockets are in the ESTABLISHED state.Berkeley-derived implementations add a fudge factor to the backlog: It is multiplied by 1.5

When a SYN arrives from a client, TCP creates a new entry on the incomplete queue and then responds with the second segment of the three-way handshake: the server's SYN with an ACK of the client's SYN (Section 2.6). This entry will remain on the incomplete queue until the third segment of the three-way handshake arrives (the client's ACK of the server's SYN), or until the entry times out. (Berkeley-derived implementations have a timeout of 75 seconds for these incomplete entries.)

If the queues are full when a client SYN arrives, TCP ignores the arriving SYN (pp. 930–931 of TCPv2); it does not send an RST. This is because the condition is considered temporary, and the client TCP will retransmit its SYN, hopefully finding room on the queue in the near future. If the server TCP immediately responded with an RST, the client's connect would return an error, forcing the application to handle this condition instead of letting TCP's normal retransmission take over. Also, the client could not differentiate between an RST in response to a SYN meaning "there is no server at this port" versus "there is a server at this port but its queues are full."


## 其它

在TCP传送一个数据包时，它会把这个数据包放入重发队列中，同时启动计时器，如果收到了关于这个包的确认信息，便将此数据包从队列中删除，如果在计时器超时的时候仍然没有收到确认信息，则需要重新发送该数据包。

## MSL和端口占满（待整理）

[一个同事深挖的客户端端口占满的问题](http://cloudate.net/?p=2356)

## 引用

[TCP序列号和确认号详解](http://www.cnblogs.com/chenboo/archive/2011/12/19/2293327.html)