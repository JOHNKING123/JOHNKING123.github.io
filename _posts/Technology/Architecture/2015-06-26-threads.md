---

layout: post
title: 服务端编程
category: 技术
tags: Architecture
keywords: 服务端 多线程

---

## 简介

从学习编程到现在，经常写程序去调用别人的服务，除了web系统外，从来没有考虑过，为别人提供服务的系统（服务端）如何设计。即便是web系统，也是直接使用spring mvc等已封装好的抽象，且每个业务逻辑都会占用一个线程，这对于服务端编程来讲，只是最简单的范式之一。

服务端提供服务有多种调用方式：RPC，RESTFUL API，http，或者是干脆直接的tcp

以tcp方式为例，作为一个服务端程序，包含以下部分（不是模块划分）：

1. 初始化，即从主线程开始，初始化一系列的数据结构
2. 连接管理，服务端一般以socket方式与客户端通信，一旦连接建立成功，一个客户端将对应一个socket
3. 解析客户端发来的数据，计算结果并返回客户端。这里有几个问题：

    - 使用何种io通信模型：bio，io复用和aio
    - 为客户端处理请求的过程：是和io（即数据读取和写入）合在一起，还是交给单独的工作线程处理？


从业务上讲，服务端一般分为通信部分和业务处理部分。并且，除非业务处理非常简单，否则，业务处理部分与通信部分大都是分开的，并且业务处理部分由专门的工作线程执行。有两种情况：

- 一对一模型，新的请求到达时，新建一个工作线程来处理业务请求
- 多对多模型，事先建立工作线程池，将业务分派到工作线程上，有两种分派模型：

    - 将所有的任务用队列存储起来，每个工作者依次去拿一个来处理，直到做完所有的任务为止。
    - 将任务平均分给工作者，先做完任务的工作者就去别的工作者那里拿一些任务来做，同样直到所有任务做完为止。（goroutine调度模型貌似就是采用这种方式，每个goroutine有一个任务队列，调度器维护一个全局任务队列。）


**题外话：多核cpu的调度策略**

我们大学学习的《操作系统》，还停留在单核cpu的思维。

一般多核任务调度算法有全局队列调度和局部队列调度。

- 前者是指操作系统维护一个全局的任务等待队列，当系统中有一个CPU核心空闲时，操作系统就从全局任务等待队列中选取就绪任务开始在此核心上执行。这种方法的优点是CPU核心利用率较高。
- 后者是指操作系统为每个CPU内核维护一个局部的任务等待队列，当系统中有一个CPU内核空闲时，便从该核心的任务等待队列中选取恰当的任务执行，这种方法的优点是任务基本上无需在多个CPU核心间切换，有利于提高CPU核心局部Cache命中率。

目前多数多核CPU操作系统采用的是基于全局队列的任务调度算法。


## 我们加到“任务”队列里的是什么

工作线程池通常会包含一个“任务”队列，受表达方式的影响，如果用java语言描述的话，我一直觉得任务队列中存储的是Runnable（或thread）元素（用来描述任务是什么），实际上，这个元素要复杂的多，包括：

1. 返回结果的存储位置
2. 任务的描述
3. 其他信息。

工作线程的处理逻辑：

1. 从任务队列中取出一个元素
2. 如果没有，则等待
3. 如果有，则执行任务，填充“返回结果”
4. 返回步骤1


## 其他









