---

layout: post
title: 《mysql技术内幕》笔记2
category: 技术
tags: Architecture
keywords: mysql innodb

---

## 简介

## 索引

全文索引

### 红黑树

[红黑树深入剖析及Java实现](https://tech.meituan.com/redblack-tree.html)

基本要点：BST，Balanced BST，Red-Black Tree

1. 二叉树在插入的时候会导致树倾斜，不同的插入顺序会导致树的高度不一样，而树的高度直接的影响了树的查找效率。平衡树在插入和删除的时候，会通过旋转操作将高度保持在logN。具有代表性的平衡树分别为AVL树和红黑树。AVL树由于实现比较复杂，而且插入和删除性能差，在实际环境下的应用不如红黑树。
2. 二叉树通过旋转保持平衡，旋转算法是不同树的**具有区分性的特质**之一。红黑树通过引入颜色的概念，通过颜色这个约束条件的使用来保持树的高度平衡。

||插入维持平衡|删除维持平衡|
|---|---|---|
|二叉树|旋转|旋转|
|B+Tree|节点的分裂、元素的上浮|向兄弟节点借元素、合并节点、元素的下沉|

二叉树与高阶（一个节点多于2个叉）树不同在于，高阶树中每个节点元素的个数,为旋转算法提供了决策依据，体现在：

1. 是否需要分裂合并等操作
2. 大多数时候，一个插入和删除操作影响节点本身、父亲和兄弟节点，通过父节点元素个数，可以简单的判断是否波及其他节点。

而对于二叉树来说，这些都可以实现，大不了整棵树遍历一遍。但没有类似于“节点个数”（因为都是一个）这样直接的信息来提供决策，这也是为什么说“AVL树实现比较复杂”的原因吧。红黑树，节点的颜色标记，估计与“节点个数”有异曲同工的作用。有一句话说，“纠结的原因通常是因为掌握的信息不够（或信息获取比较难）”，其存在标识一种平衡状态，通过局部的直接判断，即可进行旋转决策。

## 锁

在数据库中，锁有lock和latch，一般业务开发熟悉的锁对应的是latch，简单区别如下：

||对象|保护|持续时间|存在于|
|---|---|---|---|---|
|lock|事务|表、页、行|整个事务过程|logck manager的哈希表中|
|latch|线程|内存数据结构|很短|每个数据结构的对象中|

## 事务

[理解事务 - MySQL 事务处理机制](https://juejin.im/entry/58f08b4cda2f60005d225a8e)基本要点（太经典，要低水平的复制粘贴了）：

重新理解一致性：在事务T开始时，此时数据库有一种状态，这个状态是所有的MySQL对象处于一致的状态，例如数据库完整性约束正确，日志状态一致等，当事务T提交后，这时数据库又有了一个新的状态，不同的数据，不同的索引，不同的日志等，但此时，**约束，数据，索引，日志等MySQL各种对象还是要保持一致性（正确性）。** 这就是 从一个一致性的状态，变到另一个一致性的状态。也就是事务执行后，并没有破坏数据库的完整性约束（一切都是对的）。

重新理解隔离性：即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。


|事务|加解锁阶段|
|---|---|
|begin;|获取唯一自增的事务id等操作|
|insert...|加insert对应的锁|
|update...|加update对应的锁|
|delete...|加delete对应的锁|
|commit;|事务提交时，同时释放insert、update、delete对应的锁|

所以，begin和commit除了标记一个事务的开始与结束外，在数据库实现中，是有对应的操作意义的。

## 事务隔离级别与锁的关系

[Innodb中的事务隔离级别和锁的关系](https://tech.meituan.com/innodb-lock.html)基本要点:

1. 一致性和隔离性一般都通过加锁来实现
2. 不同的隔离性要求，加锁时机和类型都有所不同


|事务级别|脏读|不可重复读|幻读|加锁实现，具体的三种增删改写操作加的锁视情况不一样|rr：读取正在读取的行；rw 读取正在写的行；wr、ww类似|
|---|---|---|---|---|---|
|Read Uncommitted|可能|可能|可能|任何操作都不会加锁|rr,rw,wr,ww都允许|
|已提交读Read committed|不可能|可能|可能|读取不加锁，增删改加锁|rr wr允许;rw rw看是否是一致性锁定读；ww不允许|
|可重复读Repeatable read	|不可能|不可能|可能|悲观锁方案：读加共享锁，写加排他锁；乐观锁方案：xx；|rr允许；rw看是否是一致性锁定读；ww、wr不允许|
|可串行化 Serializable |不可能|不可能|不可能|悲观锁方案：读加共享锁，写加排他锁，读写互斥（读的时候不可以写操作，哪怕不是同一行记录）；乐观锁方案：不可行|除同一行严格要求外，不同行wr也不允许|

很多人容易搞混不可重复读和幻读，确实这两者有些相似。但不可重复读重点在于update和delete（对先后读取操作的影响），而幻读的重点在于insert。

锁定和非锁定，是锁的另一个维度

||表现|
|---|---|---|
|悲观锁|读写加锁，写加排他锁，读加什么锁视情况|
|乐观锁|乐观锁其实并不是真正的锁机制，它只是一种思想。每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。|

读操作，可以通过`select xx for update` 的方式对行加排他锁。

||读取已被排他锁占用的行|
|---|---|
|一致性锁定读|无法读取|
|一致性非锁定读|读取老版本数据|
