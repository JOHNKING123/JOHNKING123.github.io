---

layout: post
title: 《架构整洁之道》笔记
category: 架构
tags: Architecture
keywords: window

---

## 简介（持续更新）

* TOC
{:toc}

## 架构设计是有一些原则的

余晟：结构化编程 杜绝了goto 导致的混乱，有多少次， 我看到的系统设计图里，根本没有”层次“的概念，各个模块没有一致的接口划分，与子系统交互的不是子系统，而是一盘散沙的接口，甚至接口之间随意互调，带来的就是维护与调试的噩梦，吹散历史的迷雾，不正是古老的goto陷阱的再现吗？

|开发的三个层次||
|---|---|
|程序员|代码跑起来就行|
|工程师|可读、可扩展、可维护、重用<br>用工程的方法来写代码|
|架构师||

大多数的人目标不是设计出一个优质的软件或架构，而是快速解决一个具体的问题。但问题就像一个生命体一样，它们会不断地繁殖和进化， 问题的多少和系统的复杂度呈正比，并且是指数级正比，此时越来越难做技术决定，此时有一些资深的工程师开始挑战这些问题，有一些资深的工程师开始站出来挑战这些问题， 有的基于业务分析给出平衡的方案 有的开始尝试设计更高级的技术，有的开始设计更灵活的系统，有的则开始简化和轻量化整个系统，他们就是架构师。

软件架构关注的一个重点是组织结构（structure），不管是讨论组件Component、类Class、函数Function、模块Module，还是层级Layer、服务Service以及微观与宏观的 软件开发过程，软件的组织结构 都是我们的主要关注点。

物理建筑，不管地基是石头还是水泥，形状是高大还是宽阔， 风格是气势恢宏还是小巧玲珑， 其组织结构都一目了然。物理建筑的组织结构 必须遵循“受重力”这一自然规律，同时还要符合 建筑材料自身的物理特性。

计算机硬件在过去许多年发生了巨大的变化， 但今天的软件和过去本质上是一样的，都是由if、赋值语句以及while 循环组成的 ==> 软件架构的规则就是 排列组合代码块的规则 ==> 代码块没什么变化，因此排列组合它们的规则也不会变化。 

一个软件架构的优劣，可以用它满足用户需求所需要的成本来衡量。 为了在系统构建过程中采用好的设计和架构以便减少构建成本，需要先了解系统架构的各个属性与成本和生产力的关系。 （优劣以成本衡量 ==> 成本来自几个部分 ==> 架构的组成及每个部分和成本的关系）

每个软件系统都可以通过行为和架构两个维度来体现它的实际价值

1. 行为价值，按照需求，实现业务，创造理论，并修复出现的bug。**这也是大部分程序猿认为的全部工作**。 
2. 架构价值，软件系统必须足够”软“即容易修改。从系统相关的角度看，他们所提出的一系列的变更需求的范畴都是类似的，因此成本也应该是固定的。但从研发者的角度看，系统持续不断地变更需求像是要求他们不停地用一堆不同形状的拼图块拼成一个新的“形状”。如果系统架构设计偏向某种特定的“形状”，新的变更就越来越难以实施。

软件架构师这一职责本身就应更关注系统的整体结构，而不是具体的功能和系统行为的实现。软件架构师必须创建出一个可以让功能实现起来更容易、修改起来更简单、扩展起来更轻松地软件架构。

笔者的一个体会是，我们去推动一个事情， 从管理的角度，一方面是给公司带来价值，一方面是锻炼团队水平，进而间接的带来价值。

## 编程范式

|编程范式|提出时间|描述|解决的问题|对应到泛指的分布式系统||
|---|---|---|---|---|
|结构化编程|1968|对程序控制权的直接转移进行了限制和规范|消灭goto|接口之间随意互调|带来的就是维护和调试的噩梦|
|面向对象编程|1966|对程序控制权的间接转移进行了限制和规范|**利用多态限制对函数指针的使用**<br>通过封装、继承、多态 让代码的”缝隙“大一点<br>对变更更友好|接口的设计非常随意，不是基于行为而是基于特定场景实现<br>没有做适当的抽象，也没有给未来留有空间|
|函数式编程|1958|对程序中的赋值进行了限制和规范|隔离可变性、避免状态冲突|状态或变量的修改直接暴露，被不经意/恶意修改|只提供CR，不提供完整的CRUD操作|

这三个编程范式都对程序猿提出了新的限制，每个范式都约束了某种编写代码的方式，没有一个编程范式是在增加新能力。也就是说，**我们过去50年学到的东西主要是——什么不应该做**。

我们必须面对这种不友好的现实：软件构建并不是一个迅速前进的技术。今天构建软件的规则和1946年阿兰.图灵写下电子计算机第一行代码时是一样的。**尽管工具变化了，硬件变化了，但软件编程的核心没有变**。

### 结构化编程

1. 顺序、分支、循环可以构造任何程序
2. 顺序、分支、循环代码的正确性可以被证明
3. goto某些用法的正确性无法被证明

我们可以将一个大型问题拆分为一系列高级函数的组合，而这些高级函数各自又可以继续拆分为一系列低级函数，每个被拆分出来的函数都可以用结构化编程范式（顺序、分支、循环）来写。然后再编写相关的测试来视图证明这些函数是错误的，若无法证明，则可以认为这些函数是正确的，进而推导整个程序是正确的。

结构化编程最有价值的地方就是，它赋予了我们创造可证伪程序单元的能力。（作为新世纪的程序猿，我们天然认为是对的，以至于从没看重过这个事儿）这就是为什么现代语言基本已经没有goto了，无论是否自愿，我们都是结构化编程的践行者了。

无论从哪一个层面，从最小的函数到最大的组件，软件开发的过程都和科学研究非常类似，它们都是由证伪驱动的。软件架构师需要定义可以方便地进行证伪（测试）的模块、组件以及服务。为了达到这个目的，它们需要将类似结构化编程的限制方法应用到更高的层面上。

### 面向对象编程

面向对象的三个特性 相对于 以前 并没有理论创新

1. 封装，java、c++相对c 来说，封装性实际上更弱了
2. 继承，在面向对象出来以前，对继承的支持已经很久了，面向对象只是更便利一些。
3. 多态，多态其实不过是函数指针的一种应用，面向对象通过约束使用方式，消除了函数指针滥用危险性。

笔者的理解：虽然没有理论创新，但面向对象还是从形式上 约束开发有意无意的使用上述三个特性，尤其是多态，使得需求变化时，减少代码的更改或不更改成为可能。**毕竟软件开发，一个是应对复杂性，一个是应对变化**。

### 函数式编程

![](/public/upload/architecture/functional_program_design.png)

一切并发应用遇到的问题，一切由于使用多线程、多处理器而引起的问题，如果没有可变变量的话都不可能发生。一个架构设计良好的应用程序 应该将状态修改的部分和不需要修改状态的部分隔离成单独的组件，然后用合适的机制来保护可变量。软件架构师应该着力于将大部分处理逻辑都归于不可变组件中，可变状态组件的逻辑应该越少越好。PS：可以看到，函数式编程不是试图取代所有业务逻辑开发，而是仅取代其中不可变组件的开发。

随着硬件的发展，内存越大， 处理速度越快，我们对可变状态的依赖就越少。比如某个银行应用程序需要维护客户账户余额信息，当它执行存款事务时，就要同时负责修改余额记录。如果我们不保存具体账户余额，仅仅保存事务日志，当有人查询账户余额时，我们将全部交易记录取出并进行累计， 就不需要维护任何可变变量了。读者听起来也许觉得并不靠谱，但我们现在用的源代码管理程序就是这么工作的。
