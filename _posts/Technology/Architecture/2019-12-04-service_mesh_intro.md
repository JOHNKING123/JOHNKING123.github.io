---

layout: post
title: 下一代微服务Service Mesh 
category: 架构
tags: Architecture
keywords: service mesh

---

## 简介

* TOC
{:toc}


Service Mesh 的概念最早是由 Buoyant 公司的 CEO William Morgan [What's a service mesh? And why do I need one?](https://buoyant.io/2017/04/25/whats-a-service-mesh-and-why-do-i-need-one/) 提到的：A service mesh is a dedicated infrastructure layer for handling service-to-service communication. It’s responsible for the reliable delivery of requests through the complex topology of services that comprise a modern, cloud native application. In practice, the service mesh is typically implemented as an array of lightweight network proxies that are deployed alongside application code, without the application needing to be aware. Service Mesh 通常以轻量级的网络代理的方式跟应用的代码部署在一起，从而以**应用无感知的**方式实现服务治理。

## 微服务视角

[为什么说 Service Mesh 是微服务发展到今天的必然产物？](https://www.infoq.cn/article/2017/12/why-service-mesh)

著名软件大师Chris Richardson 曾一针见血地指出：“微服务应用是分布式系统，由此会带来固有的复杂性。开发者需要在 RPC 或者消息传递之间选择并完成**进程间通讯机制**。此外，他们必须写代码来处理消息传递中速度过慢或者不可用等局部失效问题。”种种复杂局面便催生了服务间通信层的出现，这个层既不会与应用程序的代码耦合，又能捕捉到底层环境高度动态的特点，让业务开发者只关注自己的业务代码，并将**应用云化后带来的诸多问题以不侵入业务代码的方式**提供给开发者。这个服务间通信层就是 Service Mesh

普元微服务专家宋潇男：让我们回忆一下单机程序的运作方式，源代码被编译器编译为一系列目标文件，然后交由链接器将这些目标文件组装成一个可执行文件，链接过程就是将各个目标文件之间对符号（方法、变量、函数、接口等）的引用转化为对内存地址的引用，由于这个过程在生成可执行文件时就完成了，所以被称为静态链接。后来为了程序的模块化和功能上的解耦与共用，开始把一些常见的公共程序剥离出来，制作成库文件供其他程序使用，在引用这些库文件的程序运行时，操作系统上的动态链接器会在库文件中查询到被引用的符号，然后将这些符号的内存地址映射到该程序的虚拟内存空间之中，由于这个过程是在程序运行时完成的，所以被称为动态链接。

再后来出现了分布式系统，程序被散布在网络中的不同主机上，那么如何链接这些程序呢？业界走过了和链接单机程序类似，但是却艰难得多的一段历程。

1. 最开始是把这些服务的网络地址写在配置文件中，这个方案显然问题太多、很不靠谱。
2. 接下来自然而然地出现了服务注册中心来统一记录这些服务的网络地址并维护这些地址的变化，服务通过注册中心提供的客户端 SDK 与注册中心通信并获得它们所依赖的服务的网络地址。由于网络通信远没有内存通信稳定，为了保证可靠的服务调用，又出现了用于流量控制的 SDK，提供流量监控、限流、熔断等能力。被依赖的服务往往以多实例的方式运行在多个主机上，有多个网络地址，所以又出现了用于负载均衡的 SDK。
3. 我们手里多了一堆 SDK，已有的（未接入微服务）应用，必须用这些 SDK 重新开发；而对于新开发的应用，我们又发现这些 SDK 体积过大。对比单机上动态链接过程的顺畅，这种基于 SDK 的微服务动态链接方案简直是难用的不得了。

在三到五年之后，Kubernetes 会成为服务器端的标准环境，就像现在的 Linux，而 Service Mesh 就是运行在 Kubernetes 上的分布式应用的动态链接器，届时开发一个分布式应用将会像开发单机程序一样简单，**业界在分布式操作系统上长达三十多年的努力将以这种方式告一段落**。

### 传统微服务架构

![](/public/upload/practice/traditional_micro_service.png)

### Service Mesh架构

![](/public/upload/practice/service_mesh.png)

## 整体架构

内容主要来自胡忠想在极客时间上的《从0开始学微服务》

![](/public/upload/architecture/service_mesh.png)

### SideCar

业务和sidecar如何交互？

![](/public/upload/architecture/service_mesh_sidecar_proxy.png)

![](/public/upload/architecture/service_mesh_sidecar_direct.png)

### Control Plane 

![](/public/upload/architecture/service_mesh_control_plan.png)

## Service Mesh 所带来的变化

基本摘抄自[Service Mesh 是新瓶装旧酒吗？](https://mp.weixin.qq.com/s/jtJ1kSYQHsK8o9AnTFEzAQ)

### 服务治理手段从过去的框架思维向平台思维转变

框架思维向平台思维转变在执行上集中体现于“轻量化”和“下沉”两个动作。

1. 轻量化是指将那些易变的功能从框架的 SDK 中移出，结果是使用了 SDK 的应用变得更轻，免除了因易变功能持续升级所带来的低效；也彻底让应用的开发者无需关心这些功能，让他们能更好地聚焦于业务逻辑本身；
2. 从框架中移出的功能放到了 Service Mesh 的 Sidecar 中实现了功能下沉。

Service Mesh 作为平台性技术，将由云厂商去运维和提供相应的产品，通过开源所构建的全球事实标准一旦被所有云厂商采纳并实现产品化输出，那时应用的可移植性问题就能水到渠成地解决。

阿里巴巴的电商核心应用基本上都是用 Java 构建的，在 Mesh 化之前，RPC 的服务发现与路由是在 SDK 中完成的，为了保证 双11 这样的流量洪峰场景下的消费者用户体验，会通过预案对服务地址的变更推送做降级，避免因为频繁推送而造成应用进程出现 Full GC。

Mesh 化之后，SDK 的那些功能被放到了 Sidecar（开发语言是 C++）这一独立进程中，这使得 Java 应用进程完全不会出现类似场景下的 Full GC 问题。

Service Mesh 使得应用与技术基础设施之间的关系变得更松且稳定，通过流量无损的热升级方案，使得应用与技术基础设施的演进变得独立，从而加速各自的演进效率。软件不成熟、不完善并不可怕，可怕的是演进起来太慢、包袱太重。当应用被 Mesh 化后，接下来的技术基础设施的升级对之就透明了，之前因为升级工作所需的人力配合问题可以通过技术产品化的手段完全释放。

另外，以往应用进程中包含了业务逻辑和基础技术的功能，不容易讲清楚各自对计算资源的消耗，Service Mesh 通过独立进程的方式让这一问题得以更好地隔离而实现量化，有了量化结果才能更好地对技术做优化。

### 技术平台的建设从面向单一编程语言向面向多编程语言转变

当企业的发展进入了多元化、跨领域、规模更大的更高阶段时，多编程语言的诉求就随之产生，对于阿里巴巴这样的云厂商来说更是如此。多编程语言诉求的背后是每种编程语言都有自己的优势和适用范围。从技术层面，这一转变意味着：

1. 技术平台的能力需要尽可能地服务化，**避免因为服务化不彻底而需要引入 SDK**，进而带来多编程语言问题（即因为没有相应编程语言的 SDK 而无法使用该编程语言）；
2. 在无法规避 SDK 的情形下，让 SDK 变得足够的轻且功能稳定，降低平台化和多编程语言化的工程成本，支持多编程语言 SDK 最好的手段是采用 IDL。

从组织层面，这一转变意味着平台技术团队的人员技能需要多编程语言化。一个只有单一编程语言的团队是很难做好面向多编程语言的技术平台的。

## 发展机遇

### 面向未来的分布式应用开发平台

在 Service Mesh 出现之前，各种分布式服务治理技术产品的发展，缺乏强有力的抓手去横向拉通做体系化设计和完成能力复用，因而难免出现概念抽象不一致和重新造轮子的局面，最终每个技术产品有自己的一套概念和独立的运维控制台。因为 Service Mesh 的出现，我们有机会就分布式应用的治理做一次全局的设计，也有机会将各种技术产品整合到一起而避免重复建设的问题。

易用性心智的确立，将使得开发者能在一个运维控制台上做最少的操作，通过为他们屏蔽背后的技术实现细节，而减轻他们在使用时的脑力负担，以及降低操作失误带来安全生产事故的可能性。PS：易用性的重大价值

### 给其他技术产品创造了重新思考云原生时代的发展机会

有了 Service Mesh 后，以前很多独立的技术产品（比如，服务注册中心、消息系统、配置中心）将变成 BaaS（Backend as a Service）服务，由 Service Mesh 的 Sidecar 负责与它们对接，应用对这些服务的访问通过 Sidecar 去完成，甚至**有些 BaaS 服务被 Sidecar 终结而完全对应用无感**。

## 给技术基础设施如何与业务基础技术更好地协同提供了一次探索机会

每一种业务（比如电商）都会构建基于所在领域的基础技术，这类技术我们称之为业务基础技术。

当阿里巴巴希望将某一业务的基础技术搬到外部去服务客户时，面临业务基础技术如何通过服务化去满足客户已选择的、与业务基础技术不同的编程语言的问题，否则会出现基于 Java 构建的业务基础技术很难与 Go 所编写的应用协同。

在 Service Mesh 致力于解决服务化问题的过程中，能否通过一定的技术手段，让业务基础技术的能力通过插件的形式“长”在 Service Mesh 之上是一个很值得探索的点。当业务基础技术以插件的形式存在时，业务基础技术无需以独立的进程存在而取得更好的性能，且这一机制也能被不同的业务复用。

**业务的基础技术并非开发了一个独立的应用（进程）然后做发布和运维管理，而是针对 Service Mesh实现了业务技术插件**，插件通过 Service Mesh 的运维平台进行管理，包含安装、灰度、升级、监控等能力。由于插件是“长”在 Service Mesh 之上的，插件化的过程就是业务技术服务化的过程。

### 给探索面向未来的异地多活、应用永远在线的整体技术解决方案打开了一扇大门

服务之间的互联互通，服务流量的控制、观测和安全加固是微服务软件架构下所要解决的关键问题，这些问题与规模化下的服务可用性和安全性紧密相关。

[阿里巴巴 Service Mesh 落地的架构与挑战](http://dict.youdao.com/w/eng/Nacos/#keyfrom=dict2.index)兑现 Service Mesh 的价值，让业务与技术设施能以更高的效率彼此独立演进

## 其它

**软件设计的质量主要体现在“概念”和“关系”两个词上。同样功能的一个系统，不同的概念塑造与切分将产生完全不同的设计成果，甚至影响到最终软件产品的工程质量与效率。当概念确定后，关系也随之确立，而关系的质量水平体现在解耦的程度上**。