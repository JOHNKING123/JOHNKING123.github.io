---

layout: post
title: 《编程的本质》笔记
category: 技术
tags: Architecture
keywords: abtest

---

## 简介

本文主要来自陈皓 的两篇文章 以及付费专栏《左耳听风》，作者的水平很高，语句也很精炼，实在是没什么可提炼整理的，干脆就弄成读书笔记了。

## 笔记

[左耳朵耗子：编程的本质是什么？](http://www.gzhshoulu.wang/article/2101593) 要点：

1. 两个公式 Programs = Algorithms + Data Structures/Algorithm = Logic + Control，侧重说第二点
2. 第二个表达式则想表达，数据结构不复杂，复杂的是算法，也就是我们的业务逻辑是复杂的。我们的算法由两个逻辑组成，一个是真正的业务逻辑，另外一种是控制逻辑。程序中有两种代码，一种是真正的业务逻辑代码，另一种代码是控制我们程序的代码，叫控制代码，这根本不是业务逻辑，业务逻辑不关心这个事情。
3. 算法的效率往往可以通过提高控制部分的效率来实现，而无须改变逻辑部分。**就像函数式编程中的 Map/Reduce/Filter，它们都是一种控制。而传给这些控制模块的那个 lambda 表达式才是我们要解决的问题的逻辑，它们共同组成了一个算法。最后，我再把数据放在数据结构里进行处理，最终就成为了我们的程序。**
4. Control 是可以标准化的。比如：遍历数据、查找数据、多线程、并发、异步等，都是可以标准化的。因为 Control 需要处理数据，所以标准化 Control，需要标准化 Data Structure，我们可以通过泛型编程来解决这个事。而 Control 还要处理用户的业务逻辑，即 Logic。所以，我们可以通过标准化接口 / 协议来实现，我们的 Control 模式可以适配于任何的 Logic。
5. 编程范式的本质。有效地分离 Logic、Control 和 Data 是写出好程序的关键所在！
6. 好多代码，会把控制逻辑和业务逻辑放在一块。里面有些变量和流程是跟业务相关的，有些是不相关的。业务逻辑决定了程序的复杂度，业务逻辑本身就复杂，你的代码就不可能写得简单。
7. 控制一个程序流转的方式，即程序执行的方式，并行还是串行，同步还是异步，以及调度不同执行路径或模块，数据之间的存储关系，这些和业务逻辑没有关系。笔者最近的一个体会是，比如业务中应用和bundle是多对多关系，现在我要找一个应用的所有bundle，这个逻辑就应该抽象和隐藏掉，因为多对多是数据层面的事情。
8. 代码复杂度的原因：

	* 业务逻辑的复杂度决定了代码的复杂度；
	* 控制逻辑的复杂度 + 业务逻辑的复杂度 ==> 程序代码的混乱不堪；
	* 绝大多数程序复杂混乱的根本原因：业务逻辑与控制逻辑的耦合。

9. 如何分离 control 和 logic 呢？我们可以使用下面的这些技术来解耦。

	1. State Machine	
		* 状态定义
		* 状态变迁条件
		* 状态的 action

	2. DSL – Domain Specific Language
		* HTML，SQL，Unix Shell Script，AWK，正则表达式……

	3. 编程范式
		* 面向对象：委托、策略、桥接、修饰、IoC/DIP、MVC……
		* 函数式编程：修饰、管道、拼装
		* 逻辑推导式编程：Prolog

[程序的本质复杂性和元语言抽象](https://coolshell.cn/articles/10652.html)

1. 逻辑就是问题的定义，比如，对于排序问题来讲，逻辑就是“什么叫做有序，什么叫大于，什么叫小于，什么叫相等”？控制就是如何合理地安排时间和空间资源去实现逻辑。比如java collections 的sort 方法`public static <T> void sort(List<T> list, Comparator<? super T> comparator)`
2. 如果目标还是代码“简短、优雅、易理解、易维护”，那么代码优化是否有一个理论极限？这个极限是由什么决定的？**普通代码比起最优代码多出来的“冗余部分”到底干了些什么事情？**
2.  程序的本质复杂性就是逻辑，非本质复杂性就是控制。逻辑决定了代码复杂性的下限，也就是说不管怎么做代码优化，Office程序永远比Notepad程序复杂，这是因为前者的逻辑就更为复杂。如果要代码简洁优雅，任何语言和技术所能做的只是尽量接近这个本质复杂性，而不可能超越这个理论下限。（回答复杂性的极限）
3. 理解”程序的本质复杂性是由逻辑决定的”从理论上为我们指明了代码优化的方向：让逻辑和控制这两个维度保持正交关系。**绝大多数程序不够简洁优雅的根本原因：逻辑与控制耦合**
4. 每种组件形式都代表了特定的抽象维度，组件复用只能在其维度上进行抽象层次的提升。比如，我们可以把常用的HashMap等功能封装为类库，但是不管怎么封装复用类永远是类，封装虽然提升了代码的抽象层次，但是它永远不会变成Lambda，而实际问题所代表的抽象维度往往与之并不匹配。
5. 逻辑决定了程序的本质复杂性，但接口不是表达逻辑的通用方式，那么是否存在表达逻辑的通用方式呢？ 通过元语言抽象让逻辑和控制彻底解耦！有两种方式：元编程（比如thrift、定义了thrift文件，并提供一个thrfit 编译器）；元驱动编程，类似于下文的通用检查用户注册信息的逻辑。那么我们编写代码时，如何从业务中发现“元”（逻辑），是一个很有意义的问题，可以从`Collections.sort(xx,comparator)`开始。

	

		var meta_create_user = {
		    form_id : 'create_user',
		    fields : [
		        { id : 'name', type : 'text', min_length : 3 },
		        { id : 'password', type : 'password', min_length : 8 },
		        { id : 'repeat-password', type : 'password', min_length : 8 },
		        { id : 'email', type : 'email' }
		    ]
		};




