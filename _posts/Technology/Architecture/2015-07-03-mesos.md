---

layout: post
title: mesos简介
category: 技术
tags: Architecture
keywords: 分布式系统 mesos

---

## 简介

今天了解一下mesos，感觉老外就是牛，什么都想做一个框架出来，写一个分布式软件的难度一下子降低了好多，很多类似软件，都有用mesos重写一番，参见[http://mesos.apache.org/documentation/latest/mesos-frameworks/ ][]

从PaaS的大概念来理解mesos的小概念。在传统的IT架构里，我们分配资源的单位是服务器。**PaaS讲究的是将计算、存储和网络三大资源标准化，然后对上提供api**。原先部署某个服务，要自己到那个服务器上部署，而现在则是直接调接口（以docker为例，部署某个服务，就是命令某个主机执行docker run命令）。同时解决两个基本问题：

1. 资源管理。n个主机的资源现在统一分配了，一个任务可以漂移了（一会儿运行在a主机上，一会儿运行在b主机上）。原先一个任务占用资源的上限是其所在主机的全部资源，现在资源共享后，一个任务占用资源的理论上限是整个集群。这就需要管理
2. 任务调度。任务被调度在哪个机器上，任务挂了怎么办？

mesos集中于资源管理层面。

下面是来自apache官网的简介：

Apache Mesos abstracts CPU, memory, storage, and other compute resources away from machines (physical or virtual), enabling fault-tolerant and elastic distributed systems to easily be built and run effectively.

Mesos is built using the same principles as the Linux kernel, only at a different level of abstraction. The Mesos kernel runs on every machine and provides applications (e.g., Hadoop, Spark, Kafka, Elastic Search) with API’s for resource management and scheduling across entire datacenter and cloud environments.

这里有一句话很有意思，说mesos类似于linux kernel，但是集群层次的抽象。观察linux的进程控制块，是各种资源的结合（比如文件描述符）。启动进程，操作系统负责帮进程处理资源的获取和访问等问题。Mesos则允许更精细化的资源的切片和分割。底层的资源像CPU、内存等都完全抽象化，不在跟具体的物理机绑在一起分配。类似于，一个分布式文件系统将多个主机的存储能力聚合起来，mesos则是将多个主机的计算、内存等资源聚合起来。

引用Mesos paper里的一句话，来说明Mesos的设计理念：

define a minimal interface that enables efficient resource sharing across frameworks, and otherwise push control of task scheduling and execution to the frameworks

定义一个最小化的接口来支持跨框架的资源共享，其他的调度以及执行工作都委托给框架自己来控制。


## mesos简介

![Alt text](/public/upload/architecture/mesos.jpg)


mesos包括以下概念：

- Master daemon
- Slave daemon
- Scheduler 
- Executor    

    为task提供上下文环境
- task        

    具体的任务，类似hadoop中的map task和reduce task


master daemon和slave daemon很好解释，而对于Scheduler和Executor抽象，我们可以通过其接口来理解，接口包含了一系列回调函数：


    public abstract interface org.apache.mesos.Scheduler {
      // 向SchedulerDriver注册Scheduler
      public abstract void registered(org.apache.mesos.SchedulerDriver arg0, org.apache.mesos.Protos.FrameworkID arg1, org.apache.mesos.Protos.MasterInfo arg2);
      // 注册成功后
      public abstract void reregistered(org.apache.mesos.SchedulerDriver arg0, org.apache.mesos.Protos.MasterInfo arg1);
      // 处理来自各slave的Resource offer，以决定将task分配到哪个slave上
      public abstract void resourceOffers(org.apache.mesos.SchedulerDriver arg0, java.util.List arg1);
      // resource offer撤回
      public abstract void offerRescinded(org.apache.mesos.SchedulerDriver arg0, org.apache.mesos.Protos.OfferID arg1);
      // 某个task的状态发生改变
      public abstract void statusUpdate(org.apache.mesos.SchedulerDriver arg0, org.apache.mesos.Protos.TaskStatus arg1);
      // 收到来自某个Executor的消息
      public abstract void frameworkMessage(org.apache.mesos.SchedulerDriver arg0, org.apache.mesos.Protos.ExecutorID arg1, org.apache.mesos.Protos.SlaveID arg2, byte[] arg3);
      // "失联"后
      public abstract void disconnected(org.apache.mesos.SchedulerDriver arg0);
      // 某个slave"失联"后
      public abstract void slaveLost(org.apache.mesos.SchedulerDriver arg0, org.apache.mesos.Protos.SlaveID arg1);
      // 某个executor"失联"后
      public abstract void executorLost(org.apache.mesos.SchedulerDriver arg0, org.apache.mesos.Protos.ExecutorID arg1, org.apache.mesos.Protos.SlaveID arg2, int arg3);
      // 运行过程中发生错误时
      public abstract void error(org.apache.mesos.SchedulerDriver arg0, java.lang.String arg1);
    }

executor

    public abstract interface org.apache.mesos.Executor {
      // 向ExecutorDriver注册Executor
      public abstract void registered(org.apache.mesos.ExecutorDriver arg0, org.apache.mesos.Protos.ExecutorInfo arg1, org.apache.mesos.Protos.FrameworkInfo arg2, org.apache.mesos.Protos.SlaveInfo arg3);
      // 估计是注册成功后
      public abstract void reregistered(org.apache.mesos.ExecutorDriver arg0, org.apache.mesos.Protos.SlaveInfo arg1);
      // “失联”后
      public abstract void disconnected(org.apache.mesos.ExecutorDriver arg0);
      // 运行任务
      public abstract void launchTask(org.apache.mesos.ExecutorDriver arg0, org.apache.mesos.Protos.TaskInfo arg1);
      // 收到scheduler杀死task的命令
      public abstract void killTask(org.apache.mesos.ExecutorDriver arg0, org.apache.mesos.Protos.TaskID arg1);
      // 接受scheduler发送的消息
      public abstract void frameworkMessage(org.apache.mesos.ExecutorDriver arg0, byte[] arg1);
      // 收到scheduler shutdown的命令
      public abstract void shutdown(org.apache.mesos.ExecutorDriver arg0);
      // 运行过程中出错
      public abstract void error(org.apache.mesos.ExecutorDriver arg0, java.lang.String arg1);
    }


言而总之，scheduler和executor提供了一系列回调函数，由scheduler driver和executor driver在合适的时机调用。从这些函数中，我们可以看到，假如我们将Scheduler/Executor(task)作为分布式框架的基本模型，那么mesos封装了大量细节，比如：

- slave信息的汇集
- slave有效性检测
- Scheduler与Executor通信（包括task status汇报等）

从而大大减少我们编写一个分布式任务的复杂性。

## 简单的例子

[示例代码][]

本例由Driver、Scheduler和Executor三个类组成

1. Driver，类似于hadoop的驱动代码，该类主要完成以下工作：
 - Create Executor Info
 - Create Framework Info
 - Instantiate Scheduler
 - Starting the mesos scheduler driver
  
2. Scheduler

    为每个slave分配一个task，当所有的任务都finished后，停掉Scheduler driver
    
3. Executor

    执行任务（就是向Scheduler返回一个字符串）

我们通过`java -cp xx.jar xx.xx.Driver类`触发Driver执行，Driver触发scheduler driver，scheduler driver执行注册到其上的scheduler。

scheduler运行时，会将ExecutorInfo（参见[示例代码][]）发送到slave daemon，ExecutorInfo包含了executor的启动命令`java -cp xx.jar xx`，进而可以触发slave端的executor driver执行executor。


## 引用

[An Introduction to Mesosphere][]











[An Introduction to Mesosphere]: https://www.digitalocean.com/community/tutorials/an-introduction-to-mesosphere
[http://mesos.apache.org/documentation/latest/mesos-frameworks/ ]: http://mesos.apache.org/documentation/latest/mesos-frameworks/ 
[示例代码]: https://github.com/qiankunli/mesos/