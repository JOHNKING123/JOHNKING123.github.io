---

layout: post
title: 如何学习架构
category: 架构
tags: Architecture
keywords: project

---

## 简介

* TOC
{:toc}

借助[如何学习分布式系统](http://qiankunli.github.io/2018/04/16/learn_distributed_system.html) 得来的经验，当一个知识足够复杂，如何学习它本身就很值得玩味

到目前为止，笔者关于架构的几篇文章或笔记

1. [《软件架构设计》笔记](http://qiankunli.github.io/2019/04/16/architecture_design_note.html)
2. [反应式架构摸索](http://qiankunli.github.io/2019/01/21/reactive_architecture.html)
3. [系统设计的一些体会](http://qiankunli.github.io/2018/09/28/system_design.html)
4. [《左耳听风》笔记](http://qiankunli.github.io/2018/09/08/zuoertingfeng_note.html)
5. [《从0开始学架构》笔记](http://qiankunli.github.io/2018/05/06/architecture_from_0_note.html)

按照许式伟的说法，架构相关的图书大概有几类

1. 架构思维类。 通常从一些著名的架构理论讲起，比如开闭原则、单一职责原则等等。其弊端在于过度理论化，而计算机科学归根到底属于工程技术类，应该实践第一。
2. 设计模式类。 这类一般上来就进入架构的局部细节，每个模式的来龙去脉并不容易理解。就算理解了某个具体的模式，也很难真正做到活学活用。
3. 分布式系统架构设计类。 通常从服务端的通用问题如一致性、高可用、高并发挑战等话题讲起，阐述大型业务系统面临的挑战。这些知识虽然非常有价值，但无法延伸至通用业务架构，对大部分企业的架构实践不具备真正的指导意义。
4. 重构类。 主要讲如何如何改进代码，其实是最实用的一类。但在我看来，一个模块最初的地基是最重要的，基本决定了这座大厦能够撑多久，而重构更多侧重于大厦建成之后，在服务于人的前提下怎么去修修补补，延长生命。

## 架构总纲——纲举目张

语言、数据结构、算法、中间件使用等属于硬的内容，比如容易表述，也容易衡量。而架构设计，系统的“三高”则属于“隐性问题”

1. 因为一个系统设计问题导致研发人力的投入和时间成本的增加
2. 业务确实很复杂，做新功能有沉重的历史包袱，最终技术拖累业务

架构是针对所有重要问题做出的重要决策。很显然，不同公司不同阶段碰到的问题不同，架构所做的事情自然也不一样。

架构的道

1. 对于技术问题，主要指高并发、高可用和一致性方面
2. 对于业务问题，主要指业务的需求分析和业务建模

|道|术|
|---|---|
|内功心法|外功招式|
|知（理论）|行（实践）|
|问题|答案|

![](/public/upload/architecture/architecture.png)

当你碰到一篇文章，即可place it in context，分析其在架构知识的哪一层

## 系统架构

* 微服务 
* 一个问题在一个进程的多线程间存在，多半也在一台机器的多进程，多台机器的多进程间存在，而解决问题的思路多半是一样的，这也是学习基础的必要性所在。比如[一分钟实现分布式锁](http://www.10tiao.com/html/249/201612/2651959749/1.html)

[谈谈互联网后端基础设施](https://yq.aliyun.com/articles/66115)要点：

1. Api网关 
2. 业务应用和后端基础框架 
3. 缓存、数据库、搜索引擎、消息队列、文件存储 
4. 统一认证中心 单点登录系统 
5. 统一配置中心 
6. 服务治理框架 
7. 统一日志服务 
8. 数据基础设施 
9. 故障监控

这里的后端基础设施主要指的是应用在线上稳定运行需要依赖的关键组件/服务等。开发或者搭建好以上的后端基础设施，一般情况下是能够支撑很长一段时间内的业务的。此外，对于一个完整的架构来说，还有很多应用感知不到的系统基础服务，如负载均衡、自动化部署、系统安全等

### 并发读写

《软件架构设计》要让各式各样的业务功能与逻辑最终在计算机系统里实现，只能通过两种操作：读和写。PS：[并发读写是线程安全的核心问题](http://qiankunli.github.io/2014/10/09/Threads.html)

![](/public/upload/architecture/high_concurrency.png)

### 可用性与稳定性

![](/public/upload/architecture/high_availability.png)

## 业务架构

《软件架构设计》为什么要区分“业务架构”和“技术架构”？要时刻意识到我们面对的是业务问题还是技术问题。

### 方法论

![](/public/upload/architecture/businese_thought.png)

很多时候会遇到这样的情况：一个函数写了几百行代码，里面的if-else写了很多，计算各种业务规则。另一个人接手后，分析了好几天，才把业务逻辑彻底理清楚。**这个问题表面上看是代码写的不规范、要重构。从根本上讲，就是重要逻辑隐藏在代码里面，没有”显性“的表达出来**。这只是一个函数，推广到类、模块、系统，是同样的道理。

所以，建模的本质就是：把重要的东西进行显性化，进而把这些显性化的构造块互相串联起来，组成一个体系。**让它在”设计图纸“上可见，而不是分析完代码才能看出来**。重要的东西找到了，如何显性化呢？其实就是”命名“

### 典型/非典型架构

1. 典型架构：browser—server，app-server
	
	* [关于互联网“一致性”架构设计的一切](http://www.10tiao.com/html/249/201709/2651960408/1.html)
	* [互联网分层架构的本质](http://www.10tiao.com/html/249/201710/2651960455/1.html) 文章要点：互联网分层架构的本质，是数据的移动；互联网分层架构中，数据的传输格式（协议）与数据在各层次的形态很重要；互联网分层架构演进的核心原则与方法：封装与复用
	
2. 非典型架构：[秒杀，推送，广告，推荐，计数-互联网非典型业务系统架构设计](http://www.10tiao.com/html/249/201709/2651960426/1.html)

### 通用设计

1. 满足业务需求
2. 解耦 [为什么说解耦的战术，决定了架构的高度？](http://www.sohu.com/a/204009990_411876)

	* ip耦合：使用内网域名代替内网ip
	* 公共库耦合：业务个性强的垂直拆分，公共特性强的下沉服务化
	* 数据库耦合：垂直切分与服务化
	* 服务化耦合：剥离业务代码上浮
	* 消息通知耦合：MQ
	* 下游扩容耦合：配置中心

[互联网架构：屡试不爽的架构三马车](https://mp.weixin.qq.com/s/VBGeI308sbTn8qNY-wASjQ)：微服务、消息队列和定时任务

![](/public/upload/architecture/business_architecture.png)


## 串一串编程范式

[架构整洁之道, 看这一篇就够了！](https://mp.weixin.qq.com/s/Kd1T40KZWvdThKC3IN6n-Q)

架构是软件系统的一部分，所以要明白架构的价值，首先要明确软件系统的价值。软件系统的价值有两方面，行为价值和架构价值。

1. 行为价值是软件的核心价值，包括需求的实现，以及可用性保障（功能性 bug 、性能、稳定性）。这几乎占据了我们90%的工作内容，支撑业务先赢是我们工程师的首要责任。**如果业务是明确的、稳定的，架构的价值就可以忽略不计，但业务通常是不明确的、飞速发展的，这时架构就无比重要，因为架构的价值就是让我们的软件（Software）更软（Soft）**。
2. 架构价值

    1. 当需求变更时，所需的软件变更必须简单方便。
    2. 变更实施的难度应该和变更的范畴（scope）成等比，而与变更的具体形状（shape）无关。

实现行为价值的需求通常是 PD 提出的，都比较紧急，但并不总是特别重要；架构价值的工作内容，通常是开发同学提出的，都很重要但基本不是很紧急，短期内不做也死不了。我们开发同学，在低头敲代码之前，一定要把杂糅在一起的“重要且紧急”和“不重要但紧急”分开，把我们架构工作（“重要但不紧急”）插进去。

**其实所谓架构就是限制**，限制源码放在哪里、限制依赖、限制通信的方式，但这些限制比较上层。编程范式是最基础的限制，它限制我们的控制流和数据流：结构化编程限制了控制权的直接转移（限制了goto语句），面向对象编程限制了控制权的间接转移（限制了函数指针的使用），函数式编程限制了赋值

|编程范式||描述||
|---|---|---|---|
|结构化编程|限制控制权的直接转移|就是函数调用或者 goto 语句，代码在原来的流程里不继续执行了，转而去执行别的代码，并且你指明了执行什么代码。|限制goto语句|
|面向对象编程|限制控制权的间接转移|就是代码在原来的流程里不继续执行了，转而去执行别的代码，但具体执行了啥代码你也不知道，你只调了个函数指针或者接口。|限制函数指针|
|函数式编程|限制赋值|函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值||

没有结构化编程，程序就无法从一块块可证伪的逻辑搭建，没有面向对象编程，跨越组件边界会是一个非常麻烦而危险的过程，而函数式编程，让组件更加高效而稳定。没有编程范式，架构设计将无从谈起。

架构工作的基本方针

1. 尽可能长时间地保留尽可能多的可选项。
2. 低层次解耦方式能解决的，不要用高层次解耦方式。

组件拆分需要在两个维度进行：按层次拆分、按变更原因拆分。

## 从架构的过去看未来

[京东刘海锋：过去十年架构领域最重要的三个变化](https://mp.weixin.qq.com/s/_W9vUK8LY9RC1-QxfGFQSg)

架构领域经历了快速演进的十年。架构领域在整个互联网的技术栈是偏底层的，但过去十年架构领域的演进速度，一点都不亚于应用开发，甚至移动端开发的速度。比如容器，新型的数据库，新型的中间件，大规模集群的调度，以及系统跟算法的结合。比如

1. 容器
2. 数据库，数据库作为基础架构非常核心的组成部分，在过去的十年间里面有一个显著的特点是从大一统的一元的数据库逐渐走向多元，逐渐的走向为不同的应用场景而定制。以电商为例，一般来说会用 MySQL 以及 MySQL 的中间件，作为最关键的结构化存储，但同时会配上内存 KV Store 做加速、用检索型数据库做全文检索，用时间序列数据库做海量数据的监控采集和分析，等等。从 DB 底层核心技术来看，跨地域复制且强一致复制、计算与存储分离、**从以磁盘为中心到以内存为中心**，是三个非常显著的技术变迁。
3. 系统跟算法的结合越来越紧密，系统跟算法一起形成一家公司的技术的基石，系统相当于是骨架，而算法给骨架注入了灵魂。


软件架构，唯一不变的就是变化，但变化又分成了波动与趋势，所以对趋势的把握显得尤为重要。未来的两个预测

1. 架构智能化
2. 混合多云，接下来 5 到 10 年，很多大中型企业，他们重要的业务一定会横跨自己的数据中心和不同云服务商的数据中心。一定会有框架出现来屏蔽底层的这些差异与复杂性

## 一些体会

1. 很多技巧是通用的，比如批量，哪怕只取一条记录，操作系统也会从磁盘上将记录所在磁盘块读到内存。对于到mysql则是一个数据页，业务系统经常一次查询多个id。其它诸如缓存等莫不如是。
2. 很多问题是通用的，这点跟第一点一脉相承。比如线程安全问题，操作系统有，mysql也有，业务系统也经常有。异步io，可以在上层如业务或mysql中伪装实现，也可以直接操作系统提供。一个问题，在哪个层次解决最合适，也是一个问题。
3. 由[互联网分层架构的本质](http://www.10tiao.com/html/249/201710/2651960455/1.html) 想到的数据在不同介质的表现形式，以mysql innodb存储引擎为例

	||表现形式|
	|---|---|
	|业务系统|一个数据对象|
	|java对象在内存|参见java对象内存模型|
	|mysql逻辑上|一行记录|
	|mysql一行记录在内存|例如compact、redundant等行记录格式|
	|mysql一页记录在内存|例如antelope、barracuda等格式|
	|mysql一页记录在文件系统|假设页大小16kb，内存数据整体复制到磁盘，地址范围page offset ~ page offset + 16kb|
	|mysql表数据在硬盘|假设启动innodb_file_per_table，对应一个xx.ibd文件|
	|一个文件在操作系统|file id|
	|一个文件在磁盘|几个磁盘块 + 部分inode块|
	
4. 上层抹不去的底层印记。磁盘天然的随机读写慢于顺序读写，迫使os、mysql进行了大量的缓冲优化。cpu缓存、java内存模型导致的变量可见性问题，事务可见性问题等。