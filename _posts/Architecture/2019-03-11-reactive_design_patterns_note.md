---

layout: post
title: 《反应式设计模式》笔记
category: 架构
tags: Architecture
keywords: project

---

## 简介（持续更新）

* TOC
{:toc}

预备几个问题

1. 为什么消息驱动是 反应式架构的底层实现？

## 为什么需要反应式

我们的初衷是构建一个对用户即时响应的系统，无论什么情况下都能响应用户的输入。由于任何单台计算机在任何时刻都可能宕机，因此我们需要将系统分布到多台计算机上。引入分布式结构这个额外的基础需求使我们意识到：构建这样的系统需要新的架构模式（或者重新发现旧模式）。过去我们建立了各种方法来维持某种表象：单线程的本地运算能够魔法般的扩展运行在多个处理器核心或网络节点上（PS：比如hadoop，写mapreduce就像在写单机程序一样）。然而虚实之间的沟壑已经大到难以为继。**解决方法是让我们应用程序中所具有的分布和并发的本质明明白白的反映到编程模型上来，并使其变成我们的优势**。

![](/public/upload/architecture/reactive_value_structure.png)

与很多成功想法一样，反应式的多项原则被过度使用和重新诠释。这不纯粹是坏事；**思想需要不断进化，从而保持相关性。但这也会引起混淆，导致原始意图被淡化**。例如一种不幸的流行误解是：反应式编程无非就是使用回调或面向流的组合 进行异步和非阻塞的编程。PS: 我们学习很多技术，都误解了初衷， 进而迷惑在细节中，**价值结构图要多画一画**。

以邮箱系统为例， 开始这样一个项目，首要任务是描绘出部署的架构图，并草拟出需要开发的软件模块清单。这也许不会是最终架构，但是你需要**描绘问题空间**，并探寻潜在的难点。层次化拆分的结果是一套层次分明的组件，每个组件就其功能而言可能是复杂的，例如搜索算法的实现。也可能其部署和编排过程是复杂的，例如为几十亿用户提供邮件存储。但在描述组件的个体职责时，总是应该保持简洁。

![](/public/upload/architecture/email_system.png)

消息流设计：对于由任意后端服务之间无限制的交互所产生的混乱问题，解决方法是专注于整个应用内的通信链路，并专门设计它们。

## 反应式宣言解读

![](/public/upload/architecture/reactive_manifest.png)

### 对用户做出反应

![](/public/upload/architecture/before_reactive.png)

传统方法，本质上 一个用户请求的处理是单线程 接力完成。或者说，或许经过多个线程，但某个时刻只有单个线程在处理请求。对用户做出反应，用户请求体现在连接数，干活的是线程，性能调优就是连接数与线程数的纠葛。

|性能调优||
|---|---|
|连接数>线程数|无意义|
|连接数=线程数|新的请求等待|
|连接池<线程数|服务能力不足|

顺序执行模型，调用方、被调用方、调用方对结果的处理在同一个线程上同步进行，紧密耦合，所以失败会以同样的方式影响两者。

并行执行通常需要额外的思考和库的支持

1. 任务并行执行， 调用方等着耗时最长的任务结束再进行下一步处理
2. 进阶——异步结果组合。难道通过并行来降低响应延迟还不够吗？假设一个任务由ABC三个子任务组成，ABC均返回Future，任务可能是一个更高层级的子任务，也理应返回Future。并行执行必须与异步的、面向任务的结果聚合配合使用。

阻塞API ==> 大量线程等待 ==> 除了[线程切换的成本](http://qiankunli.github.io/2014/10/09/Threads.html)，内核调度程序很难找出哪些线程是可运行的，哪些线程是正在等待的，也很难选择其中一个线程，使得每个线程都能获得公平的CPU时间片。操作系统内核负责线程切换，却难以业务友好的进行切换 ==> 使用消息作为沟通媒介（正是内核的运行机制——中断），不是挂起线程，只是挂起计算。

在并行计算中，一个使用多个处理器的程序的速度提升受限于程序中顺序执行部分的占比。PS：消息传递天然的可以提高程序的并行度。

**挂起线程 vs 挂起计算**：不管是同步还是异步，只要被调用方处理能力不足、网络通信存在耗时、竞争资源有限，排队是一定要排队的，只是排队的是线程还是消息罢了（就好比没有邮箱时你要邮局排队等窗口，有了邮箱你信放邮箱里，人等着vs信等着）。[线程排队](http://qiankunli.github.io/2018/12/11/thread_queued.html)

### 对失败作出反应

只有一种通用的方法来防止你的系统在部分失败时牵连整个系统：distribute（不要把鸡蛋放在一个篮子里） 和 compartmentalize（保护你的篮子，避免它们互相影响）

回弹和容错

1. 容错，比如备份儿，坏了一个还有另一个
2. 回弹，回弹性更多的谈论出错的事情的性质， 比如断路器。PS：”弹“指的是一次断路器断开、闭合无需人工干预，系统具有根据一定策略自适应能力。

### 反应式设计模式

提升抽象水平已被证明是提高程序猿生产效率的最有效措施。复杂性有两种，以一个容器平台为例

1. 固有的复杂性，是问题领域所固有的。配置cpu/mem/健康检查接口是 pass领域固有的，服务运行在物理机上也要配相关参数。
2. 附带的复杂性，仅由解决方案所引入的。docker命令和Dockerfile 是docker 这个解决方案本身引入的。

**一个适当的解决方案是暴露问题领域中的所有固有复杂性， 使其可以根据具体的使用情况进行处理，并且避免了由于所选择的抽象和底层机制之间的不匹配而导致的附加复杂性给用户带来的负担**（系统设计的精辟之言）。 这意味着，随着你对问题领域理解的不断深化评估现有的抽象，考虑它们是否抓住了固有复杂性以及又增加了多少附带复杂性。

## 消息传递 vs 方法调用

![](/public/upload/architecture/reactive_message_delivery.png)

消息传递 的对立面是方法调用，方法调用 使得调用方和被调用方是紧耦合的，体现在

1. 方法调用不管是同步还是异步，调用方都要按要求输入参数处理返回结果，有时需处理异常，必要时还得将同步方法异步化（如果不想被“被调用方”阻塞住的话）
2. 通信是同步的，接收方对如何及何时处理请求没有发言权，如果被调用方过载，就只能把调用方“阻塞”住

基于事件的系统通常建立在一个事件循环上。任何时刻只要发生了事情， 对应的事件就会被追加到一个队列中。事件循环持续的从队列中拉取事件，并执行绑定在事件上的回调函数。每一个回调函数通常都是一段微小的、匿名的、响应特定事件（例如鼠标点击）的过程。回调函数也可能产生新事件，这些事件随后也会被追加到队列里面等待处理。

基于消息的系统，不管是生产者还是消息系统本身都不需要考虑如何对消息产生正确的响应，由当前所配置的消费者来做这个决定

因为消息传递解耦了调用方和被调用方，书中用了一个词叫垂直伸缩，估计是你可以在一个调用链路上的某个环节 的处理能力，如下图

![](/public/upload/architecture/reactive_vertical_scaling.png)

在类C语言中常见的直接方法调用（direct method invocation），自身带有一种特定的流量控制：请求的发送者被接收者阻塞，直到处理过程结束。当多个发送者竞争同一个接收者的资源时，通常利用锁或信号量等同步方式，来串行化处理过程。 这种处理额外的阻塞了每个发送者，使其必须等待，直到前一个发送者的消息被处理完毕。这种隐式的回压一开始看起来好像很方便，但是当系统增长以及非功能性（吞吐量等）要求变得越来越重要时，它就会变成一种阻碍。你会发现自己花费很多时间调试性能瓶颈，而不是实现业务逻辑。（PS：以消息传递的视角来描述并发问题，很陶醉）消息传递为流量控制方案提供了更大的选择范围，因为它引入了队列概念（其实就是锁、信号量队列的显式化）。

## 其它

对用户做出反应 ==> 并行 ==> 复制（消息传递）替掉共享，无副作用 ==> 函数式编程

[全面异步化：淘宝反应式架构升级探索](https://www.infoq.cn/article/2upHTmd0pOEUNmhY5-Ay) 消息驱动强调无阻塞、无 callback，所以不会有线程挂在那里，不会有持续的资源消耗。同时，事件驱动或消息驱动都是异步化，而**异步化会将操作系统中的队列情况显式地提升到了应用层**，使得应用层可以显式根据队列的情况来进行压力负载的感知

操作系统的内存分配、进程/线程调度、队列等 显式到 应用层，看起来是一个趋势。





