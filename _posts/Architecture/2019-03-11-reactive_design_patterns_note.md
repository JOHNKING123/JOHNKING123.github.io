---

layout: post
title: 《反应式设计模式》笔记
category: 架构
tags: Architecture
keywords: project

---

## 简介（持续更新）

* TOC
{:toc}

## 为什么需要反应式

我们的初衷是构建一个对用户即时响应的系统，无论什么情况下都能响应用户的输入。由于任何单台计算机在任何时刻都可能宕机，因此我们需要将系统分布到多台计算机上。引入分布式结构这个额外的基础需求使我们意识到：构建这样的系统需要新的架构模式（或者重新发现旧模式）。过去我们建立了各种方法来维持某种表象：单线程的本地运算能够魔法般的扩展运行在多个处理器核心或网络节点上（PS：比如hadoop，写mapreduce就像在写单机程序一样）。然而虚实之间的沟壑已经大到难以为继。**解决方法是让我们应用程序中所具有的分布和并发的本质明明白白的反映到编程模型上来，并使其变成我们的优势**。

![](/public/upload/architecture/reactive_value_structure.png)

与很多成功想法一样，反应式的多项原则被过度使用和重新诠释。这不纯粹是坏事；**思想需要不断进化，从而保持相关性。但这也会引起混淆，导致原始意图被淡化**。例如一种不幸的流行误解是：反应式编程无非就是使用回调或面向流的组合 进行异步和非阻塞的编程。PS: 我们学习很多技术，都误解了初衷， 进而迷惑在细节中，**价值结构图要多画一画**。

以邮箱系统为例， 开始这样一个项目，首要任务是描绘出部署的架构图，并草拟出需要开发的软件模块清单。这也许不会是最终架构，但是你需要**描绘问题空间**，并探寻潜在的难点。层次化拆分的结果是一套层次分明的组件，每个组件就其功能而言可能是复杂的，例如搜索算法的实现。也可能其部署和编排过程是复杂的，例如为几十亿用户提供邮件存储。但在描述组件的个体职责时，总是应该保持简洁。

![](/public/upload/architecture/email_system.png)

消息流设计：对于由任意后端服务之间无限制的交互所产生的混乱问题，解决方法是专注于整个应用内的通信链路，并专门设计它们。

## 反应式宣言解读

![](/public/upload/architecture/reactive_manifesto.png)

### 对用户做出反应

![](/public/upload/architecture/before_reactive.png)

传统方法，本质上 一个用户请求的处理是单线程 接力完成。或者说，或许经过多个线程，但某个时刻只有单个线程在处理请求。对用户做出反应，用户请求体现在连接数，干活的是线程，性能调优就是连接数与线程数的纠葛。

|性能调优||
|---|---|
|连接数>线程数|无意义|
|连接数=线程数|新的请求等待|
|连接池<线程数|服务能力不足|

顺序执行模型，调用方、被调用方、调用方对结果的处理在同一个线程上同步进行，紧密耦合，所以失败会以同样的方式影响两者。

并行执行通常需要额外的思考和库的支持

1. 任务并行执行， 调用方等着耗时最长的任务结束再进行下一步处理
2. 进阶——异步结果组合。难道通过并行来降低响应延迟还不够吗？假设一个任务由ABC三个子任务组成，ABC均返回Future，任务可能是一个更高层级的子任务，也理应返回Future。并行执行必须与异步的、面向任务的结果聚合配合使用。

阻塞API ==> 大量线程等待 ==> 除了[线程切换的成本](http://qiankunli.github.io/2014/10/09/Threads.html)，内核调度程序很难找出哪些线程是可运行的，哪些线程是正在等待的，也很难选择其中一个线程，使得每个线程都能获得公平的CPU时间片。操作系统内核负责线程切换，却难以业务友好的进行切换 ==> 使用消息作为沟通媒介（正是内核的运行机制——中断），不是挂起线程，只是挂起计算

在并行计算中，一个使用多个处理器的程序的速度提升受限于程序中顺序执行部分的占比。

### 对失败作出反应

只有一种通用的方法来防止你的系统在部分失败时牵连整个系统：distribute（不要把鸡蛋放在一个篮子里） 和 compartmentalize（保护你的篮子，避免它们互相影响）

回弹和容错

1. 容错，比如备份儿，坏了一个还有另一个
2. 回弹，回弹性更多的谈论出错的事情的性质， 比如断路器。PS：”弹“指的是一次断路器断开、闭合无需人工干预，系统具有根据一定策略自适应能力。

### 反应式设计模式

提升抽象水平已被证明是提高程序猿生产效率的最有效措施。复杂性有两种，以一个容器平台为例

1. 固有的复杂性，是问题领域所固有的。配置cpu/mem/健康检查接口是 pass领域固有的，服务运行在物理机上也要配相关参数。
2. 附带的复杂性，仅由解决方案所引入的。docker命令和Dockerfile 是docker 这个解决方案本身引入的。

**一个适当的解决方案是暴露问题领域中的所有固有复杂性， 使其可以根据具体的使用情况进行处理，并且避免了由于所选择的抽象和底层机制之间的不匹配而导致的附加复杂性给用户带来的负担**（系统设计的精辟之言）。 这意味着，随着你对问题领域理解的不断深化评估现有的抽象，考虑它们是否抓住了固有复杂性以及又增加了多少附带复杂性。