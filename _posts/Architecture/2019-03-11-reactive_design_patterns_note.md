---

layout: post
title: 《反应式设计模式》笔记
category: 架构
tags: Architecture
keywords: project

---

## 简介（持续更新）

* TOC
{:toc}

## 为什么需要反应式

我们的初衷是构建一个对用户即时响应的系统，无论什么情况下都能响应用户的输入。由于任何单台计算机在任何时刻都可能宕机，因此我们需要将系统分布到多台计算机上。引入分布式结构这个额外的基础需求使我们意识到：构建这样的系统需要新的架构模式（或者重新发现旧模式）。过去我们建立了各种方法来维持某种表象：单线程的本地运算能够魔法般的扩展运行在多个处理器核心或网络节点上（PS：比如hadoop，写mapreduce就像在写单机程序一样）。然而虚实之间的沟壑已经大到难以为继。**解决方法是让我们应用程序中所具有的分布和并发的本质明明白白的反映到编程模型上来，并使其变成我们的优势**。

![](/public/upload/architecture/reactive_value_structure.png)

与很多成功想法一样，反应式的多项原则被过度使用和重新诠释。这不纯粹是坏事；**思想需要不断进化，从而保持相关性。但这也会引起混淆，导致原始意图被淡化**。例如一种不幸的流行误解是：反应式编程无非就是使用回调或面向流的组合 进行异步和非阻塞的编程。PS: 我们学习很多技术，都误解了初衷， 进而迷惑在细节中，**价值结构图要多画一画**。

以邮箱系统为例， 开始这样一个项目，首要任务是描绘出部署的架构图，并草拟出需要开发的软件模块清单。这也许不会是最终架构，但是你需要**描绘问题空间**，并探寻潜在的难点。层次化拆分的结果是一套层次分明的组件，每个组件就其功能而言可能是复杂的，例如搜索算法的实现。也可能其部署和编排过程是复杂的，例如为几十亿用户提供邮件存储。但在描述组件的个体职责时，总是应该保持简洁。

![](/public/upload/architecture/email_system.png)

消息流设计：对于由任意后端服务之间无限制的交互所产生的混乱问题，解决方法是专注于整个应用内的通信链路，并专门设计它们。

## 反应式宣言解读

![](/public/upload/architecture/reactive_manifesto.png)

### 对用户做出反应

![](/public/upload/architecture/before_reactive.png)

传统方法，本质上 一个用户请求的处理是单线程 接力完成。或者说，或许经过多个线程，但某个时刻只有单个线程在处理请求。对用户做出反应，用户请求体现在连接数，干活的是线程，性能调优就是连接数与线程数的纠葛。

|性能调优||
|---|---|
|连接数>线程数|无意义|
|连接数=线程数|新的请求等待|
|连接池<线程数|服务能力不足|

