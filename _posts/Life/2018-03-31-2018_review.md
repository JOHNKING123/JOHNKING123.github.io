---

layout: post
title: 2018 目标
category: 生活
tags: Life
keywords: coder

---

## 简介（未完成）

占个坑

本文档 会在年底 变成18年 小结

起因，今天听了阿里口碑的架构分享，有了一些新的认识

具体内容 参见今天的日记

## tips

如何理解业务？

负责平台支持，做了很多前后端结合的系统，即用户操作界面，进而改变客户端、服务端的行为。因为做出来的东西偏技术领域，也主要给程序猿用，所以没有产品经理。

做用户界面，通常在程序猿来看，是很low的项目。但笔者发现，如何设计用户界面 ==> 抽象最基本的操作给用户，多一步都是浪费 ==> 思考业务，是一脉相承的。

最开始设计用户界面的时候，就是直来直去。以数据库设计出发，数据库有几个表，界面上就有几个（或者少一两个）域概念的增删改查。

给用户的api（高层次的api），跟底层操作的 api（低层次的api） 是截然不同的


## 技术发展

1. 工作所需的组件会用，会基本的排查，最好读过源码
2. 实现过 相当复杂度的组件
3. 形成一种常识与判断。比如开车，你左右转向要提前观察左右后视镜、超车时要关注对向来车、前面的车什么行为什么意图。

历程：

1. 觉得代码实现是难点
2. 觉得数据库设计是难点。因为数据库设计有了，代码也就定了。一个学生信息管理系统，数据库设计自然没啥。但对于一个权限管理系统、审批流系统，数据库设计就很有含量了
3. 觉得业务抽象是难点。比如一个配置中心系统、ABTest 系统有哪些基本抽象，如何入手。此时是不是用数据库存储都是一个问题，比如还可以存在zk上。
4. 实现一个有闭环的平台类系统，比如风控系统等。

	* 首先它的输入是各种各样，输出也是各种各样的。
	* 各种技术的结合。java 业务处理、spark数据处理等
	* 性能要求带来的复杂度

对于第4点，也可以换个角度看，笔者曾经实现一个推送系统，各阶段如下：

1. 可送达，将业务方的消息送达到客户端。这中间涉及到推送的基本概念等
2. 可调控，比如频控，限制某个业务方的消息，以防止推送过多对用户的打扰。此外，动态调度，保证推送服务器的负载相对均衡
3. 推送系统与业务方的关系问题。比如一个业务的推送点击率很低，那么如何提高？是推送系统做还是业务方来做？这里面就需要你自己形成一套方法论，这个方法论的形成需要你的实践与沟通。沟通可不简单啊，你找人家，人家也得有时间，或者过几天他想法又变了
4. 推送系统达到一个均衡。老板比较关心点击率，业务方却只想要更多的推送机会，你担心会对用户形成打扰。推送与业务方的接口，数据报告（用数据而不是感觉说话）。这个过程中，你的人力有限，先做什么后做什么。


本质上，springmvc等，也是各种信息 获取、存放和处理，存储机制可以是xml文件、内存等

很多事情做到某个程度就行，说明你还没有逼自己。

## 学习工作习惯

实践才是学东西最快的，不追求某项特定的技术，而是追求去做 有足够复杂度的项目。项目可以做的比较复杂，但你能不能设计的比较简单。

不要着急对 钉钉消息做回复，如果真的特别紧急，他们会到工位上来找你的（有人来找你，也可以一会儿再说）。要做的工作 写在 任务软件上，完成一个活儿，勾掉这个任务，再去响应钉钉，此时解决钉钉中同事的问题，也算是换脑子。

早上要列清单，比如今天有几个面试啥的。周报可以今天干啥、明天干啥，但你自己要有日报。

无动机不学习。学一个东西，一定要有一个还算强烈的动机。学一阵儿，发现没兴趣了，也不要沮丧，或者因为你累了，或者外界需求还比较弱，那就等一等，攒一攒和需求，等好了再学。

允许自己漫无目的的学，哪怕看看自己的博客，改改其中的错漏，一天下来也感觉很充实。用收获感对抗焦虑。

纲举目张，几年买了一个付费节目，一个付费节目本身学到东西，另一个是作者在论述文章时，产生很多名词，提到过好多书（我买了几本）。除了字面上内容的提升，还有其隐含的知识体系的提升。

研究源码，类图就好比 一个地图的 各个山头，虽然不是地图的全部，但撑起了骨架。

排bug 教训

1. 一个要提高各种感知手段。报警、性能图表等，查看服务器连接状态、heap dump、thread dump等
2. 如果项目 在非高峰报警了，那么在高峰 时期很有可能就是大事情。

制定计划的时候，多找几个人问问。我曾经处理过一个项目，为了提高效率，我想到了一个diff 算法，当时认为这是最高效的，当然代码的复杂性也增加一个量级，我乐此不疲的倒腾除了一个这个复杂算法。复杂就意味着容易出错，当后来大家再去审视那个代码的时候，发现一个很简单的方案就可以解决。


## 三年小结

到今年7月份就工作3年了，回过头看过去3年，再看以后，有哪些脉络和教训。

1. 第一个坎，从学生到工作的转变。第二个坎，不用带脑子也能完成一天的工作。那么下一步怎么搞？
1. 头三年是锻炼基本能力的三年。说白了就是单兵能力的提升

	* 基本工作组件（语言、存储）的熟悉，以能实现编码任务
	* 技术依赖组件的熟悉，以使故障时能够发现原因
	* 源码阅读及分析
	* 对程序开发有个宏观认识

2. 那么以后呢？要做成更大的系统，一定是调动多个人的力量。要做成更大的项目，一定是团结多个团队的力量。为此

	* 做好心理上的准备。作为技术人，难免觉得技术才是最牛逼的。技术，更确切的是写代码，并不是难度最大的事情。但你敢这么说的 前提一定是 你基础比较扎实
	* 自己成为驱动的源头，驱动人，驱动事儿。做驱动，心理上的准备也是很重要的，“这事儿该不该我做” 是一个很费心神的问题。
	* 做好驱动的一个必要条件是，能从琐碎中脱身。一个是人的注意力有限，注意好琐碎就管不好大局。一个是人都有逃避心理，比如我负责一个项目，就很烦那个项目了。

从精确到模糊。各种维度的从精确到模糊。

1. 实现一个功能，到实现一个系统，而这个系统甚至需求都是模糊的。
2. 排错，从排查代码的bug 到 排查系统的bug。代码有日志报警，而用户只能告诉你：刷不出页面。

### 技术成长

程序猿水平晋级 跟玩户外是一样的

1. 只是参与出去玩，但事儿多
2. 出去玩，自己管自己
3. 出去玩，主动地做点事儿
4. 当押队，交代事情做
5. 当副队，是个可以商量的人，能全面考虑事情，给出建议
6. 当领队，独自筹划大部分事情
7. 不错的领队

[技术的成长曲线](http://zhangtielei.com/posts/blog-growth-curve.html)熟手：技术还无法自成体系，能理解到的知识架构还有所残缺。他解决问题所依靠的，更多是经验而非缜密的逻辑。而从熟手向专家的突破，则需要系统地去补习知识架构。技巧应该建立在对于普遍规则的理解之上.

分层无处不在，不要让一个函数 里出现不同抽象层次的代码，另一个角度说， 很多时候脑子乱也是如此。